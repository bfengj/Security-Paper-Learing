<!DOCTYPE html>
<!-- saved from url=(0098)https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/ -->
<html lang="en" data-bs-theme="light" style="scroll-padding-top: 76px;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/img/favicon.ico">
        <title>Devfile file write vulnerability in GitLab - GitLab Security Tech Notes</title>
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/bootstrap.min.css" rel="stylesheet">
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/fontawesome.min.css" rel="stylesheet">
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/brands.min.css" rel="stylesheet">
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/solid.min.css" rel="stylesheet">
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/v4-font-face.min.css" rel="stylesheet">
        <link href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/github.min.css">
        <link id="hljs-dark" rel="stylesheet" href="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/github-dark.min.css" disabled="">
        <script src="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body style="" class="">
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary" style="">
            <div class="container">
                <a class="navbar-brand" href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/">GitLab Security Tech Notes</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/" class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/red-team-tech-notes/" class="nav-link">Red Team</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/" class="nav-link">Security Research</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary" style="top: 76px;">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#devfile-file-write-vulnerability-in-gitlab" class="nav-link active">Devfile file write vulnerability in GitLab</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#starting-point-dependencies" class="nav-link">Starting point: dependencies</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#digging-deeper" class="nav-link">Digging deeper</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#one-step-back-and-three-steps-forward" class="nav-link">One step back and three steps forward</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#writing-files-where-they-dont-belong" class="nav-link">Writing files where they don't belong</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="https://gitlab-com.gitlab.io/gl-security/security-tech-notes/security-research-tech-notes/devfile/#conclusions" class="nav-link">Conclusions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="devfile-file-write-vulnerability-in-gitlab">Devfile file write vulnerability in GitLab</h1>
<p>This post is a extensive walkthrough of the process of identifying and exploiting
<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-0402">CVE-2024-0402</a>.</p>
<p>The vulnerability in GitLab was fixed on January 25th 2024 with a
<a href="https://about.gitlab.com/releases/2024/01/25/critical-security-release-gitlab-16-8-1-released/#arbitrary-file-write-while-creating-workspace">Critical Security Release</a>.</p>
<p>Sometimes exploits for vulnerabilities are like onions: they have layers.
This particular exploit had several layers and two underlying vulnerabilities
which were used in combination to achieve an arbitrary file write on a GitLab
instance. This file write then can be further abused to run arbitrary commands
on a GitLab instance. This post will cover the general approaches to identify
such issues and the technical details the exploit relies upon. However we'll spare
the full end-to-end exploit as we deem the underlying techniques and approaches
much more relevant in general than sharing an exploit for a patched vulnerability.</p>
<h2 id="starting-point-dependencies">Starting point: dependencies</h2>
<p>The adventure started by looking at the <a href="https://gitlab.com/gitlab-org/gitlab/-/blob/1fb74032a0aa55286e18428b3cedd001891555b7/Gemfile#L648">dependencies</a>
of the <a href="https://gitlab.com/gitlab-org/gitlab"><code>GitLab</code></a> main project.</p>
<p>While looking for some low-hanging fruit in the project dependencies I noticed the
<code>devfile</code> <a href="https://gitlab.com/gitlab-org/ruby/gems/devfile-gem/">Gem</a> making
<a href="https://gitlab.com/gitlab-org/ruby/gems/devfile-gem/-/blob/1573dfa774a9d2c8f1335095c7f1ff5f7853f2d9/lib/devfile.rb#L45">calls to an external helper binary</a>
by using <a href="https://docs.ruby-lang.org/en/2.0.0/Open3.html#method-i-capture3"><code>Open3.capture3</code></a>.
Calling external binaries is a typical red flag for me, there are many things
which might go sideways. Command or Argument injections for example, or other
surprises from lesser known features of the called binary. Not to speak of actual
vulnerabilities in the binary or its dependencies.</p>
<p>Notably the <code>devfile</code> Gem is written <a href="https://gitlab.com/gitlab-org/ruby/gems/devfile-gem/">in-house at GitLab</a>.
A quick review of the repository revealed <a href="https://gitlab.com/gitlab-org/ruby/gems/devfile-gem/-/blob/1573dfa774a9d2c8f1335095c7f1ff5f7853f2d9/ext/">some Go based code</a>
from which the <code>devfile</code> binary called by the Ruby Gem was being created. I didn't
know much about <a href="https://devfile.io/">Devfiles</a> at this point. I only had the
vague concept in the back of my head that those were YAML files used to describe
the environments for <a href="https://docs.gitlab.com/ee/user/workspace/">GitLab's Workspaces</a>
feature.</p>
<p>Workspaces are isolated web-based development environments which are deployed by
the GitLab application into Kubernetes clusters. Zooming out a bit we have:</p>
<ul>
<li>Devfiles: YAML files which are used to describe Workspaces in Kubernetes environments</li>
<li>A Ruby library which parses those devfiles by calling a Go based helper binary</li>
</ul>
<p>A quick check of the <a href="https://gitlab.com/gitlab-org/ruby/gems/devfile-gem/-/blob/1573dfa774a9d2c8f1335095c7f1ff5f7853f2d9/lib/devfile.rb#L45">Ruby code calling the Go binary</a>
showed there were no surprises or low hanging fruits. The binary is being
called directly with no shell being involved, simple command injections were not
possible. Also the Go binary had no opportunity for Argument injections.</p>
<h2 id="digging-deeper">Digging deeper</h2>
<p>Sometimes it's great to just start messing around with a software to get
a feeling for potential vulnerabilities. The design of the <code>devfile</code> Gem
made this easy. I could just use the included Go based binary and feed it
some YAML. Digging into the <a href="https://devfile.io/docs/">documentation</a>
and looking for some sample files to use I came across the <a href="https://devfile.io/docs/2.2.2/referring-to-a-parent-devfile"><code>parent</code></a>
feature which allows another <code>devfile</code> to be specified. That file is then used as a
base for your current <code>devfile</code>. I used the example from the
<a href="https://devfile.io/docs/2.2.2/referring-to-a-parent-devfile#parent-referred-by-uri">documentation</a>
with the <code>devfile</code> binary in the Gem like so:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/deps/ruby/</span><span class="hljs-number">3.2</span>.<span class="hljs-number">0</span>/gems/devfile-<span class="hljs-number">0.0</span>.<span class="hljs-number">25</span>.pre.alpha1-x86_64-linux/bin<span class="hljs-variable">$ </span>ls
devfile
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/deps/ruby/</span><span class="hljs-number">3.2</span>.<span class="hljs-number">0</span>/gems/devfile-<span class="hljs-number">0.0</span>.<span class="hljs-number">25</span>.pre.alpha1-x86_64-linux/bin<span class="hljs-variable">$ </span>./devfile flatten <span class="hljs-string">'schemaVersion: 2.2.0
metadata:
  name: my-project-dev
parent:
  uri: https://raw.githubusercontent.com/devfile/registry/main/stacks/nodejs/devfile.yaml'</span>
failed to <span class="hljs-symbol">populateAndParseDevfile:</span> error getting devfile info from <span class="hljs-symbol">url:</span> failed to retrieve <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/raw.githubusercontent.com/devfile</span><span class="hljs-regexp">/registry/main</span><span class="hljs-regexp">/stacks/nodejs</span><span class="hljs-regexp">/devfile.yaml, 404: Not Foundjoern@host2:~/projects</span><span class="hljs-regexp">/deps/ruby</span><span class="hljs-regexp">/3.2.0/gems</span><span class="hljs-regexp">/devfile-0.0.25.pre.alpha1-x86_64-linux/bin</span><span class="hljs-variable">$ </span>
</code></pre>
<p>I was quite surprised when I did a <code>ls</code> in the directory after that command:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/deps/ruby/</span><span class="hljs-number">3.2</span>.<span class="hljs-number">0</span>/gems/devfile-<span class="hljs-number">0.0</span>.<span class="hljs-number">25</span>.pre.alpha1-x86_64-linux/bin<span class="hljs-variable">$ </span>ls
<span class="hljs-number">2.1</span>.<span class="hljs-number">1</span>  <span class="hljs-number">2.2</span>.<span class="hljs-number">0</span>  devfile  <span class="hljs-variable constant_">OWNERS</span>  stack.yaml
</code></pre>
<p>A directory from the <a href="https://github.com/devfile/registry/tree/main/stacks/nodejs"><code>devfile/registry</code> repository</a>
has been copied into the working directory where I ran the <code>./devfile</code> command.
This was the moment I figured I might be on to something worth spending some
more time on.</p>
<h2 id="one-step-back-and-three-steps-forward">One step back and three steps forward</h2>
<p>The <code>I'll copy some stuff from the Internet into your working directory when you
parse a devfile</code> thing was very promising. I was hoping to use this vector to
gain an arbitrary file write from it. Should be easy enough, all I needed to do
was to figure out the code path from within GitLab to trigger the dependency to
flatten a devfile I crafted. That, and yes maybe a traversal out of the working
directory, maybe not. That would depend on my current unknowns where on a GitLab
instance this working directory would be and what I would control in terms of
written files. But overall, this issue looked like a juicy starting place.</p>
<p>So I took a deeper dive into the <a href="https://gitlab.com/gitlab-org/gitlab">main Ruby on Rails codebase of GitLab</a>,
just to find out that there's a validation to prevent the usage of that
<code>parent</code> feature in a <code>devfile</code>. This was really inconvenient, I almost saw that
awesome file write vanish in <a href="https://gitlab.com/gitlab-org/gitlab/-/blob/426689d290f0a7f86f2f01298e974c433ff235fb/ee/lib/remote_development/workspaces/create/pre_flatten_devfile_validator.rb#L53">that line of code</a>:</p>
<pre><code class="language-ruby hljs"><span class="hljs-keyword">return</span> err(_(<span class="hljs-string">"Inheriting from 'parent' is not yet supported"</span>)) <span class="hljs-keyword">if</span> devfile[<span class="hljs-string">'parent'</span>]
</code></pre>
<p>But it wasn't really that bad, this roadblock was something for which I was
prepared. In May 2023 I was "messing" with YAML files. This was
inspired by a <a href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">blog post from Jake Miller</a>
about parser differentials in JSON parsers, as JSON and YAML are somewhat similar
in their use cases, but YAML is a bit more complex I thought it might be worthwhile
looking at YAML from a parser differential perspective. <a href="https://threatactor.club/@joern/statuses/01H151R43VF3HNZR4G05HP9CP8">Back then</a>
I was able to craft a YAML file which would parse differently in Ruby and Python.
However it would parse the same in Ruby and in Go, so I "just" needed to find
a similar parser differential in Go and in Ruby. Let's first look at the initial
YAML file targeting Ruby/Go vs. Python:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>cat <span class="hljs-number">1</span>.yaml 
<span class="hljs-symbol">test:</span> python
!!binary dGVzdA==: ruby &amp; go
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>python -c <span class="hljs-string">'import yaml;x = yaml.safe_load(open("1.yaml"));print(x["test"])'</span>
python
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>ruby -ryaml -e <span class="hljs-string">'x = YAML.safe_load(File.read("1.yaml"));puts x["test"]'</span>
ruby &amp; go
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>cat g.go 
package main

import (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"log"</span>
        <span class="hljs-string">"os"</span>
        <span class="hljs-string">"gopkg.in/yaml.v3"</span>
)

func main() {
    data, _ <span class="hljs-symbol">:</span>= os.<span class="hljs-title class_">ReadFile</span>(os.<span class="hljs-title class_">Args</span>[<span class="hljs-number">1</span>])
        unmarshalled <span class="hljs-symbol">:</span>= &amp;yaml.<span class="hljs-title class_">Node</span>{}

        err <span class="hljs-symbol">:</span>= yaml.<span class="hljs-title class_">Unmarshal</span>([]byte(data), unmarshalled)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                log.<span class="hljs-title class_">Fatalf</span>(<span class="hljs-string">"error: %v"</span>, err)
        }
        var expanded interface{}
        err = unmarshalled.<span class="hljs-title class_">Content</span>[<span class="hljs-number">0</span>].<span class="hljs-title class_">Decode</span>(&amp;expanded)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                log.<span class="hljs-title class_">Fatalf</span>(<span class="hljs-string">"error: %v"</span>, err)
        }

        d, err <span class="hljs-symbol">:</span>= yaml.<span class="hljs-title class_">Marshal</span>(expanded)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                log.<span class="hljs-title class_">Fatalf</span>(<span class="hljs-string">"error: %v"</span>, err)
        }
        fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%s\n"</span>, string(d))
}

joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>go run g.go <span class="hljs-number">1</span>.yaml
<span class="hljs-symbol">test:</span> ruby &amp; go

</code></pre>
<p>The very simple "secret sauce" here is using the <a href="https://yaml.org/type/binary.html"><code>!!binary</code></a>
notation to introduce a Base64 encoded key:</p>
<pre><code class="language-yaml hljs"><span class="hljs-attr">test:</span> <span class="hljs-string">python</span>
<span class="hljs-type">!!binary</span> <span class="hljs-string">dGVzdA==:</span> <span class="hljs-string">ruby</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">go</span>
</code></pre>
<p>The Base64 (<code>!!binary</code>) string <code>dGVzdA==</code> becomes <code>test</code> when being decoded.
In Ruby and in Go this will overwrite the previously defined <code>test: python</code> value.
But in Python the following will happen:</p>
<pre><code class="hljs language-rust">python -c <span class="hljs-symbol">'import</span> yaml;y = yaml.<span class="hljs-title function_ invoke__">safe_load</span>(<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">"1.yaml"</span>));<span class="hljs-title function_ invoke__">print</span>(y)'        
{<span class="hljs-symbol">'test</span>': <span class="hljs-symbol">'python</span>', b<span class="hljs-symbol">'test</span>': <span class="hljs-symbol">'ruby</span> &amp; go'}
</code></pre>
<p>The <code>!!binary</code> notation will create a <a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview">Binary Sequence</a>
(<code>b'test'</code>) in Python which is different from the string <code>test</code>. So we'll have
two keys, <code>test</code> and <code>b'test'</code> here, instead of one overwriting the other like
it happens in Ruby and Go.</p>
<p>This behavior was the base I had ready, would GitLab have been a Python
code base with the same Go parser backend this would've been ready to
use right away to bypass the <code>parent</code> key filtering. Unfortunately this isn't
the case so I had to find a different way to bypass the key filter.</p>
<p>I spent a bit of time reading about <a href="https://yaml.org/spec/1.2.2/#3212-tags">Tags in YAML</a>
and noticed the line <code>Local tags start with “!”</code>. Well OK then I thought, let's
just try and see what happens when I use <code>!binary</code> instead of <code>!!binary</code>:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>cat <span class="hljs-number">2</span>.yaml
<span class="hljs-symbol">test:</span> non-binary 
!binary dGVzdA==: binary
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>ruby -ryaml -e <span class="hljs-string">'x = YAML.safe_load(File.read("2.yaml"));puts x'</span>
{<span class="hljs-string">"test"</span>=&gt;<span class="hljs-string">"binary"</span>}
joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>go run g.go <span class="hljs-number">2</span>.yaml
dGVzdA==: binary
<span class="hljs-symbol">test:</span> non-binary

joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>
</code></pre>
<p>Yes, it really was that "easy". Having this <code>!binary</code> behavior difference in Ruby and Go we
can construct a YAML file like:</p>
<pre><code class="language-yaml hljs"><span class="hljs-attr">whatever:</span> <span class="hljs-string">is</span> <span class="hljs-string">here</span>
<span class="hljs-type">!binary</span> <span class="hljs-attr">parent:</span> <span class="hljs-string">hehehe</span> <span class="hljs-string">injected</span>
</code></pre>
<p>Now when we look at it through the eyes of Ruby it will appear as:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>ruby -ryaml -e <span class="hljs-string">'x = YAML.safe_load(File.read("what.yaml"));puts x'</span>
{<span class="hljs-string">"whatever"</span>=&gt;<span class="hljs-string">"is here"</span>, <span class="hljs-string">"\xA5\xAA\xDE\x9E"</span>=&gt;<span class="hljs-string">"hehehe injected"</span>}
</code></pre>
<p>The <code>!binary</code> value has been decoded to a binary key <code>"\xA5\xAA\xDE\x9E"</code> and now,
<strong>drumroll</strong> for the Go parser:</p>
<pre><code class="hljs language-ruby">joern<span class="hljs-variable">@host2</span><span class="hljs-symbol">:~/projects/devfile</span><span class="hljs-variable">$ </span>go run g.go what.yaml 
<span class="hljs-symbol">parent:</span> hehehe injected
<span class="hljs-symbol">whatever:</span> is here
</code></pre>
<p>The <code>!binary</code> tag has just been silently dropped and the resulting YAML
key is called <code>parent</code>. These two behaviors combinded is exactly what we need
to bypass the Ruby validation for the <code>parent</code> key in the Devfile YAML.</p>
<h2 id="writing-files-where-they-dont-belong">Writing files where they don't belong</h2>
<p>Now that we're able to sneak the <code>parent</code> key past Ruby and into
the Go code it is time to dig deeper into the devfile library and
the odd file writing behavior to the working directory I noticed earlier.</p>
<p>First of all I wanted to know where that working directory was when the
<code>devfile</code> binary from the Gem was called on a GitLab instance. I was hoping
that it would be somewhat useful directory from an exploitation perspective.</p>
<p>To find this out I looked at the <a href="https://docs.gitlab.com/ee/user/workspace/configuration.html#set-up-a-workspace">documentation howto set up GitLab Workspaces</a>.
There's quite a lot of requirements here to set up those Workspaces properly,
a Kubernetes Cluster and a GitLab Agent for it, as well as certain configuration
projects on the GitLab instance to set up and tie everything together. The TL;DR
of my test setup was to run everything locally. GitLab was run using Docker
and the Kubernetes side was set up with <a href="https://minikube.sigs.k8s.io/"><code>minikube</code></a>.</p>
<p>With those two pieces in place we can connect the <code>minkube</code> cluster with the
<a href="https://docs.gitlab.com/ee/user/clusters/agent/">GitLab Agent</a> to a project
in a group on the GitLab instance. In another within the same group we can
then create a <code>.devfile.yaml</code> with the following content:</p>
<pre><code class="language-yaml hljs"><span class="hljs-attr">schemaVersion:</span> <span class="hljs-number">2.2</span><span class="hljs-number">.0</span>
<span class="hljs-type">!binary</span> <span class="hljs-attr">parent:</span> 
    <span class="hljs-attr">uri:</span> <span class="hljs-string">https://raw.githubusercontent.com/devfile/registry/main/stacks/nodejs/devfile.yaml'</span>
</code></pre>
<p>To trigger the Devfile parsing we now just need to create a workspace for that
project:</p>
<p><img alt="new workspace" src="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/new-workspace.png"></p>
<p>After this step I logged into the GitLab Docker container and searched for the
file <code>stack.yaml</code> which was present when I parsed the same Devfile earlier when
I initially observed the file writing behavior.</p>
<pre><code class="hljs language-ruby">root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># find . -name stack.yaml 2&gt; /dev/null </span>
./var/opt/gitlab/gitlab-rails/working/stack.yaml
root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># cd /var/opt/gitlab/gitlab-rails/working/</span>
root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/var/opt/gitlab/gitlab-rails/working</span><span class="hljs-comment"># ls -lart</span>
total <span class="hljs-number">46</span>
drwxr-xr-x <span class="hljs-number">9</span> git root  <span class="hljs-number">12</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">59</span> ..
-rw-r--r-- <span class="hljs-number">1</span> git git  <span class="hljs-number">283</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><span class="hljs-symbol">:</span>09 stack.yaml
-rw-r--r-- <span class="hljs-number">1</span> git git   <span class="hljs-number">73</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><span class="hljs-symbol">:</span>09 <span class="hljs-variable constant_">OWNERS</span>
drwxr-xr-x <span class="hljs-number">2</span> git git    <span class="hljs-number">2</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><span class="hljs-symbol">:</span>09 <span class="hljs-number">2.2</span>.<span class="hljs-number">0</span>
drwxr-xr-x <span class="hljs-number">2</span> git git    <span class="hljs-number">2</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><span class="hljs-symbol">:</span>09 <span class="hljs-number">2.1</span>.<span class="hljs-number">1</span>
drwx------ <span class="hljs-number">4</span> git root   <span class="hljs-number">6</span> <span class="hljs-title class_">Apr</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><span class="hljs-symbol">:</span>09 .
</code></pre>
<p>This result was not very promising, the directory was empty besides the files
written via the Devfile parser. While there might be some race conditions with
other parts of GitLab where we could write into temporary directories I decided
to not go down this route and instead dig deeper into the <a href="https://github.com/devfile/library">Devfile library</a>.</p>
<p>The main logic which parses the <code>parent</code> key in the Devfile was quickly
identified. It starts in <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L301"><code>parseParentAndPlugin()</code></a>.
The name of the function already indicates another similar feature comparable to
<code>parent</code>, namely the <a href="https://devfile.io/docs/2.0.0/adding-plugin-component"><code>plugin</code></a>.
As both features, <code>parent</code> and <code>plugin</code> had pretty much the same underlying logic
in a switch statement for <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L381-L390"><code>plugin</code></a>
and for <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L320-L328"><code>parent</code></a>:</p>
<pre><code class="language-go hljs"><span class="hljs-keyword">switch</span> {
<span class="hljs-keyword">case</span> parent.Uri != <span class="hljs-string">""</span>:
    parentDevfileObj, err = parseFromURI(parent.ImportReference, d.Ctx, resolveCtx, tool)
<span class="hljs-keyword">case</span> parent.Id != <span class="hljs-string">""</span>:
    parentDevfileObj, err = parseFromRegistry(parent.ImportReference, resolveCtx, tool)
<span class="hljs-keyword">case</span> parent.Kubernetes != <span class="hljs-literal">nil</span>:
    parentDevfileObj, err = parseFromKubeCRD(parent.ImportReference, resolveCtx, tool)
<span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"devfile parent does not define any resources"</span>)
}
</code></pre>
<p>I digged deeper into the <code>parseFrom*</code> methods. At first I looked into
<code>parseFromURI</code>, a URI to download a Devfile from I thought, should be easy enough.
Surprisingly it was not that easy. The <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L442-L503"><code>parseFromURI</code> function</a>
had quite some logic involved about local and remote URLs. What caught
my attention <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L491-L496">was</a>:</p>
<pre><code class="language-go hljs"><span class="hljs-keyword">if</span> tool.downloadGitResources {
    destDir := path.Dir(curDevfileCtx.GetAbsPath())
    err = tool.devfileUtilsClient.DownloadGitRepoResources(newUri, destDir, token)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> DevfileObj{}, err
    }
</code></pre>
<p>Litte did I know back when I examined this code about <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-49569">CVE-2023-49569</a>:</p>
<blockquote>
<p>CVE-2023-49569
A path traversal vulnerability was discovered in go-git versions prior to v5.11. This vulnerability allows an attacker to create and amend files across the filesystem. In the worse case scenario, remote code execution could be achieved.</p>
</blockquote>
<p>This vulnerability was published on January 12th, and could have been very useful
for my proposed attack as the Devfile library utilizes <code>go-git</code> for the underlying
Git operations. However when I was looking at the Devfile library this vulnerability
was not public yet. I <em>might</em> have found it if I had decided to dig deeper into the
Git operations, but I didn't ;). Instead when I was realizing that a simple URL
pointing to one of either <code>gitlab.com</code>, <code>github.com</code>, <code>raw.githubusercontent.com</code>
or <code>bitbucket.org</code> the Devfile library would do its magic and try to <code>git clone</code>
the according repository to get the referenced files.</p>
<p>The relevant implementation parts are</p>
<p>In <a href="https://github.com/devfile/library/blob/main/pkg/devfile/parser/util/utils.go#L47">pkg/devfile/parser/util/utils.go</a></p>
<pre><code class="language-go hljs"><span class="hljs-comment">// DownloadGitRepoResources downloads the git repository resources</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c DevfileUtilsClient)</span></span> DownloadGitRepoResources(url <span class="hljs-type">string</span>, destDir <span class="hljs-type">string</span>, token <span class="hljs-type">string</span>) <span class="hljs-type">error</span> {
    <span class="hljs-keyword">var</span> returnedErr <span class="hljs-type">error</span>
    <span class="hljs-keyword">if</span> util.IsGitProviderRepo(url) {
        gitUrl, err := util.NewGitURL(url, token)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> err
        }

        <span class="hljs-keyword">if</span> !gitUrl.IsFile || gitUrl.Revision == <span class="hljs-string">""</span> || !ValidateDevfileExistence((gitUrl.Path)) {
            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"error getting devfile from url: failed to retrieve %s"</span>, url)
        }

        stackDir, err := os.MkdirTemp(<span class="hljs-string">""</span>, <span class="hljs-string">"git-resources"</span>)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"failed to create dir: %s, error: %v"</span>, stackDir, err)
        }

        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> {
            err := os.RemoveAll(path)
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                returnedErr = multierror.Append(returnedErr, err)
            }
        }(stackDir)

        gitUrl.Token = token

        err = gitUrl.CloneGitRepo(stackDir)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            returnedErr = multierror.Append(returnedErr, err)
            <span class="hljs-keyword">return</span> returnedErr
        }

        dir := path.Dir(path.Join(stackDir, gitUrl.Path))
        err = util.CopyAllDirFiles(dir, destDir)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            returnedErr = multierror.Append(returnedErr, err)
            <span class="hljs-keyword">return</span> returnedErr
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"failed to download resources from parent devfile.  Unsupported Git Provider for %s "</span>, url)
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre>
<p>and in <a href="https://github.com/devfile/library/blob/main/pkg/util/util.go#L892">/pkg/util/util.go</a>:</p>
<pre><code class="language-go hljs"><span class="hljs-comment">// IsGitProviderRepo checks if the url matches a repo from a supported git provider</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsGitProviderRepo</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">if</span> strings.Contains(url, RawGitHubHost) || strings.Contains(url, GitHubHost) ||
        strings.Contains(url, GitLabHost) || strings.Contains(url, BitbucketHost) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
</code></pre>
<p>So instead of digging into the <code>go-git</code> path here I performed some simple
checks using symbolic links in repositories to see if that would bring me any
further. That wasn't the case, so next I started looking into <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L505"><code>parseFromRegistry</code></a>. A <a href="https://devfile.io/docs/2.1.0/understanding-a-devfile-registry">registry</a>
for Devfiles is based on the Open Container Initiative (OCI) Specification and pretty
much behaves like for instance a Docker registry.</p>
<p>Diving into <code>parseFromRegistry</code> quickly escalated as I was confronted with just
another dependency of the dependency. <code>parseFromRegistry</code> calls <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L568"><code>getResourcesFromRegistry</code></a>
which itself <a href="https://github.com/devfile/library/blob/v2.2.1/pkg/devfile/parser/parse.go#L575">leaves the heavy-lifting</a>
to <code>registryLibrary</code>. <a href="https://github.com/devfile/registry-support">This library</a>,
<code>registry-support</code> is also developed by the Devfile project and I decided to
take a look at it. After following the code flow, I arrived at the  <a href="https://github.com/devfile/registry-support/blob/47b3ffaeadba7babb7075e0576584cfaa3f64341/registry-library/library/library.go#L295"><code>PullStackFromRegistry</code></a>
function, which calls
the <a href="https://github.com/devfile/registry-support/blob/47b3ffaeadba7babb7075e0576584cfaa3f64341/registry-library/library/util.go#L76"><code>decompress</code></a>
function, which takes a <code>tar.gz</code> archive from the registry
library and extracts the files inside that archive. Let's have a look
at that <code>decompress</code> function:</p>
<pre><code class="language-go hljs"><span class="hljs-comment">// decompress extracts the archive file</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decompress</span><span class="hljs-params">(targetDir <span class="hljs-type">string</span>, tarFile <span class="hljs-type">string</span>, excludeFiles []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> {
    <span class="hljs-keyword">var</span> returnedErr <span class="hljs-type">error</span>

    reader, err := os.Open(filepath.Clean(tarFile))
...
    gzReader, err := gzip.NewReader(reader)
...
    tarReader := tar.NewReader(gzReader)
    <span class="hljs-keyword">for</span> {
...

        target := path.Join(targetDir, filepath.Clean(header.Name))
        <span class="hljs-keyword">switch</span> header.Typeflag {
...
        <span class="hljs-keyword">case</span> tar.TypeReg:
            <span class="hljs-comment">/* #nosec G304 -- target is produced using path.Join which cleans the dir path */</span>
            w, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                returnedErr = multierror.Append(returnedErr, err)
                <span class="hljs-keyword">return</span> returnedErr
            }
            <span class="hljs-comment">/* #nosec G110 -- starter projects are vetted before they are added to a registry.  Their contents can be seen before they are downloaded */</span>
            _, err = io.Copy(w, tarReader)
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                returnedErr = multierror.Append(returnedErr, err)
                <span class="hljs-keyword">return</span> returnedErr
            }
            err = w.Close()
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                returnedErr = multierror.Append(returnedErr, err)
                <span class="hljs-keyword">return</span> returnedErr
            }
        <span class="hljs-keyword">default</span>:
            log.Printf(<span class="hljs-string">"Unsupported type: %v"</span>, header.Typeflag)
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre>
<p>This looked promising: the line</p>
<pre><code class="language-go hljs">target := path.Join(targetDir, filepath.Clean(header.Name))
</code></pre>
<p>followed by:</p>
<pre><code class="language-go hljs"><span class="hljs-comment">/* #nosec G304 -- target is produced using path.Join which cleans the dir path */</span>
w, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))
</code></pre>
<p>The <a href="https://securego.io/docs/rules/g304.html">gosec rule 304</a>,
<code>File path provided as taint input</code>, had alerted here and the developer had 
instructed the gosec scanner to ignore the finding. The comment even gives us
the reasoning for this:
<code>target is produced using path.Join which cleans the dir path</code>, which
references how the <code>filepath.Clean(header.Name)</code> is used a little earlier in the code
flow.</p>
<p>However <a href="https://pkg.go.dev/path/filepath#Clean"><code>filepath.Clean</code></a> does not work
as expected here. It's not really obvious from the documentation either, but when
supplying a relative path to <code>filepath.Clean</code> the <code>Clean()</code>ed path will stay relative.</p>
<p>Consider the following example:</p>
<pre><code class="language-go hljs"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"path/filepath"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Println(filepath.Clean(<span class="hljs-string">"/../../../../../../../tmp/test"</span>)) <span class="hljs-comment">// absolute path</span>
    fmt.Println(filepath.Clean(<span class="hljs-string">"../../../../../../../tmp/test"</span>))  <span class="hljs-comment">// relative path</span>
}
</code></pre>
<p>The output of this program is:</p>
<pre><code class="hljs language-bash">/tmp/test
../../../../../../../tmp/test
</code></pre>
<p>And this was the missing puzzle piece for a successful exploit. Tar files
can contain <code>/</code>es and <code>.</code>s in their entry names. So we can traverse out of
the intended directory and decompress and write files to arbitrary locations
on disk when including a <code>parent</code> from a registry in the Devfile.</p>
<p>After this path traversal was identified a lot of time actually went into
setting up a fake registry server and delivering a proper payload. In total
this vulnerability, from starting to look into the Devfile Gem to having the
a working exploit ready took about two working days where a lot of time was
spent in setting up both the Workspaces feature and the fake registry.</p>
<h2 id="conclusions">Conclusions</h2>
<p>There are several takeaways more or less hidden between the lines
in this post I would like to highlight here.</p>
<h3 id="parser-differentials">Parser differentials</h3>
<p>Parser differentials can be a very powerful tool when it comes
to exploitation. They are very context dependent though and hard
to generalize in their use for exploiting software.</p>
<h3 id="dont-trust-the-comments">Don't trust the comments</h3>
<p>For once the SAST scanner was right. The path traversal was not stopped
by <code>filepath.Clean</code>, but the comment's author <a href="https://github.com/devfile/registry-support/blob/47b3ffaeadba7babb7075e0576584cfaa3f64341/registry-library/library/util.go#L124">thought it was</a>.
They explicitly turned off the gosec warning. The whole point in software exploitation
is to let some software do what it wasn't intended to do by the authors.
This means when reading comments in source code they should be taken as
an inspiration to think <code>how can I falsify this comment?</code>.</p>
<h3 id="keeps-on-giving"><code>../</code> keeps on giving</h3>
<p>The character sequence <code>../</code> is really a gift which keeps on giving.
Path traversals most of the time are simple and reliably to exploit.
They've been around 30+ years, still this vulnerability class has not
yet been solved.</p>
<h3 id="cant-find-all-the-bugs">Can't find all the bugs</h3>
<p>The go-git vulnerability (<a href="https://nvd.nist.gov/vuln/detail/CVE-2023-49569">CVE-2023-49569</a>)
was disclosed only a few days after I internally reported the file write
issue based on the registry parser. This vulnerability used in combination
with the parser differential would have been another way to write files
where they don't belong. The message here is kind of two fold: while it might
not be possible to find all the bugs there's often enough bugs to reach
your goal in a sufficiently big code base. ;)</p>
<h3 id="keep-digging-everyone">Keep digging everyone</h3>
<p>Finally, I'd like to highlight that to find vulnerabilities
it's always worth digging into source code, reading it and trying to understand the
assumptions under which it has been developed. The real hard part is to "know"
where to look and when to stop looking.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/base.js"></script>
        <script src="./Devfile file write vulnerability in GitLab - GitLab Security Tech Notes_files/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" aria-labelledby="searchModalLabel" style="display: none;" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"><p>No results found</p></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table table-striped table-hover">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    

</body></html>