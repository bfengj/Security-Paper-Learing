# Devfile file write vulnerability in GitLab - GitLab Security Tech Notes

主要是作者通过挖掘了gitlab的Devfile这个功能，挖掘到了一个任意文件写的漏洞。

前因就是Devfile会解析yaml，在解析的时候又调用了go的一个二进制来解析，发现go的这个二进制文件的`parent`键可以利用，但是在ruby中被过滤了。进一步研究yaml，发现go和ruby在解析yaml上的不同之处：

```yaml
whatever: is here
!binary parent: hehehe injected
```

正常指定二进制是`!!binary`，但是以`!`开头是用来指示本地tag。但是在ruby中，支持了`!binary`是二进制，导致会base64解码`parent`，在go中则是不解析，导致了差异：

```bash
ruby -ryaml -e 'x = YAML.safe_load(File.read("what.yaml"));puts x'
{"whatever"=>"is here", "\xA5\xAA\xDE\x9E"=>"hehehe injected"}


go run g.go what.yaml 
parent: hehehe injected
whatever: is here
```

因此可以利用这个差异来进行绕过。文章还提到`python`的解析差异：

```bash
test: python
!!binary dGVzdA==: ruby & go


python -c 'import yaml;y = yaml.safe_load(open("1.yaml"));print(y)'        
{'test': 'python', b'test': 'ruby & go'}
```



如果是`!binary`，python会直接报错。



后续的内容就是作者进一步阅读代码，找到了一个解压的路径穿越，实现了任意文件写，而且这个路径穿越也是go中有意思的一个点：

```go
target := path.Join(targetDir, filepath.Clean(header.Name))
```

对于`filepath.Clean`，如果提供的是相对路径则字符串将保持不变：

```go
package main

import (
    "fmt"
    "path/filepath"
)

func main() {
    fmt.Println(filepath.Clean("/../../../../../../../tmp/test")) // absolute path
    fmt.Println(filepath.Clean("../../../../../../../tmp/test"))  // relative path
}

```



```bash
go run test.go
/tmp/test
../../../../../../../tmp/test
```

而且这个`filepath.Clean`在windows中还会存在问题：

```bash
./ c:/1.txt
c:/1.txt
```

但是go官方已经修复了，新版本的go不会有这个问题。

总的来说这个洞还是比较有意思的，而且作者最后说挖出这个洞只用了2天，而且大部分时间是在构建registry，有点佩服作者了。